<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Celery在Django 项目中如何使用</title>
      <link href="/2019/09/30/Celery%E5%9C%A8Django%20%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/09/30/Celery%E5%9C%A8Django%20%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="创建目录celery-pro，并在celery-pro下创建下面两个文件"><a href="#创建目录celery-pro，并在celery-pro下创建下面两个文件" class="headerlink" title="创建目录celery_pro，并在celery_pro下创建下面两个文件"></a>创建目录celery_pro，并在celery_pro下创建下面两个文件</h3><p>celery.py</p><pre class="highlight"><span class="line"># celery.py</span><br><span class="line"># -*- coding:utf8 -*-</span><br><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line">#1. absolute_import 可以使导入的celery是python绝对路基的celery模块，不是当前我们创建的celery.py</span><br><span class="line">#2. unicode_literals 模块可能是python2和3兼容的，不知道</span><br><span class="line">from celery import Celery</span><br><span class="line"># from .celery import Celery        #这样才是导入当前目录下的celery</span><br><span class="line"># 填写你的项目名</span><br><span class="line">app &#x3D; Celery(&#39;project&#39;,</span><br><span class="line">             broker&#x3D;&#39;redis:&#x2F;&#x2F;localhost&#39;,</span><br><span class="line">             backend&#x3D;&#39;redis:&#x2F;&#x2F;localhost&#39;,</span><br><span class="line">             include&#x3D;[&#39;celery_pro.tasks&#39;,</span><br><span class="line">                      &#39;celery_pro.tasks2&#39;,</span><br><span class="line">                      ])</span><br><span class="line">#celery——pro是存放celery文件的文件夹名字</span><br><span class="line"></span><br><span class="line">#实例化时可以添加下面这个属性</span><br><span class="line">app.conf.update(</span><br><span class="line">   result_expires&#x3D;3600,        #执行结果放到redis里，一个小时没人取就丢弃</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 配置定时任务：每5秒钟执行 调用一次celery_pro下tasks.py文件中的add函数</span><br><span class="line">app.conf.beat_schedule &#x3D; &#123;</span><br><span class="line">    &#39;add-every-5-seconds&#39;: &#123;</span><br><span class="line">        &#39;task&#39;: &#39;celery_pro.tasks.add&#39;,  # 寻找tasks下面的add函数</span><br><span class="line">        &#39;schedule&#39;: 5.0,</span><br><span class="line">        &#39;args&#39;: (16, 16)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">app.conf.timezone &#x3D; &#39;UTC&#39;   # 配置的时间规范</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">   app.start()</span><br></pre><h3 id="task-py"><a href="#task-py" class="headerlink" title="task.py"></a>task.py</h3><pre class="highlight"><span class="line"># task.py</span><br><span class="line"># -*- coding:utf8 -*-</span><br><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line">from .celery import app       #从当前目录导入app</span><br><span class="line"></span><br><span class="line">#写一个add函数</span><br><span class="line">@app.task</span><br><span class="line">def add(x, y):</span><br><span class="line">    return x + y</span><br></pre><h3 id="task2-py"><a href="#task2-py" class="headerlink" title="task2.py"></a>task2.py</h3><pre class="highlight"><span class="line"># task2.py</span><br><span class="line"># -*- coding:utf8 -*-</span><br><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line">from .celery import app</span><br><span class="line">import time,random</span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def randnum(start,end):</span><br><span class="line">    time.sleep(3)</span><br><span class="line">    return random.randint(start,end)</span><br><span class="line"></span><br><span class="line">tasks2.py</span><br></pre><p>touch <strong>init</strong>.py<br>在celery_pro目录下新建<strong>init</strong>.py文件，否则执行命令时会报错</p><h3 id="执行下面两条命令即可让celery定时执行任务了"><a href="#执行下面两条命令即可让celery定时执行任务了" class="headerlink" title="执行下面两条命令即可让celery定时执行任务了"></a>执行下面两条命令即可让celery定时执行任务了</h3><ol><li><p>启动一个worker：在celery_pro外层目录下执行<br>celery -A celery_pro worker -l info</p></li><li><p>启动任务调度器 celery beat<br>celery -A celery_pro beat -l info</p></li><li><p>执行效果<br>看到celery运行日志中每5秒回返回一次 add函数执行结果</p></li></ol><h3 id="启动celery的worker：每台机器可以启动8个worker"><a href="#启动celery的worker：每台机器可以启动8个worker" class="headerlink" title="启动celery的worker：每台机器可以启动8个worker"></a>启动celery的worker：每台机器可以启动8个worker</h3><ol><li>在pythondir目录下启动 /pythondir/celery_pro/ 目录下的worker</li></ol><p>celery -A celery_pro worker -l info</p><ol start="2"><li>后台启动worker：/pythondir/celery_pro/目录下执行</li></ol><pre class="highlight"><span class="line">celery multi start w1 -A celery_pro -l info             #在后台启动w1这个worker</span><br><span class="line"></span><br><span class="line">celery multi start w1 w2 -A celery_pro -l info       #一次性启动w1,w2两个worker</span><br><span class="line"></span><br><span class="line">celery -A celery_pro status                       #查看当前有哪些worker在运行</span><br><span class="line"></span><br><span class="line">celery multi stop w1 w2 -A celery_pro                   #停止w1,w2两个worker</span><br><span class="line"></span><br><span class="line">celery multi restart w1 w2 -A celery_pro               #重启w1,w2两个worker</span><br></pre><h3 id="也可以手动给celery分配任务：在-pythondir-下执行"><a href="#也可以手动给celery分配任务：在-pythondir-下执行" class="headerlink" title="也可以手动给celery分配任务：在/pythondir/下执行"></a>也可以手动给celery分配任务：在/pythondir/下执行</h3><pre class="highlight"><span class="line">python3</span><br><span class="line">from celery_pro import tasks,tasks2</span><br><span class="line"></span><br><span class="line">t1 &#x3D; tasks.add.delay(34,3)</span><br><span class="line">t2 &#x3D; tasks2.randnum.delay(1,10000)             </span><br><span class="line">t1.get()</span><br><span class="line">t2.get()</span><br><span class="line"></span><br><span class="line">手动给celery分配任务：在&#x2F;pythondir&#x2F;下执行</span><br></pre><h3 id="celery与Django项目最佳实践"><a href="#celery与Django项目最佳实践" class="headerlink" title="celery与Django项目最佳实践"></a>celery与Django项目最佳实践</h3><pre class="highlight"><span class="line">pip3 install Django&#x3D;&#x3D;2.0.4</span><br><span class="line">pip3 install celery&#x3D;&#x3D;4.3.0</span><br><span class="line">pip3 install redis&#x3D;&#x3D;3.2.1</span><br><span class="line">pip3 install ipython&#x3D;&#x3D;7.6.1 </span><br><span class="line"></span><br><span class="line">find .&#x2F; -type f | xargs sed -i &#39;s&#x2F;\r$&#x2F;&#x2F;g&#39;     # 批量将当前文件夹下所有文件装换成unix格式</span><br><span class="line">celery  multi start celery_test -A celery_test -l debug --autoscale&#x3D;50,5        # celery并发数：最多50个，最少5个</span><br><span class="line">http:&#x2F;&#x2F;docs.celeryproject.org&#x2F;en&#x2F;latest&#x2F;reference&#x2F;celery.bin.worker.html#cmdoption-celery-worker-autoscale</span><br><span class="line">ps auxww|grep &quot;celery worker&quot;|grep -v grep|awk &#39;&#123;print $2&#125;&#39;|xargs kill -9       # 关闭所有celery进程</span><br></pre><h3 id="在Django中使用celery介绍（celery无法再windows下运行）"><a href="#在Django中使用celery介绍（celery无法再windows下运行）" class="headerlink" title="在Django中使用celery介绍（celery无法再windows下运行）"></a>在Django中使用celery介绍（celery无法再windows下运行）</h3><ol><li><p>在Django中使用celery时，celery文件必须以tasks.py</p></li><li><p>Django会自动到每个APP中找tasks.py文件</p></li></ol><h3 id="创建一个Django项目celery-test，和app01"><a href="#创建一个Django项目celery-test，和app01" class="headerlink" title="创建一个Django项目celery_test，和app01"></a>创建一个Django项目celery_test，和app01</h3><h3 id="在与项目同名的目录下创建celery-py"><a href="#在与项目同名的目录下创建celery-py" class="headerlink" title="在与项目同名的目录下创建celery.py"></a>在与项目同名的目录下创建celery.py</h3><pre class="highlight"><span class="line"># celery.py</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from __future__ import absolute_import</span><br><span class="line">import os</span><br><span class="line">from celery import Celery</span><br><span class="line"></span><br><span class="line"># 只要是想在自己的脚本中访问Django的数据库等文件就必须配置Django的环境变量</span><br><span class="line">os.environ.setdefault(&#39;DJANGO_SETTINGS_MODULE&#39;, &#39;celery_test.settings&#39;)</span><br><span class="line"></span><br><span class="line"># app名字</span><br><span class="line">app &#x3D; Celery(&#39;celery_test&#39;)</span><br><span class="line"></span><br><span class="line"># 配置celery</span><br><span class="line">class Config:</span><br><span class="line">    BROKER_URL &#x3D; &#39;redis:&#x2F;&#x2F;192.168.56.11:6379&#39;</span><br><span class="line">    CELERY_RESULT_BACKEND &#x3D; &#39;redis:&#x2F;&#x2F;192.168.56.11:6379&#39;</span><br><span class="line"></span><br><span class="line">app.config_from_object(Config)</span><br><span class="line"># 到各个APP里自动发现tasks.py文件</span><br><span class="line">app.autodiscover_tasks()</span><br><span class="line"></span><br></pre><h3 id="在与项目同名的目录下的-init-py-文件中添加下面内容"><a href="#在与项目同名的目录下的-init-py-文件中添加下面内容" class="headerlink" title="在与项目同名的目录下的 init.py 文件中添加下面内容"></a>在与项目同名的目录下的 init.py 文件中添加下面内容</h3><pre class="highlight"><span class="line"># __init__.py </span><br><span class="line"># -*- coding:utf8 -*-</span><br><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line"></span><br><span class="line"># 告诉Django在启动时别忘了检测我的celery文件</span><br><span class="line">from .celery import app as celery_ap</span><br><span class="line">__all__ &#x3D; [&#39;celery_app&#39;]</span><br><span class="line"></span><br></pre><h3 id="创建app01-tasks-py文件"><a href="#创建app01-tasks-py文件" class="headerlink" title="创建app01/tasks.py文件"></a>创建app01/tasks.py文件</h3><pre class="highlight"><span class="line"># tasks.py</span><br><span class="line"># -*- coding:utf8 -*-</span><br><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line">from celery import shared_task</span><br><span class="line"></span><br><span class="line"># 这里不再使用@app.task,而是用@shared_task，是指定可以在其他APP中也可以调用这个任务</span><br><span class="line">@shared_task</span><br><span class="line">def add(x, y):</span><br><span class="line">   return x + y</span><br><span class="line"></span><br></pre><h3 id="在setings-py文件指定redis服务器的配置"><a href="#在setings-py文件指定redis服务器的配置" class="headerlink" title="在setings.py文件指定redis服务器的配置"></a>在setings.py文件指定redis服务器的配置</h3><pre class="highlight"><span class="line"># settings.py</span><br><span class="line">CELERY_BROKER_URL &#x3D; &#39;redis:&#x2F;&#x2F;localhost&#39;</span><br><span class="line">CELERY_RESULT_BACKEND &#x3D; &#39;redis:&#x2F;&#x2F;localhost&#39;</span><br></pre><h3 id="将celery-test这个Django项目拷贝到centos7-3的django-test文件夹中"><a href="#将celery-test这个Django项目拷贝到centos7-3的django-test文件夹中" class="headerlink" title="将celery_test这个Django项目拷贝到centos7.3的django_test文件夹中"></a>将celery_test这个Django项目拷贝到centos7.3的django_test文件夹中</h3><h3 id="保证启动了redis-server"><a href="#保证启动了redis-server" class="headerlink" title="保证启动了redis-server"></a>保证启动了redis-server</h3><h3 id="启动一个celery的worker"><a href="#启动一个celery的worker" class="headerlink" title="启动一个celery的worker"></a>启动一个celery的worker</h3><pre class="highlight"><span class="line">celery -A celery_test worker -l info</span><br></pre><h3 id="在Linux中启动-Django项目"><a href="#在Linux中启动-Django项目" class="headerlink" title="在Linux中启动 Django项目"></a>在Linux中启动 Django项目</h3><pre class="highlight"><span class="line">python3 manage.py runserver 0.0.0.0:9000</span><br></pre><h3 id="访问http-1-1-1-3-9000-celery-call-获取任务id"><a href="#访问http-1-1-1-3-9000-celery-call-获取任务id" class="headerlink" title="访问http://1.1.1.3:9000/celery_call/ 获取任务id"></a>访问<a href="http://1.1.1.3:9000/celery_call/">http://1.1.1.3:9000/celery_call/</a> 获取任务id</h3><p><img src="https://img-blog.csdnimg.cn/20200222231228719.png" alt="~~~~~~~~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200222231228719.png" class="lozad post-image"></p><h3 id="根据11中的任务id获取对应的值"><a href="#根据11中的任务id获取对应的值" class="headerlink" title="根据11中的任务id获取对应的值"></a>根据11中的任务id获取对应的值</h3><p><a href="http://1.1.1.3:9000/celery_result/?id=5065b65b-0c01-430a-a67f-9531fe3e8d90">http://1.1.1.3:9000/celery_result/?id=5065b65b-0c01-430a-a67f-9531fe3e8d90</a></p><h3 id="基于步骤↑：在django中使用计划任务功能"><a href="#基于步骤↑：在django中使用计划任务功能" class="headerlink" title="基于步骤↑：在django中使用计划任务功能"></a>基于步骤↑：在django中使用计划任务功能</h3><h3 id="在Django中使用celery的定时任务需要安装django-celery-beat"><a href="#在Django中使用celery的定时任务需要安装django-celery-beat" class="headerlink" title="在Django中使用celery的定时任务需要安装django-celery-beat"></a>在Django中使用celery的定时任务需要安装django-celery-beat</h3><pre class="highlight"><span class="line">pip3 install django-celery-beat</span><br></pre><h3 id="在Django的settings中注册django-celery-beat"><a href="#在Django的settings中注册django-celery-beat" class="headerlink" title="在Django的settings中注册django_celery_beat"></a>在Django的settings中注册django_celery_beat</h3><pre class="highlight"><span class="line">INSTALLED_APPS &#x3D; (</span><br><span class="line">        ...,</span><br><span class="line">        &#39;django_celery_beat&#39;,</span><br><span class="line">    )</span><br></pre><h3 id="执行创建表命令"><a href="#执行创建表命令" class="headerlink" title="执行创建表命令"></a>执行创建表命令</h3><pre class="highlight"><span class="line">python3 manage.py makemigrations</span><br><span class="line"></span><br><span class="line">python3 manage.py migrate</span><br><span class="line"></span><br><span class="line">python3 manage.py startsuperuser</span><br><span class="line"></span><br></pre><h3 id="运行Django项目"><a href="#运行Django项目" class="headerlink" title="运行Django项目"></a>运行Django项目</h3><pre class="highlight"><span class="line">celery -A celery_test worker -l info</span><br><span class="line"></span><br><span class="line">python3 manage.py runserver 0.0.0.0:9000</span><br></pre><h3 id="登录-http-1-1-1-3-9000-admin-可以看到多了三张表"><a href="#登录-http-1-1-1-3-9000-admin-可以看到多了三张表" class="headerlink" title="登录 http://1.1.1.3:9000/admin/ 可以看到多了三张表"></a>登录 <a href="http://1.1.1.3:9000/admin/">http://1.1.1.3:9000/admin/</a> 可以看到多了三张表</h3><p><img src="https://img-blog.csdnimg.cn/20200222231719454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="~~~~~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200222231719454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><h3 id="在intervals表中添加一条每5秒钟执行一次的任务的时钟"><a href="#在intervals表中添加一条每5秒钟执行一次的任务的时钟" class="headerlink" title="在intervals表中添加一条每5秒钟执行一次的任务的时钟"></a>在intervals表中添加一条每5秒钟执行一次的任务的时钟</h3><p>![<del>~</del>`](<a href="https://img-blog.csdnimg.cn/20200222231733989.png">https://img-blog.csdnimg.cn/20200222231733989.png</a>)</p><h3 id="在Periodic-tasks表中创建任务"><a href="#在Periodic-tasks表中创建任务" class="headerlink" title="在Periodic tasks表中创建任务"></a>在Periodic tasks表中创建任务</h3><p><img src="https://img-blog.csdnimg.cn/20200222231750136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="````````````" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200222231750136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><h3 id="在-django-test-celery-test-目录下执行下面命令"><a href="#在-django-test-celery-test-目录下执行下面命令" class="headerlink" title="在/django_test/celery_test/目录下执行下面命令"></a>在/django_test/celery_test/目录下执行下面命令</h3><pre class="highlight"><span class="line">celery -A celery_test worker -l info                                                   #启动一个worker</span><br><span class="line"></span><br><span class="line">python manage.py runserver 0.0.0.0:9000                           #运行Django项目</span><br><span class="line"></span><br><span class="line">celery -A celery_test beat -l info -S django                                                   #启动心跳任务</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">运行上面命令后就可以看到在运行celery -A celery_test worker -l info         窗口中每5秒钟执行一次app01.tasks.add： 2+3&#x3D;5</span><br></pre><h3 id="关于添加新任务必须重启心跳问题"><a href="#关于添加新任务必须重启心跳问题" class="headerlink" title="关于添加新任务必须重启心跳问题"></a>关于添加新任务必须重启心跳问题</h3><ol><li><p>每次在Django表中添加一个任务就必须重启一下beat</p></li><li><p>但是Django中有一个djcelery插件可以帮助我们不必重启</p><h3 id="cdjango-celery-redis实现异步周期任务"><a href="#cdjango-celery-redis实现异步周期任务" class="headerlink" title="cdjango+celery+redis实现异步周期任务"></a>cdjango+celery+redis实现异步周期任务</h3><h5 id="注：python的celery模块-4-2-0版本，-刚开始安装的未4-1-1版本，但是定时任务居然不执行"><a href="#注：python的celery模块-4-2-0版本，-刚开始安装的未4-1-1版本，但是定时任务居然不执行" class="headerlink" title="注：python的celery模块 4.2.0版本， 刚开始安装的未4.1.1版本，但是定时任务居然不执行"></a>注：python的celery模块 4.2.0版本， 刚开始安装的未4.1.1版本，但是定时任务居然不执行</h5></li></ol><h3 id="在settings-py中配置celery"><a href="#在settings-py中配置celery" class="headerlink" title="在settings.py中配置celery"></a>在settings.py中配置celery</h3><pre class="highlight"><span class="line"># settings.py</span><br><span class="line">#1、如果在django中需要周期性执行，在这里需要注册 django_celery_beat 中间件</span><br><span class="line">INSTALLED_APPS &#x3D; [</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    &#39;django_celery_beat&#39;,</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIME_ZONE &#x3D; &#39;Asia&#x2F;Shanghai&#39;  # 将默认的UTC时区给成中国时区</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2、celery：配置celery</span><br><span class="line">BROKER_URL &#x3D; &#39;redis:&#x2F;&#x2F;localhost:6379&#39;</span><br><span class="line">CELERY_RESULT_BACKEND &#x3D; &#39;redis:&#x2F;&#x2F;localhost:6379&#39;</span><br><span class="line">CELERY_ACCEPT_CONTENT &#x3D; [&#39;application&#x2F;json&#39;]</span><br><span class="line">CELERY_TASK_SERIALIZER &#x3D; &#39;json&#39;</span><br><span class="line">CELERY_RESULT_SERIALIZER &#x3D; &#39;json&#39;</span><br><span class="line">CELERY_TASK_RESULT_EXPIRES &#x3D; 60 * 60</span><br><span class="line">CELERY_TIMEZONE &#x3D; &#39;Asia&#x2F;Shanghai&#39;</span><br><span class="line">CELERY_ENABLE_UTC&#x3D;False</span><br><span class="line">CELERY_ANNOTATIONS &#x3D; &#123;&#39;*&#39;: &#123;&#39;rate_limit&#39;: &#39;500&#x2F;s&#39;&#125;&#125;</span><br><span class="line">CELERYBEAT_SCHEDULER &#x3D; &#39;djcelery.schedulers.DatabaseScheduler&#39;</span><br><span class="line"></span><br></pre><h3 id="在与项目同名的目录下创建celery-py-1"><a href="#在与项目同名的目录下创建celery-py-1" class="headerlink" title="在与项目同名的目录下创建celery.py"></a>在与项目同名的目录下创建celery.py</h3><p>更多定时参考官网：<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html#crontab-schedules">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html#crontab-schedules</a></p><pre class="highlight"><span class="line"># # -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from __future__ import absolute_import</span><br><span class="line">import os</span><br><span class="line">from celery import Celery</span><br><span class="line">from celery.schedules import crontab</span><br><span class="line">from datetime import timedelta</span><br><span class="line">from kombu import Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># set the default Django settings module for the &#39;celery&#39; program.</span><br><span class="line">os.environ.setdefault(&#39;DJANGO_SETTINGS_MODULE&#39;, &#39;celery_test.settings&#39;)</span><br><span class="line"></span><br><span class="line">from django.conf import settings</span><br><span class="line"></span><br><span class="line">app &#x3D; Celery(&#39;celery_test&#39;)</span><br><span class="line"></span><br><span class="line"># Using a string here means the worker will not have to</span><br><span class="line"># pickle the object when using Windows.</span><br><span class="line">class Config:</span><br><span class="line">    BROKER_URL &#x3D; &#39;redis:&#x2F;&#x2F;1.1.1.3:6379&#39;</span><br><span class="line">    CELERY_RESULT_BACKEND &#x3D; &#39;redis:&#x2F;&#x2F;1.1.1.3:6379&#39;</span><br><span class="line">    CELERY_ACCEPT_CONTENT &#x3D; [&#39;application&#x2F;json&#39;]</span><br><span class="line">    CELERY_TASK_SERIALIZER &#x3D; &#39;json&#39;</span><br><span class="line">    CELERY_RESULT_SERIALIZER &#x3D; &#39;json&#39;</span><br><span class="line">    CELERY_TIMEZONE &#x3D; &#39;Asia&#x2F;Shanghai&#39;</span><br><span class="line">    ENABLE_UTC &#x3D; False</span><br><span class="line">    CELERY_TASK_RESULT_EXPIRES &#x3D; 60 * 60</span><br><span class="line">    CELERY_ANNOTATIONS &#x3D; &#123;&#39;*&#39;: &#123;&#39;rate_limit&#39;: &#39;500&#x2F;s&#39;&#125;&#125;</span><br><span class="line">    # 每次取任务的数量</span><br><span class="line">    # CELERYD_PREFETCH_MULTIPLIER &#x3D; 10</span><br><span class="line">    # 每个worker执行多少次任务之后就销毁，防止内存泄漏。相当于--maxtasksperchild参数</span><br><span class="line">    CELERYD_MAX_TASKS_PER_CHILD &#x3D; 16</span><br><span class="line">    # 防止死锁</span><br><span class="line">    # CELERYD_FORCE_EXECV &#x3D; True</span><br><span class="line">    # 任务发出后，经过一段时间还未收到acknowledge , 就将任务重新交给其他worker执行</span><br><span class="line">    # CELERY_DISABLE_RATE_LIMITS &#x3D; True</span><br><span class="line">    # CELERYBEAT_SCHEDULER &#x3D; &#39;djcelery.schedulers.DatabaseScheduler&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.config_from_object(Config)</span><br><span class="line">app.autodiscover_tasks()</span><br><span class="line"></span><br><span class="line">#crontab config</span><br><span class="line">app.conf.update(</span><br><span class="line">    CELERYBEAT_SCHEDULE &#x3D; &#123;</span><br><span class="line">        # 每隔三分钟执行一次add函数</span><br><span class="line">        &#39;every-3-min-add&#39;: &#123;</span><br><span class="line">            &#39;task&#39;: &#39;app01.tasks.add&#39;,</span><br><span class="line">            &#39;schedule&#39;: timedelta(seconds&#x3D;180)</span><br><span class="line">        &#125;,</span><br><span class="line">        # 每天下午15:420执行</span><br><span class="line">        &#39;add-every-day-morning@14:50&#39;: &#123;</span><br><span class="line">            &#39;task&#39;: &#39;app01.tasks.minus&#39;,</span><br><span class="line">            &#39;schedule&#39;: crontab(hour&#x3D;15, minute&#x3D;20, day_of_week&#x3D;&#39;*&#x2F;1&#39;),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Queue(&#39;transient&#39;, routing_key&#x3D;&#39;transient&#39;,delivery_mode&#x3D;1)</span><br><span class="line"></span><br><span class="line">celery.py</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from __future__ import absolute_import</span><br><span class="line">import os</span><br><span class="line">from celery import Celery</span><br><span class="line">from celery.schedules import crontab</span><br><span class="line">from datetime import timedelta</span><br><span class="line">from kombu import Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># set the default Django settings module for the &#39;celery&#39; program.</span><br><span class="line">os.environ.setdefault(&#39;DJANGO_SETTINGS_MODULE&#39;, &#39;celery_test.settings&#39;)</span><br><span class="line"></span><br><span class="line">from django.conf import settings</span><br><span class="line"></span><br><span class="line">app &#x3D; Celery(&#39;celery_test&#39;)</span><br><span class="line"></span><br><span class="line"># Using a string here means the worker will not have to</span><br><span class="line"># pickle the object when using Windows.</span><br><span class="line">class Config:</span><br><span class="line">    BROKER_URL &#x3D; &#39;redis:&#x2F;&#x2F;1.1.1.3:6379&#39;</span><br><span class="line">    CELERY_RESULT_BACKEND &#x3D; &#39;redis:&#x2F;&#x2F;1.1.1.3:6379&#39;</span><br><span class="line">    CELERY_ACCEPT_CONTENT &#x3D; [&#39;application&#x2F;json&#39;]</span><br><span class="line">    CELERY_TASK_SERIALIZER &#x3D; &#39;json&#39;</span><br><span class="line">    CELERY_RESULT_SERIALIZER &#x3D; &#39;json&#39;</span><br><span class="line">    CELERY_TIMEZONE &#x3D; &#39;Asia&#x2F;Shanghai&#39;</span><br><span class="line">    ENABLE_UTC &#x3D; False</span><br><span class="line">    CELERY_TASK_RESULT_EXPIRES &#x3D; 60 * 60</span><br><span class="line">    CELERY_ANNOTATIONS &#x3D; &#123;&#39;*&#39;: &#123;&#39;rate_limit&#39;: &#39;500&#x2F;s&#39;&#125;&#125;</span><br><span class="line">    # 每次取任务的数量</span><br><span class="line">    # CELERYD_PREFETCH_MULTIPLIER &#x3D; 10</span><br><span class="line">    # 每个worker执行多少次任务之后就销毁，防止内存泄漏。相当于--maxtasksperchild参数</span><br><span class="line">    CELERYD_MAX_TASKS_PER_CHILD &#x3D; 16</span><br><span class="line">    # 防止死锁</span><br><span class="line">    # CELERYD_FORCE_EXECV &#x3D; True</span><br><span class="line">    # 任务发出后，经过一段时间还未收到acknowledge , 就将任务重新交给其他worker执行</span><br><span class="line">    # CELERY_DISABLE_RATE_LIMITS &#x3D; True</span><br><span class="line">    # CELERYBEAT_SCHEDULER &#x3D; &#39;djcelery.schedulers.DatabaseScheduler&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.config_from_object(Config)</span><br><span class="line">app.autodiscover_tasks()</span><br><span class="line"></span><br><span class="line">#crontab config</span><br><span class="line">app.conf.update(</span><br><span class="line">    CELERYBEAT_SCHEDULE &#x3D; &#123;</span><br><span class="line">        # 每隔三分钟执行一次add函数</span><br><span class="line">        &#39;every-3-min-add&#39;: &#123;</span><br><span class="line">            &#39;task&#39;: &#39;app01.tasks.add&#39;,</span><br><span class="line">            &#39;schedule&#39;: timedelta(seconds&#x3D;180)</span><br><span class="line">        &#125;,</span><br><span class="line">        # 每天下午15:420执行</span><br><span class="line">        &#39;add-every-day-morning@14:50&#39;: &#123;</span><br><span class="line">            &#39;task&#39;: &#39;app01.tasks.minus&#39;,</span><br><span class="line">            &#39;schedule&#39;: crontab(hour&#x3D;15, minute&#x3D;20, day_of_week&#x3D;&#39;*&#x2F;1&#39;),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Queue(&#39;transient&#39;, routing_key&#x3D;&#39;transient&#39;,delivery_mode&#x3D;1)</span><br><span class="line"></span><br><span class="line"></span><br></pre><h3 id="在任意app下创建tasks-py-django会自动到各app中找到此tasks文件"><a href="#在任意app下创建tasks-py-django会自动到各app中找到此tasks文件" class="headerlink" title="在任意app下创建tasks.py (django会自动到各app中找到此tasks文件)"></a>在任意app下创建tasks.py (django会自动到各app中找到此tasks文件)</h3><pre class="highlight"><span class="line"># tasks.py</span><br><span class="line"># -*- coding:utf8 -*-</span><br><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line">from celery import shared_task</span><br><span class="line"></span><br><span class="line"># 这里不再使用@app.task,而是用@shared_task，是指定可以在其他APP中也可以调用这个任务</span><br><span class="line">@shared_task</span><br><span class="line">def add():</span><br><span class="line">   print &#39;app01.tasks.add&#39;</span><br><span class="line">   return 222 + 333</span><br><span class="line"></span><br><span class="line">@shared_task</span><br><span class="line">def minus():</span><br><span class="line">   print &#39;app01.tasks.minus&#39;</span><br><span class="line">   return 222 - 333</span><br><span class="line"></span><br></pre><h3 id="在与项目同名的目录下的-init-py-文件中添加下面内容-1"><a href="#在与项目同名的目录下的-init-py-文件中添加下面内容-1" class="headerlink" title="在与项目同名的目录下的 init.py 文件中添加下面内容"></a>在与项目同名的目录下的 init.py 文件中添加下面内容</h3><pre class="highlight"><span class="line"># __init__.py</span><br><span class="line"># -*- coding:utf8 -*-</span><br><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line"></span><br><span class="line"># 告诉Django在启动时别忘了检测我的celery文件</span><br><span class="line">from .celery import app as celery_ap</span><br><span class="line">__all__ &#x3D; [&#39;celery_app&#39;]</span><br><span class="line"></span><br><span class="line"></span><br></pre><h3 id="启动脚本（记得开启celery服务）"><a href="#启动脚本（记得开启celery服务）" class="headerlink" title="启动脚本（记得开启celery服务）"></a>启动脚本（记得开启celery服务）</h3><h3 id="启动django程序"><a href="#启动django程序" class="headerlink" title="启动django程序"></a>启动django程序</h3><pre class="highlight"><span class="line">python manage.py runserver 0.0.0.0:8000</span><br></pre><pre class="highlight"><span class="line"># service.sh</span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env bash</span><br><span class="line"></span><br><span class="line">source ..&#x2F;env&#x2F;bin&#x2F;activate</span><br><span class="line"></span><br><span class="line">export DJANGO_SETTINGS_MODULE&#x3D;celery_test.settings</span><br><span class="line"></span><br><span class="line">base_dir&#x3D;&#96;pwd&#96;</span><br><span class="line">mup_pid() &#123;</span><br><span class="line">echo &#96;ps -ef | grep -E &quot;(manage.py)(.*):8000&quot; | grep -v grep| awk &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line">&#125;</span><br><span class="line">start() &#123;</span><br><span class="line"> python $base_dir&#x2F;manage.py runserver 0.0.0.0:8000 &amp;&gt;&gt; $base_dir&#x2F;django.log 2&gt;&amp;1 &amp;</span><br><span class="line"> pid&#x3D;$(mup_pid)</span><br><span class="line"> echo -e &quot;\e[00;31mmup is running (pid: $pid)\e[00m&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop() &#123;</span><br><span class="line"> pid&#x3D;$(mup_pid)</span><br><span class="line"> echo -e &quot;\e[00;31mmup is stop (pid: $pid)\e[00m&quot;</span><br><span class="line"> ps -ef | grep -E &quot;(manage.py)(.*):8000&quot; | grep -v grep| awk &#39;&#123;print $2&#125;&#39; | xargs kill -9 &amp;&gt; &#x2F;dev&#x2F;null</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restart()&#123;</span><br><span class="line">    stop</span><br><span class="line">    start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># See how we were called.</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">  start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">  stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">  restart)</span><br><span class="line">        restart</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">  *)</span><br><span class="line">        echo $&quot;Usage: $0 &#123;start|stop|restart&#125;&quot;</span><br><span class="line">        exit 2</span><br><span class="line">esac</span><br><span class="line"></span><br></pre><h3 id="启动celery的worker：每台机器可以启动8个worker-1"><a href="#启动celery的worker：每台机器可以启动8个worker-1" class="headerlink" title="启动celery的worker：每台机器可以启动8个worker"></a>启动celery的worker：每台机器可以启动8个worker</h3><pre class="highlight"><span class="line">celery -A celery_test worker -l info</span><br></pre><pre class="highlight"><span class="line"># start-celery.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">source ..&#x2F;env&#x2F;bin&#x2F;activate</span><br><span class="line">export C_FORCE_ROOT&#x3D;&quot;true&quot;</span><br><span class="line">base_dir&#x3D;&#96;pwd&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">celery_pid() &#123;</span><br><span class="line">    echo &#96;ps -ef | grep -E &quot;celery -A celery_test worker&quot; | grep -v grep| awk &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line">&#125;</span><br><span class="line">start() &#123;</span><br><span class="line">    celery  multi start celery_test -A celery_test -l debug --autoscale&#x3D;50,5 --logfile&#x3D;$base_dir&#x2F;var&#x2F;celery-%I.log --pidfile&#x3D;celery_test.pid</span><br><span class="line">&#125;</span><br><span class="line">restart() &#123;</span><br><span class="line">    celery  multi restart celery_test -A celery_test -l debug</span><br><span class="line">&#125;</span><br><span class="line">stop() &#123;</span><br><span class="line">    celery  multi stop celery_test -A celery_test -l debug</span><br><span class="line">&#125;</span><br><span class="line">#restart()&#123;</span><br><span class="line">#    stop</span><br><span class="line">#    start</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># See how we were called.</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">  start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">  restart)</span><br><span class="line">        restart</span><br><span class="line">        ;;</span><br><span class="line">  stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">  *)</span><br><span class="line">        echo $&quot;Usage: $0 &#123;start|stop|restart&#125;&quot;</span><br><span class="line">        exit 2</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">#nohup celery -A celery_test worker -l debug --concurrency&#x3D;10 --autoreload  &amp; &gt;&gt;celery.log</span><br><span class="line"></span><br></pre><h3 id="启动celery-定时任务运行"><a href="#启动celery-定时任务运行" class="headerlink" title="启动celery 定时任务运行"></a>启动celery 定时任务运行</h3><pre class="highlight"><span class="line">celery -A celery_test beat -l debug</span><br></pre><pre class="highlight"><span class="line"># celery-crond.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#celery 定时任务运行</span><br><span class="line">source ..&#x2F;env&#x2F;bin&#x2F;activate</span><br><span class="line">export C_FORCE_ROOT&#x3D;&quot;true&quot;</span><br><span class="line">base_dir&#x3D;&#96;pwd&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">celery_pid() &#123;</span><br><span class="line">    echo &#96;ps -ef | grep -E &quot;celery -A celery_test beat&quot; | grep -v grep| awk &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line">&#125;</span><br><span class="line">start() &#123;</span><br><span class="line">    #django 调度定时任务</span><br><span class="line">    #celery -A celery_test beat -l info -S django &gt;&gt; $base_dir&#x2F;var&#x2F;celery-cron.log 2&gt;&amp;1 &amp;</span><br><span class="line">    celery -A celery_test beat -l debug &gt;&gt; $base_dir&#x2F;var&#x2F;Scheduler.log 2&gt;&amp;1 &amp;</span><br><span class="line">    sleep 3</span><br><span class="line">    pid&#x3D;$(celery_pid)</span><br><span class="line">    echo -e &quot;\e[00;31mcelery is start (pid: $pid)\e[00m&quot;</span><br><span class="line">&#125;</span><br><span class="line">restart() &#123;</span><br><span class="line">    pid&#x3D;$(celery_pid)</span><br><span class="line">    echo -e &quot;\e[00;31mcelery is restart (pid: $pid)\e[00m&quot;</span><br><span class="line">    ps auxf | grep -E &quot;celery -A celery_test beat&quot; | grep -v grep| awk &#39;&#123;print $2&#125;&#39; | xargs kill -HUP &amp;&gt; &#x2F;dev&#x2F;null</span><br><span class="line">&#125;</span><br><span class="line">stop() &#123;</span><br><span class="line">    pid&#x3D;$(celery_pid)</span><br><span class="line">    echo -e &quot;\e[00;31mcelery is stop (pid: $pid)\e[00m&quot;</span><br><span class="line">    ps -ef | grep -E &quot;celery -A celery_test beat&quot; | grep -v grep| awk &#39;&#123;print $2&#125;&#39; | xargs kill -TERM &amp;&gt; &#x2F;dev&#x2F;null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">  start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">  restart)</span><br><span class="line">        restart</span><br><span class="line">        ;;</span><br><span class="line">  stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">  *)</span><br><span class="line">        echo $&quot;Usage: $0 &#123;start|stop|restart&#125;&quot;</span><br><span class="line">        exit 2</span><br><span class="line">esac</span><br><span class="line"></span><br></pre><h3 id="windows下编写的脚本文件，放到Linux中无法识别格式"><a href="#windows下编写的脚本文件，放到Linux中无法识别格式" class="headerlink" title="windows下编写的脚本文件，放到Linux中无法识别格式"></a>windows下编写的脚本文件，放到Linux中无法识别格式</h3><p>在Linux中执行.sh脚本，异常/bin/sh^M: bad interpreter: No such file or directory</p><p>set ff=unix</p><p>dos2unix start-celery.sh<br>dos2unix celery-crond.sh</p><h3 id="常见报错"><a href="#常见报错" class="headerlink" title="常见报错"></a>常见报错</h3><p>Received unregistered task of type ‘XXX’ Celery报错（定时任务中无法找到对应tasks.py文件）</p><p>app = Celery(‘opwf’, include=[‘api_workflow.tasks’]) # api_workflow这个app中的tasks文件</p><p><a href="https://www.cnblogs.com/xiaonq/p/9303941.html">博客参考地址</a></p>]]></content>
      
      
      <categories>
          
          <category> celery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Celery 的使用</title>
      <link href="/2019/09/27/Celery%20%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/09/27/Celery%20%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>上一篇博客已经详细的介绍了 Celery 和他的工作流程 <a href="https://blog.csdn.net/weixin_44685869/article/details/104443540">celery的介绍</a></p><p>接下来 要演示 Celery 的使用</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class="highlight"><span class="line">python pip install celery</span><br></pre><p>创建 tasks.py文件进行验证</p><pre class="highlight"><span class="line"># tasks.py</span><br><span class="line"></span><br><span class="line">from celery import Celery</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">app &#x3D; Celery(&#39;TASK&#39;,</span><br><span class="line">             broker&#x3D;&#39;redis:&#x2F;&#x2F;localhost&#39;,        </span><br><span class="line">             backend&#x3D;&#39;redis:&#x2F;&#x2F;localhost&#39;)</span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def add(x, y):</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">进行任务的添加</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">    print(&quot;running..add.&quot;, x, y)</span><br><span class="line">    return x + y</span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def minus(x, y):</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">任务的减少</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">time.sleep(60)</span><br><span class="line">    print(&quot;running..minus.&quot;, x, y)</span><br><span class="line">    return x - y</span><br><span class="line"></span><br></pre><h3 id="启动Celery-Worker来开始监听并执行任务"><a href="#启动Celery-Worker来开始监听并执行任务" class="headerlink" title="启动Celery Worker来开始监听并执行任务"></a>启动Celery Worker来开始监听并执行任务</h3><pre class="highlight"><span class="line">celery -A tasks worker --loglevel&#x3D;info            # tasks是tasks.py文件：必须在tasks.py所在目录下执行</span><br><span class="line"></span><br></pre><h3 id="调用任务：再打开两个终端，进行命令行模式，调用任务"><a href="#调用任务：再打开两个终端，进行命令行模式，调用任务" class="headerlink" title="调用任务：再打开两个终端，进行命令行模式，调用任务"></a>调用任务：再打开两个终端，进行命令行模式，调用任务</h3><pre class="highlight"><span class="line">&gt;&gt;&gt; import tasks</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; t2 &#x3D; tasks.minus.delay(9,11)</span><br><span class="line"></span><br><span class="line"># 然后在另一个终端重复上面步骤执行</span><br><span class="line">&gt;&gt;&gt; import tasks</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; t1 &#x3D; tasks.add.delay(3,4)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; t1.get()</span><br><span class="line"># 由于t2执行sleep了3s所以t1.get()需要等待</span><br><span class="line"></span><br></pre><h3 id="celery其他命令"><a href="#celery其他命令" class="headerlink" title="celery其他命令"></a>celery其他命令</h3><pre class="highlight"><span class="line">&gt;&gt;&gt; t.ready()                  #返回true证明可以执行，不必等待</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; t.get(timeout&#x3D;1)           #如果1秒不返回结果就超时,避免一直等待</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; t.get(propagate&#x3D;False)     #如果执行的代码错误只会打印错误信息</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; t.traceback                #打印异常详细结果</span><br></pre><h3 id="Celery执行异步任务"><a href="#Celery执行异步任务" class="headerlink" title="Celery执行异步任务"></a>Celery执行异步任务</h3><p>创建项目celerytest</p><h3 id="创建py文件：celery-app-task-py"><a href="#创建py文件：celery-app-task-py" class="headerlink" title="创建py文件：celery_app_task.py"></a>创建py文件：celery_app_task.py</h3><pre class="highlight"><span class="line">import celery</span><br><span class="line">import time</span><br><span class="line"># broker&#x3D;&#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;2&#39; 不加密码</span><br><span class="line">backend&#x3D;&#39;redis:&#x2F;&#x2F;:123456@127.0.0.1:6379&#x2F;1&#39;</span><br><span class="line">broker&#x3D;&#39;redis:&#x2F;&#x2F;:123456@127.0.0.1:6379&#x2F;2&#39;</span><br><span class="line">cel&#x3D;celery.Celery(&#39;test&#39;,backend&#x3D;backend,broker&#x3D;broker)</span><br><span class="line"></span><br><span class="line">@cel.task</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">添加任务</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">def add(x,y):</span><br><span class="line">    return x+y</span><br><span class="line"></span><br></pre><h3 id="创建py文件：add-task-py-添加任务"><a href="#创建py文件：add-task-py-添加任务" class="headerlink" title="创建py文件：add_task.py,添加任务"></a>创建py文件：add_task.py,添加任务</h3><pre class="highlight"><span class="line">from celery_app_task import add</span><br><span class="line">result &#x3D; add.delay(4,5)</span><br><span class="line">print(result.id)</span><br></pre><h3 id="创建py文件：run-py，执行任务，或者使用命令执行：celery-worker-A-celery-app-task-l-info"><a href="#创建py文件：run-py，执行任务，或者使用命令执行：celery-worker-A-celery-app-task-l-info" class="headerlink" title="创建py文件：run.py，执行任务，或者使用命令执行：celery worker -A celery_app_task -l info"></a>创建py文件：run.py，执行任务，或者使用命令执行：celery worker -A celery_app_task -l info</h3><p>windows下：celery worker -A celery_app_task -l info -P eventlet</p><pre class="highlight"><span class="line">from celery_app_task import cel</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    cel.worker_main()</span><br><span class="line">    # cel.worker_main(argv&#x3D;[&#39;--loglevel&#x3D;info&#39;)</span><br></pre><h3 id="创建py文件：result-py，查看任务执行结果"><a href="#创建py文件：result-py，查看任务执行结果" class="headerlink" title="创建py文件：result.py，查看任务执行结果"></a>创建py文件：result.py，查看任务执行结果</h3><pre class="highlight"><span class="line">from celery.result import AsyncResult</span><br><span class="line">from celery_app_task import cel</span><br><span class="line"></span><br><span class="line">async &#x3D; AsyncResult(id&#x3D;&quot;e919d97d-2938-4d0f-9265-fd8237dc2aa3&quot;, app&#x3D;cel)</span><br><span class="line"></span><br><span class="line">if async.successful():</span><br><span class="line">    result &#x3D; async.get()</span><br><span class="line">    print(result)</span><br><span class="line">    # result.forget() # 将结果删除</span><br><span class="line">elif async.failed():</span><br><span class="line">    print(&#39;执行失败&#39;)</span><br><span class="line">elif async.status &#x3D;&#x3D; &#39;PENDING&#39;:</span><br><span class="line">    print(&#39;任务等待中被执行&#39;)</span><br><span class="line">elif async.status &#x3D;&#x3D; &#39;RETRY&#39;:</span><br><span class="line">    print(&#39;任务异常后正在重试&#39;)</span><br><span class="line">elif async.status &#x3D;&#x3D; &#39;STARTED&#39;:</span><br><span class="line">    print(&#39;任务已经开始被执行&#39;)</span><br></pre><p>执行 add_task.py，添加任务，并获取任务ID</p><p>执行 run.py ，或者执行命令：celery worker -A celery_app_task -l info</p><p>执行 result.py,检查任务状态并获取结果</p><h3 id="多任务结构"><a href="#多任务结构" class="headerlink" title="多任务结构"></a>多任务结构</h3><pre class="highlight"><span class="line">pro_cel</span><br><span class="line">    ├── celery_task      # celery相关文件夹</span><br><span class="line">    │   ├── celery.py    # celery连接和配置相关文件,必须叫这个名字</span><br><span class="line">    │   └── tasks1.py    #  所有任务函数</span><br><span class="line">    │   └── tasks2.py    #  所有任务函数</span><br><span class="line">    ├── check_result.py  # 检查结果</span><br><span class="line">    └── send_task.py     # 触发任务</span><br></pre><h3 id="celery-py"><a href="#celery-py" class="headerlink" title="celery.py"></a>celery.py</h3><pre class="highlight"><span class="line">from celery import Celery</span><br><span class="line"></span><br><span class="line">cel &#x3D; Celery(&#39;celery_demo&#39;,</span><br><span class="line">             broker&#x3D;&#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;1&#39;,</span><br><span class="line">             backend&#x3D;&#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;2&#39;,</span><br><span class="line">             # 包含以下两个任务文件，去相应的py文件中找任务，对多个任务做分类</span><br><span class="line">             include&#x3D;[&#39;celery_task.tasks1&#39;,</span><br><span class="line">                      &#39;celery_task.tasks2&#39;</span><br><span class="line">                      ])</span><br><span class="line"></span><br><span class="line"># 时区</span><br><span class="line">cel.conf.timezone &#x3D; &#39;Asia&#x2F;Shanghai&#39;</span><br><span class="line"># 是否使用UTC</span><br><span class="line">cel.conf.enable_utc &#x3D; False</span><br></pre><h3 id="tasks1-py"><a href="#tasks1-py" class="headerlink" title="tasks1.py"></a>tasks1.py</h3><pre class="highlight"><span class="line">import time</span><br><span class="line">from celery_task.celery import cel</span><br><span class="line"></span><br><span class="line">@cel.task</span><br><span class="line">def test_celery(res):</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    return &quot;test_celery任务结果:%s&quot;%res</span><br></pre><h3 id="tasks2-py"><a href="#tasks2-py" class="headerlink" title="tasks2.py"></a>tasks2.py</h3><pre class="highlight"><span class="line">import time</span><br><span class="line">from celery_task.celery import cel</span><br><span class="line">@cel.task</span><br><span class="line">def test_celery2(res):</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    return &quot;test_celery2任务结果:%s&quot;%res</span><br></pre><h3 id="check-result-py"><a href="#check-result-py" class="headerlink" title="check_result.py"></a>check_result.py</h3><pre class="highlight"><span class="line">from celery.result import AsyncResult</span><br><span class="line">from celery_task.celery import cel</span><br><span class="line"></span><br><span class="line">async &#x3D; AsyncResult(id&#x3D;&quot;08eb2778-24e1-44e4-a54b-56990b3519ef&quot;, app&#x3D;cel)</span><br><span class="line"></span><br><span class="line">if async.successful():</span><br><span class="line">    result &#x3D; async.get()</span><br><span class="line">    print(result)</span><br><span class="line">    # result.forget() # 将结果删除,执行完成，结果不会自动删除</span><br><span class="line">    # async.revoke(terminate&#x3D;True)  # 无论现在是什么时候，都要终止</span><br><span class="line">    # async.revoke(terminate&#x3D;False) # 如果任务还没有开始执行呢，那么就可以终止。</span><br><span class="line">elif async.failed():</span><br><span class="line">    print(&#39;执行失败&#39;)</span><br><span class="line">elif async.status &#x3D;&#x3D; &#39;PENDING&#39;:</span><br><span class="line">    print(&#39;任务等待中被执行&#39;)</span><br><span class="line">elif async.status &#x3D;&#x3D; &#39;RETRY&#39;:</span><br><span class="line">    print(&#39;任务异常后正在重试&#39;)</span><br><span class="line">elif async.status &#x3D;&#x3D; &#39;STARTED&#39;:</span><br><span class="line">    print(&#39;任务已经开始被执行&#39;)</span><br><span class="line"></span><br></pre><h3 id="send-task-py"><a href="#send-task-py" class="headerlink" title="send_task.py"></a>send_task.py</h3><pre class="highlight"><span class="line">from celery_task.tasks1 import test_celery</span><br><span class="line">from celery_task.tasks2 import test_celery2</span><br><span class="line"></span><br><span class="line"># 立即告知celery去执行test_celery任务，并传入一个参数</span><br><span class="line">result &#x3D; test_celery.delay(&#39;第一个的执行&#39;)</span><br><span class="line">print(result.id)</span><br><span class="line">result &#x3D; test_celery2.delay(&#39;第二个的执行&#39;)</span><br><span class="line">print(result.id)</span><br></pre><p>添加任务（执行send_task.py），开启work：celery worker -A celery_task -l info -P eventlet，检查任务执行结果（执行check_result.py）</p><h2 id="Celery执行定时任务"><a href="#Celery执行定时任务" class="headerlink" title="Celery执行定时任务"></a>Celery执行定时任务</h2><h3 id="设定时间让celery执行一个任务"><a href="#设定时间让celery执行一个任务" class="headerlink" title="设定时间让celery执行一个任务"></a>设定时间让celery执行一个任务</h3><h3 id="add-task-py"><a href="#add-task-py" class="headerlink" title="add_task.py"></a>add_task.py</h3><pre class="highlight"><span class="line">from celery_app_task import add</span><br><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line"># 方式一</span><br><span class="line"># v1 &#x3D; datetime(2019, 2, 13, 18, 19, 56)</span><br><span class="line"># print(v1)</span><br><span class="line"># v2 &#x3D; datetime.utcfromtimestamp(v1.timestamp())</span><br><span class="line"># print(v2)</span><br><span class="line"># result &#x3D; add.apply_async(args&#x3D;[1, 3], eta&#x3D;v2)</span><br><span class="line"># print(result.id)</span><br><span class="line"></span><br><span class="line"># 方式二</span><br><span class="line">ctime &#x3D; datetime.now()</span><br><span class="line"># 默认用utc时间</span><br><span class="line">utc_ctime &#x3D; datetime.utcfromtimestamp(ctime.timestamp())</span><br><span class="line">from datetime import timedelta</span><br><span class="line">time_delay &#x3D; timedelta(seconds&#x3D;10)</span><br><span class="line">task_time &#x3D; utc_ctime + time_delay</span><br><span class="line"></span><br><span class="line"># 使用apply_async并设定时间</span><br><span class="line">result &#x3D; add.apply_async(args&#x3D;[4, 3], eta&#x3D;task_time)</span><br><span class="line">print(result.id)</span><br><span class="line"></span><br></pre><h3 id="类似于crontab的定时任务"><a href="#类似于crontab的定时任务" class="headerlink" title="类似于crontab的定时任务"></a>类似于crontab的定时任务</h3><h3 id="多任务结构中celery-py修改如下"><a href="#多任务结构中celery-py修改如下" class="headerlink" title="多任务结构中celery.py修改如下"></a>多任务结构中celery.py修改如下</h3><pre class="highlight"><span class="line">from datetime import timedelta</span><br><span class="line">from celery import Celery</span><br><span class="line">from celery.schedules import crontab</span><br><span class="line"></span><br><span class="line">cel &#x3D; Celery(&#39;tasks&#39;, broker&#x3D;&#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;1&#39;, backend&#x3D;&#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;2&#39;, include&#x3D;[</span><br><span class="line">    &#39;celery_task.tasks1&#39;,</span><br><span class="line">    &#39;celery_task.tasks2&#39;,</span><br><span class="line">])</span><br><span class="line">cel.conf.timezone &#x3D; &#39;Asia&#x2F;Shanghai&#39;</span><br><span class="line">cel.conf.enable_utc &#x3D; False</span><br><span class="line"></span><br><span class="line">cel.conf.beat_schedule &#x3D; &#123;</span><br><span class="line">    # 名字随意命名</span><br><span class="line">    &#39;add-every-10-seconds&#39;: &#123;</span><br><span class="line">        # 执行tasks1下的test_celery函数</span><br><span class="line">        &#39;task&#39;: &#39;celery_task.tasks1.test_celery&#39;,</span><br><span class="line">        # 每隔2秒执行一次</span><br><span class="line">        # &#39;schedule&#39;: 1.0,</span><br><span class="line">        # &#39;schedule&#39;: crontab(minute&#x3D;&quot;*&#x2F;1&quot;),</span><br><span class="line">        &#39;schedule&#39;: timedelta(seconds&#x3D;2),</span><br><span class="line">        # 传递参数</span><br><span class="line">        &#39;args&#39;: (&#39;test&#39;,)</span><br><span class="line">    &#125;,</span><br><span class="line">    # &#39;add-every-12-seconds&#39;: &#123;</span><br><span class="line">    #     &#39;task&#39;: &#39;celery_task.tasks1.test_celery&#39;,</span><br><span class="line">    #     每年4月11号，8点42分执行</span><br><span class="line">    #     &#39;schedule&#39;: crontab(minute&#x3D;42, hour&#x3D;8, day_of_month&#x3D;11, month_of_year&#x3D;4),</span><br><span class="line">    #     &#39;schedule&#39;: crontab(minute&#x3D;42, hour&#x3D;8, day_of_month&#x3D;11, month_of_year&#x3D;4),</span><br><span class="line">    #     &#39;args&#39;: (16, 16)</span><br><span class="line">    # &#125;,</span><br><span class="line">&#125;</span><br></pre><h3 id="启动一个beat：celery-beat-A-celery-task-l-info"><a href="#启动一个beat：celery-beat-A-celery-task-l-info" class="headerlink" title="启动一个beat：celery beat -A celery_task -l info"></a>启动一个beat：celery beat -A celery_task -l info</h3><h3 id="启动work执行：celery-worker-A-celery-task-l-info-P-eventlet"><a href="#启动work执行：celery-worker-A-celery-task-l-info-P-eventlet" class="headerlink" title="启动work执行：celery worker -A celery_task -l info -P eventlet"></a>启动work执行：celery worker -A celery_task -l info -P eventlet</h3><h2 id="Django中使用Celery"><a href="#Django中使用Celery" class="headerlink" title="Django中使用Celery"></a>Django中使用Celery</h2><h3 id="在项目目录下创建celeryconfig-py"><a href="#在项目目录下创建celeryconfig-py" class="headerlink" title="在项目目录下创建celeryconfig.py"></a>在项目目录下创建celeryconfig.py</h3><pre class="highlight"><span class="line">djcelery.setup_loader()</span><br><span class="line">CELERY_IMPORTS&#x3D;(</span><br><span class="line">    &#39;app01.tasks&#39;,</span><br><span class="line">)</span><br><span class="line">#有些情况可以防止死锁</span><br><span class="line">CELERYD_FORCE_EXECV&#x3D;True</span><br><span class="line"># 设置并发worker数量</span><br><span class="line">CELERYD_CONCURRENCY&#x3D;4</span><br><span class="line">#允许重试</span><br><span class="line">CELERY_ACKS_LATE&#x3D;True</span><br><span class="line"># 每个worker最多执行100个任务被销毁，可以防止内存泄漏</span><br><span class="line">CELERYD_MAX_TASKS_PER_CHILD&#x3D;100</span><br><span class="line"># 超时时间</span><br><span class="line">CELERYD_TASK_TIME_LIMIT&#x3D;12*30</span><br></pre><h3 id="在app01目录下创建tasks-py"><a href="#在app01目录下创建tasks-py" class="headerlink" title="在app01目录下创建tasks.py"></a>在app01目录下创建tasks.py</h3><pre class="highlight"><span class="line">from celery import task</span><br><span class="line">@task</span><br><span class="line">def add(a,b):</span><br><span class="line">    with open(&#39;a.text&#39;, &#39;a&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">        f.write(&#39;a&#39;)</span><br><span class="line">    print(a+b)</span><br></pre><h3 id="视图函数views-py"><a href="#视图函数views-py" class="headerlink" title="视图函数views.py"></a>视图函数views.py</h3><pre class="highlight"><span class="line">from django.shortcuts import render,HttpResponse</span><br><span class="line">from app01.tasks import add</span><br><span class="line">from datetime import datetime</span><br><span class="line">def test(request):</span><br><span class="line">    # result&#x3D;add.delay(2,3)</span><br><span class="line">    ctime &#x3D; datetime.now()</span><br><span class="line">    # 默认用utc时间</span><br><span class="line">    utc_ctime &#x3D; datetime.utcfromtimestamp(ctime.timestamp())</span><br><span class="line">    from datetime import timedelta</span><br><span class="line">    time_delay &#x3D; timedelta(seconds&#x3D;5)</span><br><span class="line">    task_time &#x3D; utc_ctime + time_delay</span><br><span class="line">    result &#x3D; add.apply_async(args&#x3D;[4, 3], eta&#x3D;task_time)</span><br><span class="line">    print(result.id)</span><br><span class="line">    return HttpResponse(&#39;ok&#39;)</span><br><span class="line"></span><br></pre><h3 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a>settings.py</h3><pre class="highlight"><span class="line">#INSTALLED_APPS &#x3D; [</span><br><span class="line">#    &#39;djcelery&#39;,</span><br><span class="line">#    &#39;app01&#39;</span><br><span class="line">#]</span><br><span class="line"></span><br><span class="line">from djagocele import celeryconfig</span><br><span class="line">BROKER_BACKEND&#x3D;&#39;redis&#39;</span><br><span class="line">BOOKER_URL&#x3D;&#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;1&#39;</span><br><span class="line">CELERY_RESULT_BACKEND&#x3D;&#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;2&#39;</span><br></pre>]]></content>
      
      
      <categories>
          
          <category> celery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Celery 结构，组件</title>
      <link href="/2019/09/26/Celery%20%E7%BB%93%E6%9E%84%EF%BC%8C%E7%BB%84%E4%BB%B6/"/>
      <url>/2019/09/26/Celery%20%E7%BB%93%E6%9E%84%EF%BC%8C%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-Celery？"><a href="#什么是-Celery？" class="headerlink" title="什么是 Celery？"></a>什么是 Celery？</h3><p>Celery是一个简单、灵活且可靠的，处理大量消息的分布式系统</p><p>专注于实时处理的异步任务队列</p><p>同时也支持任务调度</p><h3 id="celery-架构"><a href="#celery-架构" class="headerlink" title="celery 架构"></a>celery 架构</h3><p>Celery的架构由三部分组成，消息中间件（message broker），任务执行单元（worker）和任务执行结果存储（task result store）组成。<br><img src="https://img-blog.csdnimg.cn/20200222143757591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="~~~~~~~~~~~~~~~~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200222143757591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><h4 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h4><p>Celery本身不提供消息服务，但是可以方便的和第三方提供的消息中间件集成。包括，RabbitMQ, Redis等等</p><h4 id="任务执行单元"><a href="#任务执行单元" class="headerlink" title="任务执行单元"></a>任务执行单元</h4><p>Worker是Celery提供的任务执行的单元，worker并发的运行在分布式的系统节点中。</p><h4 id="任务结果存储"><a href="#任务结果存储" class="headerlink" title="任务结果存储"></a>任务结果存储</h4><p>Task result store用来存储Worker执行的任务的结果，Celery支持以不同方式存储任务的结果，包括AMQP, redis等</p><h3 id="Celery-组件"><a href="#Celery-组件" class="headerlink" title="Celery 组件"></a>Celery 组件</h3><h5 id="Celery-扮演生产者和消费者的角色"><a href="#Celery-扮演生产者和消费者的角色" class="headerlink" title="Celery 扮演生产者和消费者的角色"></a>Celery 扮演生产者和消费者的角色</h5><ul><li><p>Producer :<br>任务生产者. 调用 Celery API , 函数或者装饰器, 而产生任务并交给任务队列处理的都是任务生产者。</p></li><li><p>Celery Beat :<br>任务调度器. Beat 进程会读取配置文件的内容, 周期性的将配置中到期需要执行的任务发送给任务队列。</p></li><li><p>Broker :<br>消息代理, 队列本身. 也称为消息中间件.。接受任务生产者发送过来的任务消息, 存进队列再按序分发给任务消费方(通常是消息队列或者数据库)。</p></li><li><p>Celery Worker :<br>执行任务的消费者, 通常会在多台服务器运行多个消费者, 提高运行效率。</p></li><li><p>Result Backend :<br>任务处理完成之后保存状态信息和结果, 以供查询。</p></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>异步任务：<br>发邮件、发送消息<br>自动化工单中耗时任务<br>所有需要异步处理的请求都可以</p></li><li><p>定时任务：<br>工单系统定时获取超时工单进行延时报警<br>对过期会员进行清理</p></li></ul><h3 id="celery应用举例"><a href="#celery应用举例" class="headerlink" title="celery应用举例"></a>celery应用举例</h3><ol><li><p>Celery 是一个 基于python开发的分布式异步消息任务队列，通过它可以轻松的实现任务的异步处理，如果你的业务场景中需要用到异步任务，就可以考虑使用celery</p></li><li><p>你想对100台机器执行一条批量命令，可能会花很长时间 ，但你不想让你的程序等着结果返回，而是给你返回 一个任务ID,你过一段时间只需要拿着这个任务id就可以拿到任务执行结果， 在任务执行ing进行时，你可以继续做其它的事情</p></li><li><p>Celery 在执行任务时需要通过一个消息中间件来接收和发送任务消息，以及存储任务结果， 一般使用rabbitMQ or Redis</p></li></ol><h3 id="Celery的优点"><a href="#Celery的优点" class="headerlink" title="Celery的优点"></a>Celery的优点</h3><ol><li><p>简单：一单熟悉了celery的工作流程后，配置和使用还是比较简单的</p></li><li><p>高可用：当任务执行失败或执行过程中发生连接中断，celery 会自动尝试重新执行任务</p></li><li><p>快速：一个单进程的celery每分钟可处理上百万个任务</p></li><li><p>灵活： 几乎celery的各个组件都可以被扩展及自定制</p></li></ol><h3 id="Celery基本工作流程图"><a href="#Celery基本工作流程图" class="headerlink" title="Celery基本工作流程图"></a>Celery基本工作流程图</h3><p>![<del>~</del>`](<a href="https://img-blog.csdnimg.cn/2020022214505926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/2020022214505926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70</a>)</p><p>user：用户程序，用于告知celery去执行一个任务。<br>broker: 存放任务（依赖RabbitMQ或Redis，进行存储）<br>worker：执行任务</p><p><img src="https://img-blog.csdnimg.cn/20200222145650451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="~~~~~~~~~~~~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200222145650451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><h2 id="非常重要"><a href="#非常重要" class="headerlink" title="非常重要"></a>非常重要</h2><h3 id="版本支持情况"><a href="#版本支持情况" class="headerlink" title="版本支持情况"></a>版本支持情况</h3><pre class="highlight"><span class="line">Celery version 4.0 runs on</span><br><span class="line">        Python ❨2.7, 3.4, 3.5❩</span><br><span class="line">        PyPy ❨5.4, 5.5❩</span><br><span class="line">    This is the last version to support Python 2.7, and from the next version (Celery 5.x) Python 3.5 or newer is required.</span><br><span class="line"></span><br><span class="line">    If you’re running an older version of Python, you need to be running an older version of Celery:</span><br><span class="line"></span><br><span class="line">        Python 2.6: Celery series 3.1 or earlier.</span><br><span class="line">        Python 2.5: Celery series 3.0 or earlier.</span><br><span class="line">        Python 2.4 was Celery series 2.2 or earlier.</span><br><span class="line"></span><br><span class="line">    Celery is a project with minimal funding, so we don’t support Microsoft Windows. Please don’t open any issues related to that platform.</span><br></pre><p>如果使用python版本不支持 ↓</p><h4 id="解决版本问题："><a href="#解决版本问题：" class="headerlink" title="解决版本问题："></a>解决版本问题：</h4><p>在 celery 官方的提议下，建议将 async 文件的文件名改成 asynchronous</p><p>C:\Python37\Lib\site-packages\kombu\async</p><pre class="highlight"><span class="line">C:\Python37\Lib\site-packages\celery\utils\timer2.py</span><br><span class="line">C:\Python37\lib\site-packages\celery\concurrency\asynpool.py</span><br><span class="line">C:\Python37\lib\site-packages\celery\worker\components.py</span><br><span class="line">C:\Python37\lib\site-packages\celery\worker\autoscale.py</span><br><span class="line">C:\Python37\lib\site-packages\celery\worker\consumer.py</span><br></pre><p>以下的文件都有 async 的导包，我们将里面的导报都改成 asynchronous</p>]]></content>
      
      
      <categories>
          
          <category> celery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>压缩 -压缩实现方法、常用的压缩格式</title>
      <link href="/2019/09/19/%E5%8E%8B%E7%BC%A9%20-%E5%8E%8B%E7%BC%A9%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%A0%BC%E5%BC%8F/"/>
      <url>/2019/09/19/%E5%8E%8B%E7%BC%A9%20-%E5%8E%8B%E7%BC%A9%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>压缩是通过 特定的算法来减少机算机对文件的大小机制，可以减少 Bytes<br>有很多的公司 对 存储的数据，都是用压缩包的形式，很少会用到数据库，一朋友 ，新跳了一家公司 分配好项目之后，没想到，发来的 数据都是 压缩包，其中有一个包 里面有着 4000W 的用户信息 （具体啥玩意我也不知道）他的电脑 打都打不开。<br>（ 咱不是程序大佬 小白白 ）</li></ul><p>让我突然重视了起来 压缩，因为平时 除了用快压 解压一些小电影剩下的好像什么都没有办，所以 度妈妈 了一些相关知识想着分享一下、也放在这里希望 大佬 能够指点</p><p><strong>言归正传</strong><br>我们大众化的理解就是解压 就是去除空格 其实也不完全对<br>接下来我们来说说 压缩</p><ol><li>文件</li></ol><ul><li><p>（ 文件 ）压缩技术 简单的来说 就是查找文件内的重复 Bytes，然后建立一个具有相同 Bytes 的 字典 文件，并且用一个代码来 表示。</p></li><li><p>比如原文件里，有多处重复的 Bytes or word 如：LiEnze 我爱你，这个时候 就会生产出一个代码来表示 如：sb 当然只是举例、真实的操作要麻烦的多</p></li></ul><ol start="2"><li>图片</li></ol><ul><li>（ 图片 ）计算机处理信息 用的是 二进制表示、在一张图片内 有数不清的 相同颜色点对吧，压缩就会 在某个位置上 有多少个 蓝色点、在通过 公式用 （0， 1）来表示出来</li></ul><p><strong>压缩 方法分为：</strong><br>（ 有的时候想追求效率 必然质量会打点折扣 ）</p><ol><li>有损压缩：</li></ol><ul><li>举个例子 在压缩 图片的时候 你图片的左上角 少了一个 像素点 你的肉眼能看出来么？对吧！</li><li>所以有损压缩 非常适用于 压缩 图片 音频 视频 典型的代表格式就是 .mpeg</li></ul><ol start="2"><li>无损压缩：</li></ol><ul><li>当我们对数据追求完美 不是特别考虑效率的时候 无损压缩就用到了、代表格式就太多了 如：.zip .rar 这些啊<br>其实压缩 最重要的 一点还是去重 也就是 重复压缩</li></ul><p><strong>重复压缩 也有两种：</strong></p><ol><li>段语句的重复</li></ol><ul><li><p>Bytes 在重复三个以上就成为短语句</p></li><li><p>在压缩这种类型时候 zip 用的是 两个数字 一个是 重复位置到当前位置的 距离，另一个是重复的长度</p></li><li><p>比如：abcddddd 我这个当前重复的位置是第 3个（第一个位置索引是 0），重复的长度是 5，那么我就可以 d(3,5) 来表示重复的 d。</p></li></ul><p>不要觉得一个 Bytes 有256个可能 三个字节就是有 256 ^ 3 种可能、这种压缩方法简直就是天方夜谭、</p><ul><li>比如：一篇小说中出现的 主人公的名字，和女主角去酒店的名字，极大程度地多次出现、这样就恰恰的符合了 重复压缩的做法，但是重复压缩只适合进行一次压缩</li><li>如果对文件进行第二次重复压缩 意义不大，因为第一次压缩 已经大大的破坏了 源语句的重复倾向。</li></ul><ol><li>单 Bytes 的重复</li></ol><ul><li><p>一个字节有 236 中可能、这样重复的几率岂不是更大？因为他是单字节，所以范围缩小了好多的。</p></li><li><p>比如在 ASCII 文本文件中 常用的就是 字母 和 数字，据说 E 的使用率是最高的 。</p></li><li><p>图片就更好理解了 肯定 深色调 和 浅色调 使用的多嘛<br>这里顺便提一下：png图片格式是一种无损压缩，其核心算法就是 zip 算法，它和 zip 格式的文件的主要区别在于：作为一种图片格式，它在文件头处存放了图片的大小、使用的颜色数等信息。</p></li><li><p>上面提到的短语式压缩的结果也有这种倾向：重复倾向于出现在离当前压缩位置较近的地方，重复长度倾向于比较短（20字节以内）。</p></li></ul><p><strong>常见的压缩格式：</strong></p><ol><li><p><a href="https://baike.baidu.com/item/JAR/919533?fr=aladdin">JAR</a>– Java Archive File<br>他是 Java 的一种文档格式、你也可以理解为他就是 ZIP文件 ，叫他文件包，他和 ZIP 的最大区别就是 JAR 文件的内容中包含了一个 META-INF/MANIFEST.MF 文件，这个文件是在生成 JAR 文件的时候自动创建的</p></li><li><p><a href="https://baike.baidu.com/item/Zip/16684862?fr=aladdin">ZIP</a>–<br>zip 是 very常见的一种压缩格式了它不需要单独的一个压缩或者解压缩软件，因为Windows系统已经集成了对 ZIP 压缩格式的支持。</p></li><li><p><a href="https://baike.baidu.com/item/RAR">RAR</a>–<br>RAR 的压缩地位仅次于 ZIP ,因为 RAR 的压缩率 要比 ZIP 高很多。有一个后起之秀 叫 7Z 有着 比 RAR 更高的压缩率 但是 没办法 RAR 在压缩领域奠定了一定的基础、不可撼动。</p></li><li><p><a href="https://baike.baidu.com/item/CAB/10159898">CAB</a><br>CAB 是微软推出的压缩文件格式，主要都是用于安装程序上，所以 CAB 文件包含的文件都是被经过处理的，代价就是咱们自己解压后可能还用不了</p></li><li><p><a href="https://jingyan.baidu.com/article/ceb9fb10868f6d8cad2ba0ee.html">ISO</a> –<br>ISO 是 一种光盘镜像格式，是吧数据保存到光盘上。你一可以理解 这就是文件提取。</p></li><li><p><a href="https://baike.baidu.com/item/Tar/13886925?fr=aladdin">TAR</a>–<br>TAR .tar 为后缀的文件，WinZIP、WinRAR、都可以打开，因为 他们两个都对 TAR 进行了关联，注意说的一点是 TAR是linux 常用的文件格式</p></li><li><p><a href="https://baike.baidu.com/item/119%E5%8F%B7%E5%85%83%E7%B4%A0/4817562?fromtitle=uue&fromid=9922593">UUE</a>–<br>UUE 这个比较牛逼、是压缩遇到邮件编码混合 引起 乱码 的情况下就用压缩格式，可以用WinZIP、WinRAR打开。</p></li></ol><p>压缩的操作相比较来说 还是比较麻烦的  要慢慢钻研<del>~</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2019/09/15/%E9%80%92%E5%BD%92/"/>
      <url>/2019/09/15/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>在调用一个函数的过程中，直接或间接地调用了函数本身这个就叫递归。但为了避免出现死循环，必须要有一个结束条件</p><p>在函数中调用函数本身时，相当于你让程序回到函数的第一行重新走一遍而已。、</p><p><img src="https://v3u.cn/book/img/dd1.jpg" alt="~~~~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://v3u.cn/book/img/dd1.jpg" class="lozad post-image"></p><pre class="highlight"><span class="line">def foo(S, T):</span><br><span class="line">    S &#x3D; T * T - S</span><br><span class="line">    if S &gt;&#x3D; 10:</span><br><span class="line">        W &#x3D; S + T * T</span><br><span class="line">        return W</span><br><span class="line">    else:</span><br><span class="line">        foo(S, T * 2)</span><br><span class="line"></span><br></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大查找</title>
      <link href="/2019/09/10/%E5%85%AB%E5%A4%A7%E6%9F%A5%E6%89%BE/"/>
      <url>/2019/09/10/%E5%85%AB%E5%A4%A7%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>算法简介 顺序查找又称为线性查找，是一种最简单的查找方法。适用于线性表的顺序存储结构和链式存储结构。该算法的时间复杂度为O(n)。 基本思路 从第一个元素m开始逐个与需要查找的元素x进行比较，当比较到元素值相同(即m=x)时返回元素m的下标，如果比较到最后都没有找到，则返回-1。 优缺点 缺点：是当n 很大时，平均查找长度较大，效率低； 优点：是对表中数据元素的存储没有要求。另外，对于线性链表，只能进行顺序查找。 算法实现</p><pre class="highlight"><span class="line">def sequential_search(lis, key):</span><br><span class="line">  length &#x3D; len(lis)</span><br><span class="line">  for i in range(length):</span><br><span class="line">    if lis[i] &#x3D;&#x3D; key:</span><br><span class="line">      return i</span><br><span class="line">    else:</span><br><span class="line">      return False</span><br><span class="line"></span><br></pre><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><p>二分查找（Binary Search），是一种在有序数组中查找某一特定元素的查找算法。查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则查找过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。 这种查找算法每一次比较都使查找范围缩小一半。</p><p>算法描述 给予一个包含 个带值元素的数组A 1、 令 L为0 ， R为 n-1 2、 如果L&gt;R，则搜索以失败告终 3、 令 m (中间值元素)为 ⌊(L+R)/2⌋ 4、 如果 AmT，令 R为 m - 1 并回到步骤二 复杂度分析 时间复杂度：折半搜索每次把搜索区域减少一半，时间复杂度为 O(logn) 空间复杂度：O(1)</p><pre class="highlight"><span class="line">def binary_search(lis, key):</span><br><span class="line">  low &#x3D; 0</span><br><span class="line">  high &#x3D; len(lis) - 1</span><br><span class="line">  time &#x3D; 0</span><br><span class="line">  while low &lt; high:</span><br><span class="line">    time +&#x3D; 1</span><br><span class="line">    mid &#x3D; int((low + high) &#x2F; 2)</span><br><span class="line">    if key &lt; lis[mid]:</span><br><span class="line">      high &#x3D; mid - 1</span><br><span class="line">    elif key &gt; lis[mid]:</span><br><span class="line">      low &#x3D; mid + 1</span><br><span class="line">    else:</span><br><span class="line">      # 打印折半的次数</span><br><span class="line">      print(&quot;times: %s&quot; % time)</span><br><span class="line">      return mid</span><br><span class="line">  print(&quot;times: %s&quot; % time)</span><br><span class="line">  return False</span><br></pre><h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>算法简介</p><p>插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的 查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])*(high-low)。 时间复杂度o(logn)但对于表长较大而关键字分布比较均匀的查找表来说，效率较高。</p><p>算法思想 基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。 注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p><p>复杂度分析 时间复杂性：如果元素均匀分布，则O（log log n）），在最坏的情况下可能需要O（n）。 空间复杂度：O（1）。</p><pre class="highlight"><span class="line">def binary_search(lis, key):</span><br><span class="line">  low &#x3D; 0</span><br><span class="line">  high &#x3D; len(lis) - 1</span><br><span class="line">  time &#x3D; 0</span><br><span class="line">  while low &lt; high:</span><br><span class="line">    time +&#x3D; 1</span><br><span class="line">    # 计算mid值是插值算法的核心代码</span><br><span class="line">    mid &#x3D; low + int((high - low) * (key - lis[low])&#x2F;(lis[high] - lis[low]))</span><br><span class="line">    print(&quot;mid&#x3D;%s, low&#x3D;%s, high&#x3D;%s&quot; % (mid, low, high))</span><br><span class="line">    if key &lt; lis[mid]:</span><br><span class="line">      high &#x3D; mid - 1</span><br><span class="line">    elif key &gt; lis[mid]:</span><br><span class="line">      low &#x3D; mid + 1</span><br><span class="line">    else:</span><br><span class="line">      # 打印查找的次数</span><br><span class="line">      print(&quot;times: %s&quot; % time)</span><br><span class="line">      return mid</span><br><span class="line">  print(&quot;times: %s&quot; % time)</span><br><span class="line">  return False</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">  LIST &#x3D; [1, 5, 7, 8, 22, 54, 99, 123, 200, 222, 444]</span><br><span class="line">  result &#x3D; binary_search(LIST, 444)</span><br><span class="line">  print(result)</span><br><span class="line"></span><br></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大排序</title>
      <link href="/2019/09/02/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/09/02/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序：插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序；首先将第一个作为已经排好序的，然后每次从后的取出插入到前面并排序；</p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(1)</p><p>稳定性：稳定</p><pre class="highlight"><span class="line">def insert_sort(ilist):</span><br><span class="line">    for i in range(len(ilist)):</span><br><span class="line">        for j in range(i):</span><br><span class="line">            if ilist[i] &lt; ilist[j]:</span><br><span class="line">                ilist.insert(j, ilist.pop(i))</span><br><span class="line">                break</span><br><span class="line">    return ilist</span><br></pre><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成</p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(1)</p><p>稳定性：稳定</p><pre class="highlight"><span class="line">def bubble_sort(blist):</span><br><span class="line">    count &#x3D; len(blist)</span><br><span class="line">    for i in range(0, count):</span><br><span class="line">        for j in range(i + 1, count):</span><br><span class="line">            if blist[i] &gt; blist[j]:</span><br><span class="line">                blist[i], blist[j] &#x3D; blist[j], blist[i]</span><br><span class="line">    return blist</span><br><span class="line"></span><br><span class="line">blist &#x3D; bubble_sort([4,5,6,7,3,2,6,9,8])</span><br><span class="line">print(blist)</span><br></pre><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</p><p>时间复杂度：O(nlog₂n)</p><p>空间复杂度：O(nlog₂n)</p><p>稳定性：不稳定</p><pre class="highlight"><span class="line">def quick_sort(qlist):</span><br><span class="line">    if qlist &#x3D;&#x3D; []:</span><br><span class="line">        return []</span><br><span class="line">    else:</span><br><span class="line">        qfirst &#x3D; qlist[0]</span><br><span class="line">        qless &#x3D; quick_sort([l for l in qlist[1:] if l &lt; qfirst])</span><br><span class="line">        qmore &#x3D; quick_sort([m for m in qlist[1:] if m &gt;&#x3D; qfirst])</span><br><span class="line">        return qless + [qfirst] + qmore</span><br><span class="line"></span><br><span class="line">qlist &#x3D; quick_sort([4,5,6,7,3,2,6,9,8])</span><br></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序：第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕</p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(1)</p><p>稳定性：不稳定</p><pre class="highlight"><span class="line">def select_sort(slist):</span><br><span class="line">    for i in range(len(slist)):</span><br><span class="line">        x &#x3D; i</span><br><span class="line">        for j in range(i, len(slist)):</span><br><span class="line">            if slist[j] &lt; slist[x]:</span><br><span class="line">                x &#x3D; j</span><br><span class="line">        slist[i], slist[x] &#x3D; slist[x], slist[i]</span><br><span class="line">    return slist</span><br><span class="line"></span><br><span class="line">slist &#x3D; select_sort([4,5,6,7,3,2,6,9,8])</span><br><span class="line"></span><br></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序：采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并</p><p>时间复杂度：O(nlog₂n)</p><p>空间复杂度：O(1)</p><p>稳定性：稳定</p><pre class="highlight"><span class="line">def merge_sort(array):</span><br><span class="line">    def merge_arr(arr_l, arr_r):</span><br><span class="line">        array &#x3D; []</span><br><span class="line">        while len(arr_l) and len(arr_r):</span><br><span class="line">            if arr_l[0] &lt;&#x3D; arr_r[0]:</span><br><span class="line">                array.append(arr_l.pop(0))</span><br><span class="line">            elif arr_l[0] &gt; arr_r[0]:</span><br><span class="line">                array.append(arr_r.pop(0))</span><br><span class="line">        if len(arr_l) !&#x3D; 0:</span><br><span class="line">            array +&#x3D; arr_l</span><br><span class="line">        elif len(arr_r) !&#x3D; 0:</span><br><span class="line">            array +&#x3D; arr_r</span><br><span class="line">        return array</span><br><span class="line"></span><br><span class="line">    def recursive(array):</span><br><span class="line">        if len(array) &#x3D;&#x3D; 1:</span><br><span class="line">            return array</span><br><span class="line">        mid &#x3D; len(array) &#x2F;&#x2F; 2</span><br><span class="line">        arr_l &#x3D; recursive(array[:mid])</span><br><span class="line">        arr_r &#x3D; recursive(array[mid:])</span><br><span class="line">        return merge_arr(arr_l, arr_r)</span><br><span class="line"></span><br><span class="line">    return recursive(array)</span><br><span class="line"></span><br></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT简介</title>
      <link href="/2019/08/17/JWT%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/08/17/JWT%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="https://v3u.cn/book/img/jwt.png" alt="~~~~~~~~~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://v3u.cn/book/img/jwt.png" class="lozad post-image"></p><p>JWT 特点 体积小，因而传输速度快</p><p>传输方式多样，可以通过URL/POST参数/HTTP头部等方式传输</p><p>严格的结构化。它自身（在 payload 中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且 payload 支持为你的应用而定制化。</p><p>支持跨域验证，可以应用于单点登录。</p><p>JWT是Auth0提出的通过对JSON进行加密签名来实现授权验证的方案，编码之后的JWT看起来是这样的一串字符：</p><pre class="highlight"><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre><p>由 . 分为三段，通过解码可以得到：</p><ol><li>头部（Header）<pre class="highlight"><span class="line">&#x2F;&#x2F; 包括类别（typ）、加密算法（alg）；</span><br><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre>jwt的头部包含两部分信息：</li></ol><p>声明类型，这里是jwt</p><p>声明加密的算法 通常直接使用 HMAC SHA256</p><ol><li>载荷（payload）<br>载荷（payload） 载荷就是存放有效信息的地方。</li><li>签名（signature)<br>签名的目的：签名实际上是对头部以及载荷内容进行签名。所以，如果有人对头部以及载荷的内容解码之后进行修改，再进行编码的话，那么新的头部和载荷的签名和之前的签名就将是不一样的。而且，如果不知道服务器加密的时候用的密钥的话，得出来的签名也一定会是不一样的。 这样就能保证token不会被篡改。</li></ol><p>最后，我们将上面拼接完的字符串用HS256算法进行加密。在加密的时候，我们还需要提供一个密钥（secret）。类似盐</p><p>这里在第三步我们得到 JWT 之后，需要将JWT存放在 client，之后的每次需要认证的请求都要把JWT发送过来。（请求时可以放到 header 的 Authorization ）</p><p>一、使用JSON Web Token的好处？ </p><ol><li>性能问题。 JWT方式将用户状态分散到了客户端中，相比于session，可以明显减轻服务端的内存压力。 Session方式存储用户id的最大弊病在于Session是存储在服务器端的，所以需要占用大量服务器内存， 对于较大型应用而言可能还要保存许多的状态，一般还需借助nosql和缓存机制来实现session的存储，如果是分布式应用还需session共享。 </li><li>单点登录。 JWT能轻松的实现单点登录，因为用户的状态已经被传送到了客户端。 token 可保存自定义信息，如用户基本信息，web服务器用key去解析token，就获取到请求用户的信息了。 我们也可以配置它以便包含用户拥有的任何权限。这意味着每个服务不需要与授权服务交互才能授权用户。 </li><li>前后端分离。 以前的传统模式下，后台对应的客户端就是浏览器，就可以使用session+cookies的方式实现登录， 但是在前后分离的情况下，后端只负责通过暴露的RestApi提供数据，而页面的渲染、路由都由前端完成。因为rest是无状态的，因此也就不会有session记录到服务器端。 </li><li>兼容性。 支持移动设备，支持跨程序调用，Cookie 是不允许垮域访问的，而 Token 则不存在这个问题。 </li><li>可拓展性。 jwt是无状态的，特别适用于分布式站点的单点登录（SSO）场景。 比如有3台机器（A、B、C）组成服务器集群，若session存在机器A上，session只能保存在其中一台服务器，此时你便不能访问机器B、C，因为B、C上没有存放该Session， 而使用token就能够验证用户请求合法性，并且我再加几台机器也没事，所以可拓展性好。 </li><li>安全性。因为有签名，所以JWT可以防止被篡改。</li></ol><p>JWT是基于token的身份认证的方案。</p><p>json web token全称。可以保证安全传输的前提下传送一些基本的信息，以减轻对外部存储的依赖，减少了分布式组件的依赖，减少了硬件的资源。</p><p>可实现无状态、分布式的Web应用授权，jwt的安全特性保证了token的不可伪造和不可篡改。</p><p>本质上是一个独立的身份验证令牌，可以包含用户标识、用户角色和权限等信息，以及您可以存储任何其他信息（自包含）。任何人都可以轻松读取和解析，并使用密钥来验证真实性。</p><p>缺陷：<br>1). JWT在生成token的时候支持失效时间，但是支持的失效时间是固定的，比如说一天。 但是用户在等出的时候是随机触发的，那么我们jwt token来做这个失效是不可行的，因为jwt在初始化的时候已经定死在什么时候过期了。 采用其他方案，在redis中存储token，设置token的过期时间，每次鉴权的时候都会去延长时间<br>2). jwt不适合存放大量信息，信息越多token越长</p>]]></content>
      
      
      <categories>
          
          <category> jwt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是 MongoDB</title>
      <link href="/2019/08/06/%E4%BB%80%E4%B9%88%E6%98%AF%20MongoDB/"/>
      <url>/2019/08/06/%E4%BB%80%E4%B9%88%E6%98%AF%20MongoDB/</url>
      
        <content type="html"><![CDATA[<p><strong>MongoDB</strong> 是一个介于关系数据库和非关系数据库之间的开源产品，是最接近于关系型数据库的 NoSQL 数据库。它在轻量级JSON 交换基础之上进行了扩展，即称为 BSON 的方式来描述其无结构化的数据类型。尽管如此它同样可以存储较为复杂的数据类型。它和上一篇文章讲到的Redis有异曲同工之妙。虽然两者均为 NoSQL ，但是 MongoDB 相对于 Redis 而言，MongoDB 更像是传统的数据库。早些年我们是先有了 Relation Database (关系型数据库)，然后出现了很多很复杂的query ，里面用到了很多嵌套，很多 join 操作。所以在设计数据库的时候，我们也考虑到了如何应用他们的关系，使得写 query 可以使 database 效率达到最高。后来人们发现，不是每个系统，都需要如此复杂的关系型数据库。有些简单的网站，比如博客，比如社交网站，完全可以斩断数据库之间的一切关系。这样做带来的好处是，设计数据库变得更加简单，写 query 也变得更加简单。然后，query 消耗的时间可能也会变少。因为 query 简单了，少了许多消耗资源的 join 操作，速度自然会上去。正如所说的， query 简单了，很有以前 MySQL 可以找到的东西，现在关系没了，通过 Mongo 找不到了。我们只能将几组数据都抓到本地，然后在本地做 join ，所以在这点上可能会消耗很多资源。这里我们可以发现。如何选择数据库，完全取决于你所需要处理的数据的模型，即 Data Model 。如果它们之间，关系错综复杂，千丝万缕，这个时候 MySQL 一定是首选。如果他们的关系并不是那么密切，那么， NoSQL 将会是利器。</p><h5 id="MongoDB-和-Redis-一样均为-key-value-存储系统，它具有以下特点："><a href="#MongoDB-和-Redis-一样均为-key-value-存储系统，它具有以下特点：" class="headerlink" title="MongoDB 和 Redis 一样均为 key-value 存储系统，它具有以下特点："></a>MongoDB 和 Redis 一样均为 key-value 存储系统，它具有以下<strong>特点</strong>：</h5><p>面向集合存储，易存储对象类型的数据。 模式自由。 支持动态查询。 支持完全索引，包含内部对象。 支持查询。 支持复制和故障恢复。 使用高效的二进制数据存储，包括大型对象(如视频等)。 自动处理碎片，以支持云计算层次的扩展性 支持 Python ， PHP ， Ruby ， Java ， C ， C# ， Javascript ，Perl 及 C++ 语言的驱动程序，社区中也提供了对 Erlang 及 .NET 等平台的驱动程序。 文件存储格式为 BSON (一种 JSON 的扩展)。 可通过网络访问。</p><h3 id="MongoDB-与-MySQL-性能比较"><a href="#MongoDB-与-MySQL-性能比较" class="headerlink" title="MongoDB 与 MySQL 性能比较"></a>MongoDB 与 MySQL 性能比较</h3><p>像 MySQL 一样， MongoDB 提供了丰富的远远超出了简单的键值存储中提供的功能和功能。 MongoDB 具有查询语言，功能强大的辅助索引(包括文本搜索和地理空间)，数据分析功能强大的聚合框架等。相比使用关系数据库而言，使用MongoDB ，您还可以使用如下表所示的这些功能，跨越更多样化的数据类型和数据规模。</p><p>MySQLMongoDB丰富的数据模型否是动态 Schema否是数据类型是是数据本地化否是字段更新是是易于编程否是复杂事务是否审计是是自动分片否是</p><p>MySQL 中的许多概念在 MongoDB 中具有相近的类比。本表概述了每个系统中的一些常见概念。</p><p>MySQLMongoDB表集合行文档列字段joins嵌入文档或者链接</p><h3 id="MongoDB应用范围和限制"><a href="#MongoDB应用范围和限制" class="headerlink" title="MongoDB应用范围和限制"></a>MongoDB应用范围和限制</h3><p>MongoDB 的主要目标是在 key-value (键/值)存储方式(提供了高性能和高度伸缩性)以及传统的 RDBMS 系统(丰富的功能)架起一座桥梁，集两者的优势于一身。 MongoDB 适用范围如下：</p><p>网站数据： Mongo 非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。 缓存：由于性能很高， Mongo 也适合作为信息基础设施的缓存层。在系统重启之后，由 Mongo 搭建的持久化缓存层可以避免下层的数据源过载。 大尺寸，低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。 高伸缩性的场景： Mongo 非常适合由数十或数百台服务器组成的数据库。 Mongo 的路线图中已经包含对 MapReduce 引擎的内置支持。 用于对象及 JSON 数据的存储： Mongo 的 BSON 数据格式非常适合文档化格式的存储及查询。 MongoDB 当然也会有以下场景的限制：</p><p>高度事物性的系统：例如银行或会计系统。传统的关系型数据库目前还是更适用于需要大量原子性复杂事务的应用程序。 传统的商业智能应用：针对特定问题的 BI 数据库会对产生高度优化的查询方式。对于此类应用，数据仓库可能是更合适的选择。 需要 SQL 的问题。</p>]]></content>
      
      
      <categories>
          
          <category> mongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue页面结构&amp;语法</title>
      <link href="/2019/07/30/vue%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84&amp;%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/07/30/vue%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84&amp;%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-vue页面结构"><a href="#1-vue页面结构" class="headerlink" title="1.vue页面结构"></a>1.vue页面结构</h2><pre class="highlight"><span class="line">//页面骨架</span><br><span class="line">&lt;template&gt;  </span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// 页面行为</span><br><span class="line">&lt;script&gt;  </span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//页面样式</span><br><span class="line">&lt;style&gt;  </span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre><hr><h2 id="2-vue基本语法"><a href="#2-vue基本语法" class="headerlink" title="2.vue基本语法"></a>2.vue基本语法</h2><pre class="highlight"><span class="line">v-html:显示（能解析html格式）</span><br><span class="line"></span><br><span class="line">&#123;&#123; &#125;&#125;：显示（原样显示）</span><br><span class="line"></span><br><span class="line">v-show：隐藏（true/<span class="number">1</span>显示，fales/<span class="number">0</span>不显示）</span><br><span class="line"></span><br><span class="line">v-<span class="keyword">if</span>/v-<span class="keyword">else</span>-<span class="keyword">if</span>/v-<span class="keyword">else</span>:条件判断，多重判断</span><br><span class="line"></span><br><span class="line">v-<span class="keyword">for</span>=<span class="string">&#x27;(item,index) in data&#x27;</span>:循环遍历  <span class="comment">#item:遍历输出的个体 index：</span></span><br><span class="line">列表的下标 data：循环的列表</span><br><span class="line"></span><br><span class="line">v-bind:简写为‘：’绑定（标签里使用的绑定）</span><br><span class="line">v-on:简写为‘@’双向绑定（标签里使用的绑定）</span><br><span class="line"></span><br><span class="line">v-model:双向数据绑定（表单里使用的绑定）</span><br></pre><hr><h2 id="3-vue基础行为"><a href="#3-vue基础行为" class="headerlink" title="3.vue基础行为"></a>3.vue基础行为</h2><pre class="highlight"><span class="line"></span><br><span class="line">//定义数据</span><br><span class="line">data:&#123;  </span><br><span class="line">    <span class="keyword">return</span>&#123;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//钩子函数：样式加载前</span><br><span class="line">mounted（）&#123;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//钩子函数：所有数据加载前 比mounted更快</span><br><span class="line">created（）&#123;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//计算属性（在不改变原始值的情况下进行操作，非必须）</span><br><span class="line">computed：&#123;  </span><br><span class="line">    reverse_msg:function()&#123;</span><br><span class="line">        console_log()控制台输出</span><br><span class="line">        <span class="keyword">return</span> this.msg.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)<span class="comment">#反转        </span></span><br><span class="line">    &#125;，</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//监听属性(监听自定义变量的变化)</span><br><span class="line">watch：&#123;  </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//自定义函数方法</span><br><span class="line">methods:&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre><pre class="highlight"><span class="line">//vue的各种互动用法</span><br><span class="line">console.log(res) //控制台输出</span><br><span class="line">this.$Message(res.data.message)  //提示框</span><br><span class="line">this.$Notice(res.data.message)  //警示框</span><br><span class="line">this.$router.push(<span class="string">&#x27;/&#x27;</span>)  //页面跳转</span><br><span class="line">this.$route.query.键 //从url里获取参数值</span><br></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue页面结构&amp;语法</title>
      <link href="/2019/07/30/vue%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84&amp;%E8%AF%AD%E6%B3%95%20-%20%E5%89%AF%E6%9C%AC%20-%20%E5%89%AF%E6%9C%AC%20(12)/"/>
      <url>/2019/07/30/vue%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84&amp;%E8%AF%AD%E6%B3%95%20-%20%E5%89%AF%E6%9C%AC%20-%20%E5%89%AF%E6%9C%AC%20(12)/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue页面结构&amp;语法</title>
      <link href="/2019/07/30/vue%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84&amp;%E8%AF%AD%E6%B3%95%20-%20%E5%89%AF%E6%9C%AC%20-%20%E5%89%AF%E6%9C%AC%20(11)/"/>
      <url>/2019/07/30/vue%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84&amp;%E8%AF%AD%E6%B3%95%20-%20%E5%89%AF%E6%9C%AC%20-%20%E5%89%AF%E6%9C%AC%20(11)/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue页面结构&amp;语法</title>
      <link href="/2019/07/30/vue%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84&amp;%E8%AF%AD%E6%B3%95%20-%20%E5%89%AF%E6%9C%AC%20-%20%E5%89%AF%E6%9C%AC%20(14)/"/>
      <url>/2019/07/30/vue%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84&amp;%E8%AF%AD%E6%B3%95%20-%20%E5%89%AF%E6%9C%AC%20-%20%E5%89%AF%E6%9C%AC%20(14)/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue页面结构&amp;语法</title>
      <link href="/2019/07/30/vue%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84&amp;%E8%AF%AD%E6%B3%95%20-%20%E5%89%AF%E6%9C%AC%20-%20%E5%89%AF%E6%9C%AC%20(13)/"/>
      <url>/2019/07/30/vue%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84&amp;%E8%AF%AD%E6%B3%95%20-%20%E5%89%AF%E6%9C%AC%20-%20%E5%89%AF%E6%9C%AC%20(13)/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue页面结构&amp;语法</title>
      <link href="/2019/07/30/vue%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84&amp;%E8%AF%AD%E6%B3%95%20-%20%E5%89%AF%E6%9C%AC%20-%20%E5%89%AF%E6%9C%AC%20(15)/"/>
      <url>/2019/07/30/vue%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84&amp;%E8%AF%AD%E6%B3%95%20-%20%E5%89%AF%E6%9C%AC%20-%20%E5%89%AF%E6%9C%AC%20(15)/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue页面结构&amp;语法</title>
      <link href="/2019/07/30/vue%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84&amp;%E8%AF%AD%E6%B3%95%20-%20%E5%89%AF%E6%9C%AC%20-%20%E5%89%AF%E6%9C%AC%20(16)/"/>
      <url>/2019/07/30/vue%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84&amp;%E8%AF%AD%E6%B3%95%20-%20%E5%89%AF%E6%9C%AC%20-%20%E5%89%AF%E6%9C%AC%20(16)/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue目录</title>
      <link href="/2019/07/24/vue%E7%9B%AE%E5%BD%95/"/>
      <url>/2019/07/24/vue%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-npm相关操作"><a href="#1-npm相关操作" class="headerlink" title="1.npm相关操作"></a>1.npm相关操作</h2><pre class="highlight"><span class="line">npm改源：npm set registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">npm版本查询：npm -v</span><br><span class="line"></span><br><span class="line">npm升级：npm install -g npm</span><br><span class="line"></span><br><span class="line">安装所有依赖：npm install  <span class="comment">#在vue项目目录下进行</span></span><br><span class="line"></span><br><span class="line">npm run dev 启动不了：</span><br><span class="line"></span><br><span class="line">​删除node_modules:</span><br><span class="line"></span><br><span class="line">​安装npm install rimraf -g</span><br><span class="line"></span><br><span class="line">​然后rimraf node_modules</span><br></pre><hr><h2 id="2-vue目录"><a href="#2-vue目录" class="headerlink" title="2.vue目录"></a>2.vue目录</h2><pre class="highlight"><span class="line">build：打包文件</span><br><span class="line"></span><br><span class="line">​config：配置文件</span><br><span class="line"></span><br><span class="line">​disk:打包后的文件在这个里面，一开始没有</span><br><span class="line"></span><br><span class="line">​node_modules：根据package.json下载的所有依赖在这里面，不能上传库，解决方法：.gitignore文件中写入不上传的文件名。  <span class="comment">#vue和django项目中都有.gitignore</span></span><br><span class="line"></span><br><span class="line">​src：所有代码在这个里面</span><br><span class="line"></span><br><span class="line">​   assets：放样式和静态</span><br><span class="line">        bootstrap：手机模式样式</span><br><span class="line"></span><br><span class="line">​   components：组件文件夹  <span class="comment">#所有页面在这里面</span></span><br><span class="line"></span><br><span class="line">​   router：放所有路由的</span><br><span class="line">        mode：<span class="string">&#x27;history&#x27;</span>  <span class="comment">#去掉url中的#</span></span><br><span class="line">        path：url</span><br><span class="line">        name：命名空间  <span class="comment">#模板跳转使用</span></span><br><span class="line">        component：组件名称</span><br><span class="line"></span><br><span class="line">   App.vue:渲染组件，绑定vue和页面节点</span><br><span class="line">   </span><br><span class="line">   config:项目配置  <span class="comment">#自定义</span></span><br><span class="line"></span><br><span class="line">​   main.js:入口文件，实例生成，组件引用</span><br><span class="line"></span><br><span class="line">static:静态文件夹</span><br><span class="line"></span><br><span class="line">​package.json：所有模块依赖的集合 npm install 根据这个进行安装</span><br><span class="line"></span><br><span class="line">.gitignore：文件中写入不上传的文件名</span><br></pre><hr>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue国际化</title>
      <link href="/2019/07/13/Vue%E5%9B%BD%E9%99%85%E5%8C%96/"/>
      <url>/2019/07/13/Vue%E5%9B%BD%E9%99%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="这里所说的国际化，是根据访问者的浏览器语言来更改页面语言。"><a href="#这里所说的国际化，是根据访问者的浏览器语言来更改页面语言。" class="headerlink" title="这里所说的国际化，是根据访问者的浏览器语言来更改页面语言。"></a>这里所说的国际化，是根据访问者的浏览器语言来更改页面语言。</h2><h3 id="导入插件"><a href="#导入插件" class="headerlink" title="导入插件:"></a>导入插件:</h3><pre class="highlight"><span class="line">npm install vue-i18n --save</span><br></pre><hr><h3 id="在main的js中注册该组件"><a href="#在main的js中注册该组件" class="headerlink" title="在main的js中注册该组件:"></a>在main的js中注册该组件:</h3><pre class="highlight"><span class="line">// 导入</span><br><span class="line"><span class="keyword">import</span> VueI18n <span class="keyword">from</span> <span class="string">&#x27;vue-i18n&#x27;</span></span><br><span class="line">// 注册</span><br><span class="line">Vue.use(VueI18n)</span><br></pre><hr><pre class="highlight"><span class="line">在src目录下新建lang文件夹，在文件夹中新建zh.js和en.js文件</span><br><span class="line"></span><br><span class="line">在两个文件中(如果不止是中文和英文的话就再新建对应的文件)输入对应的文本，具体内容按自己需求而定，</span><br><span class="line"></span><br></pre><hr><h3 id="这是我自己的zh-js文件内容"><a href="#这是我自己的zh-js文件内容" class="headerlink" title="这是我自己的zh.js文件内容:"></a>这是我自己的zh.js文件内容:</h3><pre class="highlight"><span class="line">// 双语规范的变量(中文)</span><br><span class="line"></span><br><span class="line">export const m = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">&#x27;welcome&#x27;</span>: <span class="string">&#x27;欢迎您&#x27;</span>,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre><hr><h3 id="这是我的en-js文件内容"><a href="#这是我的en-js文件内容" class="headerlink" title="这是我的en.js文件内容:"></a>这是我的en.js文件内容:</h3><pre class="highlight"><span class="line">// 双语规范的变量(英文)</span><br><span class="line"></span><br><span class="line">export const m= &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="string">&#x27;welcome&#x27;</span>: <span class="string">&#x27;Welcome!&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre><hr><h5 id="然后再在main-js中加入以下内容，注意要放在上次写的语句下面"><a href="#然后再在main-js中加入以下内容，注意要放在上次写的语句下面" class="headerlink" title="然后再在main.js中加入以下内容，注意要放在上次写的语句下面:"></a>然后再在main.js中加入以下内容，注意要放在上次写的语句下面:</h5><pre class="highlight"><span class="line">// 导入语言包</span><br><span class="line">const i18n = new VueI18n(&#123;</span><br><span class="line">  // 当前默认语言</span><br><span class="line">  locale: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">  // 语言包声明</span><br><span class="line">  messages:&#123;</span><br><span class="line">    <span class="string">&#x27;zh&#x27;</span>: require(<span class="string">&#x27;./lang/zh&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;en&#x27;</span>: require(<span class="string">&#x27;./lang/en&#x27;</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre><hr><h6 id="在new-Vue中加入以下内容"><a href="#在new-Vue中加入以下内容" class="headerlink" title="在new Vue中加入以下内容:"></a>在new Vue中加入以下内容:</h6><pre class="highlight"><span class="line">i18n</span><br></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selenium &amp; PhantomJS</title>
      <link href="/2019/07/01/Selenium%20&amp;%20PhantomJS/"/>
      <url>/2019/07/01/Selenium%20&amp;%20PhantomJS/</url>
      
        <content type="html"><![CDATA[<h2 id="1-selenium介绍"><a href="#1-selenium介绍" class="headerlink" title="1.selenium介绍"></a>1.selenium介绍</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍:"></a>介绍:</h3><p>1.selenium是一个web自动化测试用的框架. 程序员可以通过代码实现对浏览器的控制, 比如打开网页, 点击网页中的元素, 实现鼠标滚动等操作.<br>2.它支持多款浏览器, 如谷歌浏览器, 火狐浏览器等等, 当然也支持无头浏览器.</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的:"></a>目的:</h3><p>在爬取数据的过程中, 经常遇到动态数据加载, 一般动态数据加载有两种, 一种通过ajax请求加载数据, 另一种通过js代码加载动态数据. selenium可以模拟人操作真实浏览器, 获取加载完成的页面数据<br>ajax:<br>    url有规律且未加密, 直接构建url连接请求<br>    url加密过无法破解规律 –&gt; selenium<br>js动态数据加载 –&gt;  selenium</p><hr><h2 id="2-selenium安装"><a href="#2-selenium安装" class="headerlink" title="2.selenium安装"></a>2.selenium安装</h2><pre class="highlight"><span class="line">pip install selenium</span><br></pre><pre class="highlight"><span class="line">三要素: 浏览器, 驱动程序, selenium框架</span><br><span class="line"></span><br><span class="line">浏览器: 推荐谷歌浏览器, 标准稳定版本</span><br><span class="line">驱动程序:http:&#x2F;&#x2F;chromedriver.storage.googleapis.com&#x2F;index.html</span><br><span class="line"></span><br><span class="line"># 测试:</span><br><span class="line">from selenium import webdriver</span><br><span class="line">browser &#x3D; webdriver.Chrome(&#39;.&#x2F;webdriver&#39;)   # 将驱动放在脚本所在的文件夹</span><br><span class="line">browser.get(&#39;www.baidu.com&#39;)</span><br></pre><hr><h2 id="3-selenium常用操作"><a href="#3-selenium常用操作" class="headerlink" title="3.selenium常用操作"></a>3.selenium常用操作</h2><pre class="highlight"><span class="line"># 实例化浏览器对象:</span><br><span class="line">from selenium import webdriver</span><br><span class="line">browser &#x3D; webdriver.Chrome(&#39;driverpath&#39;)</span><br><span class="line"></span><br><span class="line"># 发送get请求:</span><br><span class="line">browser.get(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;)</span><br><span class="line"></span><br><span class="line"># 获取页面元素:</span><br><span class="line">find_element_by_id:根据元素的id</span><br><span class="line">find_element_by_name:根据元素的name</span><br><span class="line">find_element_by_xpath:根据xpath表达式</span><br><span class="line">find_element_by_class_name:根据class的值</span><br><span class="line">find_element_by_css_selector:根据css选择器</span><br><span class="line"></span><br><span class="line"># 节点交互操作:</span><br><span class="line">click(): 点击</span><br><span class="line">send_keys(): 输入内容</span><br><span class="line">clear(): 清空操作</span><br><span class="line">execute_script(js): 执行指定的js代码</span><br><span class="line"></span><br><span class="line"># JS代码: window.scrollTo(0, document.body.scrollHeight)可以模拟鼠标滚动一屏高度</span><br><span class="line">quit(): 退出</span><br><span class="line"></span><br><span class="line"># 获取网页源码:</span><br><span class="line">browser.page_source  ---&gt;  str类型</span><br><span class="line"></span><br><span class="line"># frame</span><br><span class="line">switch_to.frame(&#39;frameid&#39;) </span><br><span class="line"></span><br></pre><hr><h2 id="4-qq空间模拟登陆"><a href="#4-qq空间模拟登陆" class="headerlink" title="4.qq空间模拟登陆"></a>4.qq空间模拟登陆</h2><pre class="highlight"><span class="line">from selenium import webdriver</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 实例化浏览器对象</span><br><span class="line">browser &#x3D; webdriver.Chrome(&#39;.&#x2F;chromedriver.exe&#39;)</span><br><span class="line"></span><br><span class="line"># 打开qq空间登陆页面</span><br><span class="line">browser.get(&#39;https:&#x2F;&#x2F;qzone.qq.com&#x2F;&#39;)</span><br><span class="line">time.sleep(1)</span><br><span class="line"></span><br><span class="line"># 转至frame子页面</span><br><span class="line">browser.switch_to.frame(&#39;login_frame&#39;)</span><br><span class="line"></span><br><span class="line"># 获取密码登陆选项并点击</span><br><span class="line">a_tag &#x3D; browser.find_element_by_id(&#39;switcher_plogin&#39;)</span><br><span class="line">a_tag.click()</span><br><span class="line">time.sleep(1)</span><br><span class="line"></span><br><span class="line"># 获取账号输入框并输入账号</span><br><span class="line">browser.find_element_by_id(&#39;u&#39;).clear()</span><br><span class="line">user &#x3D; browser.find_element_by_id(&#39;u&#39;)</span><br><span class="line">user.send_keys(&#39;3338003899&#39;)</span><br><span class="line">time.sleep(1)</span><br><span class="line"></span><br><span class="line"># 获取密码输入框并输入密码</span><br><span class="line">browser.find_element_by_id(&#39;p&#39;).clear()</span><br><span class="line">pwd &#x3D; browser.find_element_by_id(&#39;p&#39;)</span><br><span class="line">pwd.send_keys(&#39;qq123456&#39;)</span><br><span class="line">time.sleep(1)</span><br><span class="line"></span><br><span class="line"># 获取登陆按钮并单击</span><br><span class="line">button &#x3D; browser.find_element_by_id(&#39;login_button&#39;)</span><br><span class="line">button.click()</span><br></pre><hr><h2 id="5-PhantomJS浏览器使用"><a href="#5-PhantomJS浏览器使用" class="headerlink" title="5.PhantomJS浏览器使用"></a>5.PhantomJS浏览器使用</h2><h3 id="PhantomJS下载及配置环境变量"><a href="#PhantomJS下载及配置环境变量" class="headerlink" title="PhantomJS下载及配置环境变量"></a>PhantomJS下载及配置环境变量</h3><pre><code>- 下载, 直接解压- 将解压文件的bin目录添加至环境变量</code></pre><hr><h3 id="PhantomJS无界面浏览器"><a href="#PhantomJS无界面浏览器" class="headerlink" title="PhantomJS无界面浏览器"></a>PhantomJS无界面浏览器</h3><pre class="highlight"><span class="line">from selenium import webdriver</span><br><span class="line">browser &#x3D; webdriver.PhantomJS()</span><br><span class="line">browser.get(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;)</span><br><span class="line">with open(&#39;baidu_phantomjs.html&#39;, &#39;w&#39;, encoding&#x3D;&quot;utf-8&quot;) as f:</span><br><span class="line">    f.write(browser.page_source)</span><br></pre><h3 id="谷歌无头浏览器"><a href="#谷歌无头浏览器" class="headerlink" title="谷歌无头浏览器"></a>谷歌无头浏览器</h3><pre class="highlight"><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.chrome.options import Options</span><br><span class="line"></span><br><span class="line">chrome_options &#x3D; Options()</span><br><span class="line">chrome_options.add_argument(&#39;--headless&#39;)</span><br><span class="line">chrome_options.add_argument(&#39;--disable-gpu&#39;)</span><br><span class="line">browser &#x3D; webdriver.Chrome(chrome_options&#x3D;chrome_options)</span><br><span class="line">browser.get(&quot;https:&#x2F;&#x2F;www.baidu.com&quot;)</span><br><span class="line">print(browser.page_source)</span><br><span class="line">with open(&#39;baidu_headerless.html&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">    f.write(browser.page_source)</span><br></pre><hr><h2 id="6-图片懒加载"><a href="#6-图片懒加载" class="headerlink" title="6..图片懒加载"></a>6..图片懒加载</h2><pre class="highlight"><span class="line">import requests</span><br><span class="line">from lxml import etree</span><br><span class="line">from urllib import request</span><br><span class="line">import urllib</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;sc.chinaz.com&#x2F;tupian&#x2F;index.html&#39;</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;USer-Agent&quot;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line">res.encoding &#x3D; &#39;utf-8&#39;</span><br><span class="line"># print(res.text)</span><br><span class="line">tree &#x3D; etree.HTML(res.text)</span><br><span class="line"></span><br><span class="line">src_list &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[contains(@class,&quot;box&quot;)]&#x2F;div&#x2F;a&#x2F;img&#x2F;@src2&#39;)</span><br><span class="line">for url_img in src_list:</span><br><span class="line">    request.urlretrieve(url_img,&#39;%s.jpg&#39;%src_list.index(url_img))</span><br><span class="line">    </span><br></pre><hr><pre class="highlight"><span class="line">from selenium import webdriver</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">browser &#x3D; webdriver.Chrome(&#39;.&#x2F;chromedriver.exe&#39;)</span><br><span class="line">browser.get(&#39;http:&#x2F;&#x2F;image.baidu.com&#x2F;&#39;)</span><br><span class="line">search &#x3D; browser.find_element_by_id(&#39;kw&#39;)</span><br><span class="line">search.send_keys(&#39;安琪拉&#39;)</span><br><span class="line">button &#x3D; browser.find_element_by_class_name(&#39;s_search&#39;)</span><br><span class="line">button.click()</span><br><span class="line">for i in range(3):</span><br><span class="line">    browser.execute_script(&#39;window.scrollTo(0, document.body.scrollHeight)&#39;)</span><br><span class="line">    time.sleep(5)</span><br><span class="line"></span><br><span class="line">text &#x3D; browser.page_source</span><br><span class="line">with open(&#39;baidu_pic.html&#39;, &#39;w&#39;, encoding&#x3D;&quot;utf-8&quot;) as f:</span><br><span class="line">    f.write(text)</span><br><span class="line"></span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup &#x3D; BeautifulSoup(open(&#39;.&#x2F;baidu_pic.html&#39;, &#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;), &#39;lxml&#39;)</span><br><span class="line">li_list &#x3D; soup.select(&#39;.imgpage ul li&#39;)</span><br><span class="line">for url_img in li_list:</span><br><span class="line">    url_img &#x3D; url_img[&#39;data-objurl&#39;]</span><br><span class="line">    print(url_img)</span><br></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy框架（2）</title>
      <link href="/2019/06/22/Scrapy%E6%A1%86%E6%9E%B6%EF%BC%882%EF%BC%89/"/>
      <url>/2019/06/22/Scrapy%E6%A1%86%E6%9E%B6%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="1-scrapy-多页爬取"><a href="#1-scrapy-多页爬取" class="headerlink" title="1.scrapy 多页爬取"></a>1.scrapy 多页爬取</h2><pre class="highlight"><span class="line"># spider编码在原基础之上, 构建其他页面的url地址, 并利用scrapy.Request发起新的请求, 请求的回调函数依然是parse:page &#x3D; 1base_url &#x3D; &#39;http:&#x2F;&#x2F;www.xiaohuar.com&#x2F;list-1-%s.html&#39;if self.page &lt; 4:    page_url &#x3D; base_url%self.page    self.page +&#x3D; 1    yield scrapy.Request(url&#x3D;page_url, callback&#x3D;self.parse)# (其他文件不用改动)</span><br></pre><hr><h2 id="2-scrapy爬取详情页"><a href="#2-scrapy爬取详情页" class="headerlink" title="2.scrapy爬取详情页"></a>2.scrapy爬取详情页</h2><h4 id="需求-爬取笑话的标题与详情页连接-通过详情页链接-爬取详情页笑话内容"><a href="#需求-爬取笑话的标题与详情页连接-通过详情页链接-爬取详情页笑话内容" class="headerlink" title="需求: 爬取笑话的标题与详情页连接, 通过详情页链接, 爬取详情页笑话内容"></a>需求: 爬取笑话的标题与详情页连接, 通过详情页链接, 爬取详情页笑话内容</h4><pre class="highlight"><span class="line"># item编码: 定义数据持久化的字段信息</span><br><span class="line">import scrapy</span><br><span class="line">class JokeItem(scrapy.Item):</span><br><span class="line">    # define the fields for your item here like:</span><br><span class="line">    # name &#x3D; scrapy.Field()</span><br><span class="line">    title &#x3D; scrapy.Field()</span><br><span class="line">    content &#x3D; scrapy.Field()</span><br></pre><pre class="highlight"><span class="line"># spider的编码:</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import scrapy</span><br><span class="line">from ..items import JokeItem</span><br><span class="line"></span><br><span class="line">class XhSpider(scrapy.Spider):</span><br><span class="line">    name &#x3D; &#39;xh&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;http:&#x2F;&#x2F;www.jokeji.cn&#x2F;list.htm&#39;]</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        li_list &#x3D; response.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;list_title&quot;]&#x2F;ul&#x2F;li&#39;)</span><br><span class="line">        for li in li_list:</span><br><span class="line">            title &#x3D; li.xpath(&#39;.&#x2F;b&#x2F;a&#x2F;text()&#39;).extract_first()</span><br><span class="line">            link &#x3D; &#39;http:&#x2F;&#x2F;www.jokeji.cn&#39; + li.xpath(&#39;.&#x2F;b&#x2F;a&#x2F;@href&#39;).extract_first()</span><br><span class="line">            yield scrapy.Request(url&#x3D;link, callback&#x3D;self.datail_parse, meta&#x3D;&#123;&quot;title&quot;:title&#125;)</span><br><span class="line"></span><br><span class="line">    def datail_parse(self, response):</span><br><span class="line">        joke_list &#x3D; response.xpath(&#39;&#x2F;&#x2F;span[@id&#x3D;&quot;text110&quot;]&#x2F;&#x2F;text()&#39;).extract()</span><br><span class="line">        title &#x3D; response.meta[&quot;title&quot;]</span><br><span class="line">        content &#x3D; &#39;&#39;</span><br><span class="line">        for s in joke_list:</span><br><span class="line">            content +&#x3D; s</span><br><span class="line">        item &#x3D; JokeItem()</span><br><span class="line">        item[&quot;title&quot;] &#x3D; title</span><br><span class="line">        item[&quot;content&quot;] &#x3D; content</span><br><span class="line">        yield item</span><br></pre><pre class="highlight"><span class="line"># Pipeline编码: 数据持久化具体操作</span><br><span class="line">import pymongo</span><br><span class="line"></span><br><span class="line">class JokePipeline(object):</span><br><span class="line">    conn &#x3D; pymongo.MongoClient(&#39;localhost&#39;, 27017)</span><br><span class="line">    db &#x3D; conn.haha</span><br><span class="line">    table &#x3D; db.hahatable</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        self.table.insert(dict(item))</span><br><span class="line">        return item</span><br><span class="line"></span><br><span class="line">    def close_spider(self, spider):</span><br><span class="line">        self.conn.close()</span><br></pre><pre class="highlight"><span class="line"># settings配置编码:</span><br><span class="line">UA伪装</span><br><span class="line">Robots协议</span><br><span class="line">Item_Pipeline</span><br></pre><hr><h2 id="3-scrapy发送post请求"><a href="#3-scrapy发送post请求" class="headerlink" title="3.scrapy发送post请求"></a>3.scrapy发送post请求</h2><pre class="highlight"><span class="line">import scrapy</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FySpider(scrapy.Spider):</span><br><span class="line">    name &#x3D; &#39;fy&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;https:&#x2F;&#x2F;fanyi.baidu.com&#x2F;sug&#39;]</span><br><span class="line">    def start_requests(self):</span><br><span class="line">        data &#x3D; &#123;</span><br><span class="line">            &#39;kw&#39;:&#39;boy&#39;</span><br><span class="line">        &#125;</span><br><span class="line">        yield scrapy.FormRequest(url&#x3D;self.start_urls[0], callback&#x3D;self.parse, formdata&#x3D;data)</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        print(~~~~)</span><br><span class="line">        print(response.text)</span><br><span class="line">        print(json.loads(response.text))</span><br><span class="line"> print(~~~~)</span><br></pre><hr><h2 id="4-scrapy中间件"><a href="#4-scrapy中间件" class="headerlink" title="4.scrapy中间件"></a>4.scrapy中间件</h2><pre class="highlight"><span class="line"># 中间件分类:</span><br><span class="line">- 下载中间件: DownloadMiddleware</span><br><span class="line">- 爬虫中间件: SpiderMiddleware</span><br><span class="line"># 中间件的作用:</span><br><span class="line">- 下载中间件: 拦截请求与响应, 篡改请求与响应</span><br><span class="line">- 爬虫中间件: 拦截请求与响应, 拦截管道item, 篡改请求与响应, 处理item</span><br><span class="line"># 下载中间件的主要方法:</span><br><span class="line">process_request</span><br><span class="line">process_response</span><br><span class="line">process_exception</span><br></pre><h4 id="下载中间件拦截请求-使用代理ip案例"><a href="#下载中间件拦截请求-使用代理ip案例" class="headerlink" title="下载中间件拦截请求, 使用代理ip案例"></a>下载中间件拦截请求, 使用代理ip案例</h4><pre class="highlight"><span class="line"># spider编码:</span><br><span class="line">import scrapy</span><br><span class="line">class DlproxySpider(scrapy.Spider):</span><br><span class="line">    name &#x3D; &#39;dlproxy&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;ip&#39;]</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        with open(&#39;baiduproxy.html&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">            f.write(response.text)</span><br></pre><pre class="highlight"><span class="line"># Downloadermiddleware编码:</span><br><span class="line">def process_request(self, request, spider):</span><br><span class="line">    request.meta[&#39;proxy&#39;] &#x3D; &#39;http:&#x2F;&#x2F;111.231.90.122:8888&#39;</span><br><span class="line">    return None</span><br></pre><hr><h2 id="5-下载中间件实现UA池"><a href="#5-下载中间件实现UA池" class="headerlink" title="5.下载中间件实现UA池"></a>5.下载中间件实现UA池</h2><pre class="highlight"><span class="line"># spider编码:</span><br><span class="line">class DlproxySpider(scrapy.Spider):</span><br><span class="line">    name &#x3D; &#39;dlproxy&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;,&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;,&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;,&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;,&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;]</span><br><span class="line">    </span><br><span class="line">    def parse(self, response):</span><br><span class="line">        pass</span><br></pre><pre class="highlight"><span class="line"># 中间件的编码:</span><br><span class="line">from scrapy import signals</span><br><span class="line">from fake_useragent import UserAgent</span><br><span class="line">import random</span><br><span class="line">ua &#x3D; UserAgent()</span><br><span class="line">ua_list &#x3D; []</span><br><span class="line">for i in range(100):    </span><br><span class="line">    ua_chrome &#x3D; ua.Chrome    </span><br><span class="line">    ua_list.append(ua_chrome)    </span><br><span class="line">class ...():    </span><br><span class="line">    def process_request(self, request, spider):        </span><br><span class="line">        # request.meta[&#39;proxy&#39;] &#x3D; &#39;http:&#x2F;&#x2F;111.231.90.122:8888&#39;        </span><br><span class="line">        print(~~~~)        </span><br><span class="line">        print(self.ua_pool)        </span><br><span class="line">        print(~~~)        </span><br><span class="line">        request.headers[&#39;User-Agent&#39;] &#x3D; random.choice(self.ua_pool)        </span><br><span class="line">        return None   </span><br><span class="line">    def process_response(self, request, response, spider):      print(~~~~)        </span><br><span class="line">         print(request.headers[&quot;User-Agent&quot;])       </span><br><span class="line">         print(~~~)        </span><br><span class="line">         return response</span><br></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy框架（1）</title>
      <link href="/2019/06/12/scrapy%E6%A1%86%E6%9E%B6%EF%BC%881%EF%BC%89/"/>
      <url>/2019/06/12/scrapy%E6%A1%86%E6%9E%B6%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="1-scrapy安装与环境依赖"><a href="#1-scrapy安装与环境依赖" class="headerlink" title="1.scrapy安装与环境依赖"></a>1.scrapy安装与环境依赖</h2><p>在安装scrapy前需要安装好相应的依赖库, 再安装scrapy, 具体安装步骤如下:</p><h4 id="1-安装lxml库"><a href="#1-安装lxml库" class="headerlink" title="(1).安装lxml库"></a>(1).安装lxml库</h4><pre class="highlight"><span class="line">pip install lxml</span><br></pre><h4 id="2-安装wheel"><a href="#2-安装wheel" class="headerlink" title="(2).安装wheel"></a>(2).安装wheel</h4><pre class="highlight"><span class="line">pip install wheel</span><br></pre><h4 id="3-安装twisted"><a href="#3-安装twisted" class="headerlink" title="(3).安装twisted"></a>(3).安装twisted</h4><pre class="highlight"><span class="line">pip install twisted文件路径</span><br></pre><pre class="highlight"><span class="line">(twisted需下载后本地安装,下载地址:http:&#x2F;&#x2F;www.lfd.uci.edu&#x2F;~gohlke&#x2F;pythonlibs&#x2F;#twisted)</span><br><span class="line">    (版本选择如下图,版本后面有解释,请根据自己实际选择)</span><br></pre><p><img src="/hugoblog/twisted.png" alt="twisted" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/twisted.png" class="lozad post-image"></p><h4 id="4-安装pywin32"><a href="#4-安装pywin32" class="headerlink" title="(4).安装pywin32"></a>(4).安装pywin32</h4><pre class="highlight"><span class="line">pip install pywin32</span><br></pre><h4 id="5-安装scrapy"><a href="#5-安装scrapy" class="headerlink" title="(5).安装scrapy"></a>(5).安装scrapy</h4><pre class="highlight"><span class="line">pip install scrapy</span><br></pre><h4 id="6-成功验证"><a href="#6-成功验证" class="headerlink" title="(6).成功验证"></a>(6).成功验证</h4><pre class="highlight"><span class="line">在cmd命令行输入scrapy,显示Scrapy1.6.0-no active project,证明安装成功 </span><br></pre><hr><h2 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2.创建项目"></a>2.创建项目</h2><pre class="highlight"><span class="line">1.手动创建一个目录test</span><br><span class="line">2.在test文件夹下创建爬虫项目为spiderpro: scrapy startproject spiderpro</span><br><span class="line">3.进入项目文件夹: cd spiderpro</span><br><span class="line">4.创建爬虫文件: scrapy genspider 爬虫名 域名</span><br></pre><hr><h2 id="3-项目目录介绍"><a href="#3-项目目录介绍" class="headerlink" title="3.项目目录介绍"></a>3.项目目录介绍</h2><pre class="highlight"><span class="line">spiderpro</span><br><span class="line">　　spiderpro # 项目目录</span><br><span class="line">　　　　__init__</span><br><span class="line">　　　　spiders:爬虫文件目录</span><br><span class="line">　　　　　　__init__</span><br><span class="line">　　　　　　tests.py:爬虫文件</span><br><span class="line">　　　　items.py:定义爬取数据持久化的数据结构</span><br><span class="line">　　　　middlewares.py:定义中间件</span><br><span class="line">　　　　pipelines.py:管道,持久化存储相关</span><br><span class="line">　　　　settings.py:配置文件</span><br><span class="line">　　venv:虚拟环境目录</span><br><span class="line">　 scrapy.cfg: scrapy项目配置文件</span><br></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre class="highlight"><span class="line">(1).spiders:其内包含一个个Spider的实现, 每个Spider是一个单独的文件</span><br><span class="line">　　(2).items.py:它定义了Item数据结构, 爬取到的数据存储为哪些字段</span><br><span class="line">　　(3).pipelines.py:它定义Item Pipeline的实现</span><br><span class="line">　　(4).settings.py:项目的全局配置</span><br><span class="line">　　(5).middlewares.py:定义中间件, 包括爬虫中间件和下载中间件</span><br><span class="line">　　(6).scrapy.cfg:它是scrapy项目的配置文件, 其内定义了项目的配置路径, 部署相关的信息等</span><br></pre><hr><h2 id="4-scrapy框架介绍-5大核心组件与数据流向"><a href="#4-scrapy框架介绍-5大核心组件与数据流向" class="headerlink" title="4.scrapy框架介绍: 5大核心组件与数据流向"></a>4.scrapy框架介绍: 5大核心组件与数据流向</h2><p><img src="/hugoblog/scrapy.png" alt="scrapy" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/scrapy.png" class="lozad post-image"></p><h3 id="架构"><a href="#架构" class="headerlink" title="架构:"></a>架构:</h3><pre class="highlight"><span class="line">Scrapy Engine: 这是引擎，负责Spiders、ItemPipeline,Downloader、Scheduler中间的通讯，信号、数据传递等等!</span><br><span class="line"></span><br><span class="line">　　Scheduler(调度器): 它负责接受引擎发送过来的requests请求，并按照一定的方式进行整理排列，入队、并等待Scrapy Engine(引擎)来请求时，交给引擎。</span><br><span class="line"></span><br><span class="line">　　Downloader（下载器)：负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spiders来处理，</span><br><span class="line"></span><br><span class="line">　　Spiders：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器)，</span><br><span class="line"></span><br><span class="line">　　Item Pipeline：它负责处理Spiders中获取到的Item，并进行处理，比如去重，持久化存储（存数据库，写入文件，总之就是保存数据用的）</span><br><span class="line"></span><br><span class="line">　　Downloader Middlewares(下载中间件)：你可以当作是一个可以自定义扩展下载功能的组件</span><br><span class="line"></span><br><span class="line">　　Spider Middlewares(Spider中间件)：你可以理解为是一个可以自定扩展和操作引擎和Spiders中间‘通信‘的功能组件（比如进入Spiders的Responses;和从Spiders出去的Requests）</span><br></pre><hr><h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流:"></a>工作流:</h3><pre class="highlight"><span class="line">1.spider将请求发送给引擎, 引擎将request发送给调度器进行请求调度</span><br><span class="line"></span><br><span class="line">　　2.调度器把接下来要请求的request发送给引擎, 引擎传递给下载器, 中间会途径下载中间件</span><br><span class="line"></span><br><span class="line">　　3.下载携带request访问服务器, 并将爬取内容response返回给引擎, 引擎将response返回给spider</span><br><span class="line"></span><br><span class="line">　　4.spider将response传递给自己的parse进行数据解析处理及构建item一系列的工作, 最后将item返回给引擎, 引擎传递个pipeline</span><br><span class="line"></span><br><span class="line">　　5.pipe获取到item后进行数据持久化</span><br><span class="line"></span><br><span class="line">　　6.以上过程不断循环直至爬虫程序终止</span><br></pre><hr><h2 id="5-使用scrapy框架爬取糗百"><a href="#5-使用scrapy框架爬取糗百" class="headerlink" title="5.使用scrapy框架爬取糗百"></a>5.使用scrapy框架爬取糗百</h2><h4 id="需求-爬取糗事百科热门板块-每一条的标题-好笑-评论条数及作者信息-解析爬取的信息数据-定制item数据存储结构-最终将数据存储于MongoDB数据库中"><a href="#需求-爬取糗事百科热门板块-每一条的标题-好笑-评论条数及作者信息-解析爬取的信息数据-定制item数据存储结构-最终将数据存储于MongoDB数据库中" class="headerlink" title="需求: 爬取糗事百科热门板块,每一条的标题,好笑,评论条数及作者信息,解析爬取的信息数据,定制item数据存储结构,最终将数据存储于MongoDB数据库中."></a>需求: 爬取糗事百科热门板块,每一条的标题,好笑,评论条数及作者信息,解析爬取的信息数据,定制item数据存储结构,最终将数据存储于MongoDB数据库中.</h4><pre class="highlight"><span class="line"># 创建项目:</span><br><span class="line">scrapy startproject qsbk # 创建项目</span><br><span class="line">cd qsbk # 切换到项目目录</span><br><span class="line">scrapy genspider qsbk_hot www.qiushibaike.com # 创建爬虫文件, qsbk_hot为爬虫名, www...com为爬取范围</span><br></pre><hr><pre class="highlight"><span class="line"># item文件定义数据存储的字段:</span><br><span class="line">import scrapy</span><br><span class="line">class QsbkItem(scrapy.Item):</span><br><span class="line">    title &#x3D; scrapy.Field()  # 标题</span><br><span class="line">    lau &#x3D; scrapy.Field()  # 好笑数</span><br><span class="line">    comment &#x3D; scrapy.Field()  # 评论数</span><br><span class="line">    auth &#x3D; scrapy.Field()  # 作者</span><br></pre><pre class="highlight"><span class="line"># spider文件中定义解析数据的方法</span><br><span class="line">class QsbkHotSpider(scrapy.Spider):</span><br><span class="line">    name &#x3D;&#39;qsbk_hot&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.qiushibaike.com&#39;] # 无用, 可注释掉</span><br><span class="line">    start_urls &#x3D;[&#39;http:&#x2F;&#x2F;www.qiushibaike.com&#x2F;&#39;]</span><br><span class="line"></span><br><span class="line">    # 思路:一条热点数据在前端中对应一个li标签, 将一页中的所有li标签取出, 再进一步操作</span><br><span class="line">    def parse(self, response):</span><br><span class="line"></span><br><span class="line">        li_list &#x3D; response.selector.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;recommend-article&quot;]&#x2F;ul&#x2F;li&#39;)</span><br><span class="line"></span><br><span class="line">        # 循环li标签组成的列表, 先实例化item, 再取需要的字段, 并该item对象的相应属性赋值</span><br><span class="line">        for li in li_list:</span><br><span class="line"></span><br><span class="line">            # 实例化item对象</span><br><span class="line">            item &#x3D;QsbkItem()</span><br><span class="line"></span><br><span class="line">            # 解析获取title(标题), lau(好笑数), comment(评论数), auth(作者)等信息</span><br><span class="line">            title &#x3D; li.xpath(&#39;.&#x2F;div[@class&#x3D;&quot;recmd-right&quot;]&#x2F;a&#x2F;text()&#39;).extract_first()</span><br><span class="line">            lau &#x3D; li.xpath(&#39;.&#x2F;div[@class&#x3D;&quot;recmd-right&quot;]&#x2F;div[@class&#x3D;&quot;recmd-detail clearfix&quot;]&#x2F;div&#x2F;span[1]&#x2F;text()&#39;).extract_first()</span><br><span class="line">            comment &#x3D; li.xpath(&#39;.&#x2F;div[@class&#x3D;&quot;recmd-right&quot;]&#x2F;div[@class&#x3D;&quot;recmd-detail clearfix&quot;]&#x2F;div&#x2F;span[4]&#x2F;text()&#39;).extract_first()</span><br><span class="line">            auth &#x3D; li.xpath(&#39;.&#x2F;div[@class&#x3D;&quot;recmd-right&quot;]&#x2F;div[@class&#x3D;&quot;recmd-detail clearfix&quot;]&#x2F;a&#x2F;span&#x2F;text()&#39;).extract_first()</span><br><span class="line"></span><br><span class="line">            # 因为部分热点数据还没有评论和好笑数, 所以需对数据进行处理</span><br><span class="line">            if not lau:</span><br><span class="line">                lau &#x3D;None</span><br><span class="line">            if not comment:</span><br><span class="line">                comment &#x3D;None</span><br><span class="line"></span><br><span class="line">            # 将字段的值存储在item的属性中</span><br><span class="line">            item[&quot;title&quot;]&#x3D; title</span><br><span class="line">            item[&quot;lau&quot;]&#x3D; lau</span><br><span class="line">            item[&quot;comment&quot;]&#x3D; comment</span><br><span class="line">            item[&quot;auth&quot;]&#x3D; auth</span><br><span class="line"></span><br><span class="line">            # 返回item, 框架会自动将item传送至pipeline中的指定类</span><br><span class="line">            yield item</span><br></pre><pre class="highlight"><span class="line"># 在pipeline中定义管道类进行数据的存储</span><br><span class="line">import pymongo</span><br><span class="line"></span><br><span class="line">classQsbkPipeline(object):</span><br><span class="line">　　# 连接MongoDB数据库</span><br><span class="line">conn &#x3D; pymongo.MongoClient(&quot;localhost&quot;, 27017)</span><br><span class="line">db &#x3D; conn.qiubai  #(数据库名)</span><br><span class="line">table &#x3D; db.qb_hot  #(表名)</span><br><span class="line"></span><br><span class="line">　　def process_item(self, item, spider):</span><br><span class="line">　　　　# 向数据库中出入数据</span><br><span class="line">　　　　self.table.insert(dict(item))</span><br><span class="line"></span><br><span class="line">　　　　# 此处return item是为了下一个管道类能够接收到item进行存储</span><br><span class="line">　　　　return item</span><br><span class="line"></span><br><span class="line">　　def close_spider(self):</span><br><span class="line">　　　　# 关闭数据库连接</span><br><span class="line">　　　　self.conn.close()</span><br></pre><pre class="highlight"><span class="line"># 此示例中配置文件中的配置的项, 注意是不是全部的配置, 是针对该项目增加或修改的配置项</span><br><span class="line"></span><br><span class="line"># 忽略robots协议</span><br><span class="line">ROBOTSTXT_OBEY &#x3D;False</span><br><span class="line"></span><br><span class="line"># UA伪装</span><br><span class="line">USER_AGENT &#x3D; &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;76.0.3809.87 Safari&#x2F;537.36&#39;</span><br><span class="line"></span><br><span class="line"># 管道类的注册配置</span><br><span class="line">ITEM_PIPELINES &#x3D;&#123;</span><br><span class="line">&#39;qsbk.pipelines.QsbkPipeline&#39;:300,</span><br><span class="line">&#125;</span><br></pre><hr><h2 id="6-scrapy爬取校花网人名与图片下载链接"><a href="#6-scrapy爬取校花网人名与图片下载链接" class="headerlink" title="6.scrapy爬取校花网人名与图片下载链接"></a>6.scrapy爬取校花网人名与图片下载链接</h2><h4 id="需求-爬取校花网大学校花的默认的第一页的所有图片src和人名-并通过管道存入mongodb数据库"><a href="#需求-爬取校花网大学校花的默认的第一页的所有图片src和人名-并通过管道存入mongodb数据库" class="headerlink" title="需求: 爬取校花网大学校花的默认的第一页的所有图片src和人名, 并通过管道存入mongodb数据库"></a>需求: 爬取校花网大学校花的默认的第一页的所有图片src和人名, 并通过管道存入mongodb数据库</h4><pre class="highlight"><span class="line"># 创建项目:</span><br><span class="line">scrapy startproject xiaohuaspider # 创建项目</span><br><span class="line">cd xiaohuaspider # 切换到项目目录</span><br><span class="line">scrapy genspider hua www.baidu.com # 创建爬虫文件, hua为爬虫名, www.baidu.com为爬取范围</span><br></pre><hr><pre class="highlight"><span class="line"># 创建item类, 用于存储解析出的数据</span><br><span class="line">import scrapy</span><br><span class="line">class XiaohuaspiderItem(scrapy.Item):</span><br><span class="line">    name &#x3D; scrapy.Field()</span><br><span class="line">    src &#x3D; scrapy.Field()</span><br></pre><hr><pre class="highlight"><span class="line"># spider中定义爬取的行为与解析数据的操作</span><br><span class="line">import scrapy</span><br><span class="line">from ..items import XiaohuaspiderItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HuaSpider(scrapy.Spider):</span><br><span class="line">    name &#x3D; &#39;hua&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;http:&#x2F;&#x2F;www.xiaohuar.com&#x2F;hua&#x2F;&#39;]</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        div_list &#x3D; response.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;img&quot;]&#39;)</span><br><span class="line">        for div in div_list:</span><br><span class="line">            item &#x3D; XiaohuaspiderItem()</span><br><span class="line">            name &#x3D; div.xpath(&#39;.&#x2F;&#x2F;span&#x2F;text()&#39;).extract_first()</span><br><span class="line">            src &#x3D; div.xpath(&#39;.&#x2F;a&#x2F;img&#x2F;@src&#39;).extract_first()</span><br><span class="line">            item[&quot;name&quot;] &#x3D; name</span><br><span class="line">            item[&quot;src&quot;] &#x3D; src</span><br><span class="line">            yield item</span><br></pre><hr><pre class="highlight"><span class="line"># itemPipeline编码, 持久化数据到本地</span><br><span class="line">import pymongo</span><br><span class="line"></span><br><span class="line">class XiaohuaspiderPipeline(object):</span><br><span class="line">    conn &#x3D; pymongo.MongoClient(&#39;localhost&#39;, 27017)</span><br><span class="line">    db &#x3D; conn.xiaohua</span><br><span class="line">    table &#x3D; db.hua</span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        self.table.insert(dict(item))</span><br><span class="line">        return item</span><br><span class="line">    def close_spider(self, spider):</span><br><span class="line">        self.conn.close()</span><br></pre><hr><pre class="highlight"><span class="line"># 配置项:</span><br><span class="line"># UA伪装:</span><br><span class="line">USER_AGENT &#x3D; &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;76.0.3809.87 Safari&#x2F;537.36&#39;</span><br><span class="line"></span><br><span class="line"># 忽略robots协议:</span><br><span class="line">ROBOTSTXT_OBEY &#x3D; False</span><br><span class="line"></span><br><span class="line"># 开启管道类</span><br><span class="line">ITEM_PIPELINES &#x3D; &#123;</span><br><span class="line">   &#39;xiaohuaspider.pipelines.XiaohuaspiderPipeline&#39;: 300,</span><br><span class="line">&#125;</span><br></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy &amp; Django项目</title>
      <link href="/2019/05/29/Scrapy%20&amp;%20Django%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/05/29/Scrapy%20&amp;%20Django%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="需求-编写爬虫项目与Django项目详解和-将爬取到的数据展示到前端页面上"><a href="#需求-编写爬虫项目与Django项目详解和-将爬取到的数据展示到前端页面上" class="headerlink" title="需求: 编写爬虫项目与Django项目详解和, 将爬取到的数据展示到前端页面上"></a>需求: 编写爬虫项目与Django项目详解和, 将爬取到的数据展示到前端页面上</h3><h4 id="爬虫的编写"><a href="#爬虫的编写" class="headerlink" title="爬虫的编写:"></a>爬虫的编写:</h4><pre class="highlight"><span class="line"># spider编写:</span><br><span class="line">import scrapy</span><br><span class="line">from dl.items import DlItem</span><br><span class="line">class PSpider(scrapy.Spider):</span><br><span class="line">    name &#x3D; &#39;p&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;https:&#x2F;&#x2F;www.kuaidaili.com&#x2F;free&#x2F;&#39;]</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        # print(response)</span><br><span class="line">        tr_list &#x3D; response.xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;list&quot;]&#x2F;table&#x2F;tbody&#x2F;tr&#39;)</span><br><span class="line">        # print(tr_list)</span><br><span class="line">        for tr in tr_list:</span><br><span class="line">            ip &#x3D; tr.xpath(&#39;.&#x2F;td[1]&#x2F;text()&#39;).extract_first()</span><br><span class="line">            port &#x3D; tr.xpath(&#39;.&#x2F;td[2]&#x2F;text()&#39;).extract_first()</span><br><span class="line">            typ &#x3D; tr.xpath(&#39;.&#x2F;td[3]&#x2F;text()&#39;).extract_first()</span><br><span class="line">            protocal &#x3D; tr.xpath(&#39;.&#x2F;td[4]&#x2F;text()&#39;).extract_first()</span><br><span class="line">            position &#x3D; tr.xpath(&#39;.&#x2F;td[5]&#x2F;text()&#39;).extract_first()</span><br><span class="line">            # print(ip, port, protocal, position)</span><br><span class="line">            item &#x3D; DlItem()</span><br><span class="line">            item[&#39;ip&#39;] &#x3D; ip</span><br><span class="line">            item[&#39;port&#39;] &#x3D; port</span><br><span class="line">            item[&#39;typ&#39;] &#x3D; typ</span><br><span class="line">            item[&#39;protocal&#39;] &#x3D; protocal</span><br><span class="line">            item[&#39;position&#39;] &#x3D; position</span><br><span class="line">            print(item)</span><br><span class="line">            yield item</span><br></pre><hr><h4 id="items编码"><a href="#items编码" class="headerlink" title="items编码"></a>items编码</h4><pre class="highlight"><span class="line"># items编码</span><br><span class="line">import scrapy</span><br><span class="line">class DlItem(scrapy.Item):</span><br><span class="line">    ip &#x3D; scrapy.Field()</span><br><span class="line">    port &#x3D; scrapy.Field()</span><br><span class="line">    typ &#x3D; scrapy.Field()</span><br><span class="line">    protocal &#x3D; scrapy.Field()</span><br><span class="line">    position &#x3D; scrapy.Field()</span><br></pre><hr><h4 id="Django项目创建与所有配置"><a href="#Django项目创建与所有配置" class="headerlink" title="Django项目创建与所有配置"></a>Django项目创建与所有配置</h4><pre class="highlight"><span class="line"># Django项目创建与所有配置:</span><br><span class="line">1.models创建:</span><br><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line"># Create your models here.</span><br><span class="line"></span><br><span class="line">class Proxy(models.Model):</span><br><span class="line">    ip &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    port &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    typ &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    protocal &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    position &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    </span><br><span class="line">2.在scrapy框架项目中嵌入django</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">sys.path.append(os.path.dirname(os.path.abspath(&#39;.&#39;)))</span><br><span class="line">os.environ[&#39;DJANGO_SETTINGS_MODULE&#39;] &#x3D; &#39;proxyscan.settings&#39;</span><br><span class="line"># 手动初始化Django：</span><br><span class="line">import django</span><br><span class="line">django.setup()</span><br><span class="line"></span><br><span class="line">3.修改爬虫item:</span><br><span class="line">import scrapy</span><br><span class="line">from scrapy_djangoitem import DjangoItem</span><br><span class="line">from proxy import models</span><br><span class="line">class DlItem(DjangoItem):</span><br><span class="line">    django_model &#x3D; models.Proxy</span><br><span class="line">    </span><br><span class="line">4.pipeline编码:</span><br><span class="line">class DlPipeline(object):</span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        print(&#39;开启数据库, 进行数据存储&#39;)</span><br><span class="line">        item.save()</span><br><span class="line">        print(&#39;关闭数据库&#39;)</span><br><span class="line">        return item</span><br><span class="line">    </span><br><span class="line">5.Django项目迁移数据库与admin后台配置</span><br><span class="line">Python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br><span class="line"></span><br><span class="line">from proxy.models import Proxy</span><br><span class="line">admin.site.register(Proxy)</span><br><span class="line"></span><br><span class="line"># 创建超级用户:</span><br><span class="line">Python manage.py createsuperuser</span><br></pre><hr><pre class="highlight"><span class="line"># 路由:</span><br><span class="line">from django.conf.urls import url</span><br><span class="line">from django.contrib import admin</span><br><span class="line">from proxy.views import index</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^admin&#x2F;&#39;, admin.site.urls),</span><br><span class="line">    url(r&#39;^index&#x2F;&#39;, index),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 视图函数:</span><br><span class="line">from django.shortcuts import render</span><br><span class="line">from proxy.models import Proxy</span><br><span class="line">def index(requests):</span><br><span class="line">    p &#x3D; Proxy.objects.all()</span><br><span class="line">    return render(requests, &#39;index.html&#39;, &#123;&quot;p&quot;:p&#125;)</span><br><span class="line"></span><br></pre><hr><h4 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h4><pre class="highlight"><span class="line"># 前端代码:</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.4.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;4.3.1&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;row&quot; &gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;col-md-10 col-md-offset-2&quot; style&#x3D;&quot;margin:0 auto&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;panel panel-primary&quot;&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;panel-heading&quot; style&#x3D;&quot;margin-top:50px&quot;&gt;</span><br><span class="line">                    &lt;h3 class&#x3D;&quot;panel-title&quot;&gt;代理IP一览表&lt;&#x2F;h3&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;panel-body&quot;&gt;</span><br><span class="line">                    &lt;table class&#x3D;&quot;table table-striped&quot;&gt;</span><br><span class="line">                        &lt;thead&gt;</span><br><span class="line">                        &lt;tr&gt;</span><br><span class="line">                            &lt;th&gt;IP&lt;&#x2F;th&gt;</span><br><span class="line">                            &lt;th&gt;Port&lt;&#x2F;th&gt;</span><br><span class="line">                            &lt;th&gt;Type&lt;&#x2F;th&gt;</span><br><span class="line">                            &lt;th&gt;Protocal&lt;&#x2F;th&gt;</span><br><span class="line">                            &lt;th&gt;Positon&lt;&#x2F;th&gt;</span><br><span class="line">                        &lt;&#x2F;tr&gt;</span><br><span class="line">                        &lt;&#x2F;thead&gt;</span><br><span class="line">                        &lt;tbody&gt;</span><br><span class="line">                        &#123;% for i in p %&#125;</span><br><span class="line">                            &lt;tr&gt;</span><br><span class="line">                                &lt;th&gt;&#123;&#123; i.ip &#125;&#125;&lt;&#x2F;th&gt;</span><br><span class="line">                                &lt;td&gt;&#123;&#123; i.port &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                                &lt;td&gt;&#123;&#123; i.typ &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                                &lt;td&gt;&#123;&#123; i.protocal &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                                &lt;td&gt;&#123;&#123; i.position &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                            &lt;&#x2F;tr&gt;</span><br><span class="line">                        &#123;% endfor %&#125;</span><br><span class="line">                        &lt;&#x2F;tbody&gt;</span><br><span class="line">                    &lt;&#x2F;table&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis雪崩&amp;穿透&amp;击穿</title>
      <link href="/2019/05/16/Redis%E9%9B%AA%E5%B4%A9&amp;%E7%A9%BF%E9%80%8F&amp;%E5%87%BB%E7%A9%BF/"/>
      <url>/2019/05/16/Redis%E9%9B%AA%E5%B4%A9&amp;%E7%A9%BF%E9%80%8F&amp;%E5%87%BB%E7%A9%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1. 缓存穿透"></a>1. 缓存穿透</h2><pre class="highlight"><span class="line">1）定义</span><br><span class="line">1. 缓存穿透是指查询一个一定不存在的数据，由于缓存不命中，接着查询数据库也无法查询出结果，</span><br><span class="line">2. 虽然也不会写入到缓存中，但是这将会导致每个查询都会去请求数据库，造成缓存穿透；</span><br><span class="line">2）解决方法 ：布隆过滤</span><br><span class="line">1. 对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；</span><br></pre><hr><h2 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2.缓存雪崩"></a>2.缓存雪崩</h2><pre class="highlight"><span class="line"></span><br><span class="line">1）定义　　　　　　</span><br><span class="line">1. 缓存雪崩是指，由于缓存层承载着大量请求，有效的保护了存储层，但是如果缓存层由于某些原因整体不能提供服务</span><br><span class="line">2. 于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</span><br><span class="line">2）解决方法</span><br><span class="line">1. 保证缓存层服务高可用性：比如 Redis Sentinel 和 Redis Cluster 都实现了高可用</span><br><span class="line">2. 依赖隔离组件为后端限流并降级：比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</span><br></pre><hr><h2 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3. 缓存击穿"></a>3. 缓存击穿</h2><pre class="highlight"><span class="line">1）定义：</span><br><span class="line">1. 缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况</span><br><span class="line">2. 当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</span><br><span class="line">2）解决方法</span><br><span class="line">1. 解决方式也很简单，可以将热点数据设置为永远不过期；</span><br><span class="line">2. 或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据</span><br></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据操作</title>
      <link href="/2019/05/01/Redis%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/05/01/Redis%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><ul><li>redis是key-value的数据结构，每条数据都是⼀个键值对</li><li>键的类型是字符串</li><li>注意：键不能重复</li></ul><p><strong>数据结构</strong><br><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTYxODQwMS8yMDE5MDkvMTYxODQwMS0yMDE5MDkwMTIwNTQxOTIyMy0xODA4MDM4ODM3LnBuZw?x-oss-process=image/format,png" class="lozad post-image"src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTYxODQwMS8yMDE5MDkvMTYxODQwMS0yMDE5MDkwMTIwNTQxOTIyMy0xODA4MDM4ODM3LnBuZw?x-oss-process=image/format,png"></p><p><strong>值的类型</strong>分为五种：</p><ul><li>字符串string</li><li>哈希hash</li><li>列表list</li><li>集合set</li><li>有序集合zset</li></ul><p><strong>数据操作行为</strong></p><ul><li>保存</li><li>修改</li><li>获取</li><li>删除<br>中⽂官⽹查看命令⽂档 <a href="http://redis.cn/commands.html">http://redis.cn/commands.html</a><h1 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h1></li></ul><p>字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。</p><p><strong>保存</strong><br>如果设置的键不存在则为添加，如果设置的键已经存在则修改</p><p><strong>设置键值</strong><br>set key value<br>例1：设置键为name值为itcast的数据</p><pre class="highlight"><span class="line">set name yifchan</span><br></pre><p><strong>设置键值及过期时间</strong>，以秒为单位</p><pre class="highlight"><span class="line">setex key seconds value</span><br></pre><p>例2：设置键为aa值为aa过期时间为3秒的数据</p><pre class="highlight"><span class="line">setex aa 3 aa</span><br></pre><p><strong>设置多个键值</strong></p><pre class="highlight"><span class="line">mset key1 value1 key2 value2 ...</span><br></pre><p>例3：设置键为’a1’值为’python’、键为’a2’值为’java’、键为’a3’值为’c’</p><pre class="highlight"><span class="line">mset a1 python a2 java a3 c</span><br></pre><p><strong>追加值</strong></p><pre class="highlight"><span class="line">append key value</span><br></pre><p>例4：向键为a1中追加值’ haha’</p><pre class="highlight"><span class="line">append &#39;a1&#39; &#39;haha&#39;</span><br></pre><p><strong>获取</strong><br>获取：<strong>根据键获取值</strong>，如果不存在此键则返回nil</p><pre class="highlight"><span class="line">get key</span><br></pre><p>例5：获取键’name’的值</p><pre class="highlight"><span class="line">get &#39;name&#39;</span><br></pre><p>根据多个键获取多个值</p><pre class="highlight"><span class="line">mget key1 key2 ...</span><br></pre><p>例6：获取键a1、a2、a3’的值</p><pre class="highlight"><span class="line">mget a1 a2 a3</span><br></pre><p><strong>删除</strong><br>详⻅下节键的操作，删除键时会将值删除</p><p><strong>键命令</strong><br>查找键，参数⽀持正则表达式</p><pre class="highlight"><span class="line">keys pattern</span><br></pre><p>例1：查看所有键</p><pre class="highlight"><span class="line">keys *</span><br></pre><p>例2：查看名称中包含a的键</p><pre class="highlight"><span class="line">keys &#39;a*&#39;</span><br></pre><p><strong>判断键是否存在</strong>，如果存在返回1，不存在返回0</p><pre class="highlight"><span class="line">exists key1</span><br></pre><p>例3：判断键a1是否存在</p><pre class="highlight"><span class="line">exists a1</span><br></pre><p><strong>查看键对应的value的类型</strong></p><pre class="highlight"><span class="line">type key</span><br></pre><p>例4：查看键a1的值类型，为redis⽀持的五种类型中的⼀种</p><pre class="highlight"><span class="line">type a1</span><br></pre><p><strong>删除键及对应的值</strong></p><pre class="highlight"><span class="line">del key1 key2 ...</span><br></pre><p>例5：删除键a2、a3</p><pre class="highlight"><span class="line">del a2 a3</span><br></pre><p><strong>设置过期时间</strong>，以秒为单位</p><p>如果没有指定过期时间则⼀直存在，直到使⽤DEL移除</p><pre class="highlight"><span class="line">expire key seconds</span><br></pre><p>例6：设置键’a1’的过期时间为3秒</p><pre class="highlight"><span class="line">expire &#39;a1&#39; 3</span><br></pre><p><strong>查看有效时间</strong>，以秒为单位</p><pre class="highlight"><span class="line">ttl key</span><br></pre><p>例7：查看键’bb’的有效时间</p><pre class="highlight"><span class="line">ttl bb</span><br></pre><h1 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h1><ul><li>hash⽤于存储对象，对象的结构为属性、值</li><li>值的类型为string</li><li><strong>增加、修改</strong></li></ul><p><strong>设置单个属性</strong></p><pre class="highlight"><span class="line">hset key field value</span><br></pre><p>例1：设置键 user的属性name为itheima</p><pre class="highlight"><span class="line">hset user name itheima</span><br></pre><p>可能报错</p><pre class="highlight"><span class="line">MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error.</span><br><span class="line"></span><br></pre><p>Redis被配置为保存数据库快照，但它目前不能持久化到硬盘。用来修改集合数据的命令不能用</p><p>原因：</p><p>强制关闭Redis快照导致不能持久化。 解决方案：</p><p>运行 config set stop-writes-on-bgsave-error no 命令后，关闭配置项stop-writes-on-bgsave-error解决该问题。<br><strong>设置多个属性</strong></p><p>hmset key field1 value1 field2 value2 …<br>例2：设置键u2的属性name为itcast、属性age为11</p><p>hmset u2 name itcast age 11</p><p><strong>获取<br>获取指定键所有的属性</strong></p><pre class="highlight"><span class="line">hkeys key</span><br></pre><p>例3：获取键u2的所有属性</p><pre class="highlight"><span class="line">hkeys u2</span><br></pre><p><strong>获取⼀个属性的值</strong></p><pre class="highlight"><span class="line">hget key field</span><br></pre><p>例4：获取键u2属性’name’的值</p><pre class="highlight"><span class="line">hget u2 &#39;name&#39;</span><br></pre><p><strong>获取多个属性的值</strong></p><pre class="highlight"><span class="line">hmget key field1 field2 ...</span><br></pre><p>例5：获取键u2属性’name’、’age的值</p><pre class="highlight"><span class="line">hmget u2 name age</span><br></pre><p>获取所有属性的值</p><pre class="highlight"><span class="line">hvals key</span><br></pre><p>例6：获取键’u2’所有属性的值</p><pre class="highlight"><span class="line">hvals u2</span><br></pre><p><strong>删除</strong><br>删除整个hash键及值，使⽤del命令<br>删除属性，属性对应的值会被⼀起删除</p><pre class="highlight"><span class="line">hdel key field1 field2 ...</span><br></pre><p>例7：删除键’u2’的属性’age’</p><pre class="highlight"><span class="line">hdel u2 age</span><br></pre><h1 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h1><ul><li>列表的元素类型为string</li><li>按照插⼊顺序排序</li></ul><p><strong>增加<br>在左侧插⼊数据</strong></p><pre class="highlight"><span class="line">lpush key value1 value2 ...</span><br></pre><p>例1：从键为’a1’的列表左侧加⼊数据a 、 b 、c</p><pre class="highlight"><span class="line">lpush a1 a b c</span><br></pre><p><strong>在右侧插⼊数据</strong></p><pre class="highlight"><span class="line">rpush key value1 value2 ...</span><br></pre><p>例2：从键为’a1’的列表右侧加⼊数据0 1</p><pre class="highlight"><span class="line">rpush a1 0 1</span><br></pre><p><strong>在指定元素的前或后插⼊新元素</strong></p><pre class="highlight"><span class="line">linsert key before或after 现有元素 新元素</span><br></pre><p>例3：在键为’a1’的列表中元素’b’前加⼊’3’</p><pre class="highlight"><span class="line">linsert a1 before b 3</span><br></pre><p><strong>获取<br>返回列表⾥指定范围内的元素</strong></p><ul><li>start、stop为元素的下标索引</li><li>索引从左侧开始，第⼀个元素为0</li><li>索引可以是负数，表示从尾部开始计数，如-1表示最后⼀个元素<br>lrange key start stop<br>例4：获取键为’a1’的列表所有元素<pre class="highlight"><span class="line">lrange a1 0 -1</span><br></pre></li></ul><p><strong>设置指定索引位置的元素值</strong><br>索引从左侧开始，第⼀个元素为0<br>索引可以是负数，表示尾部开始计数，如-1表示最后⼀个元素</p><pre class="highlight"><span class="line">lset key index value</span><br></pre><p>例5：修改键为’a1’的列表中下标为1的元素值为’z’</p><pre class="highlight"><span class="line">lset a 1 z</span><br></pre><p><strong>删除<br>删除指定元素</strong></p><p>将列表中前count次出现的值为value的元素移除</p><ul><li>count &gt; 0: 从头往尾移除</li><li>count &lt; 0: 从尾往头移除</li><li>count = 0: 移除所有<pre class="highlight"><span class="line">lrem key count value</span><br></pre></li></ul><p>例6.1：向列表’a2’中加⼊元素’a’、’b’、’a’、’b’、’a’、’b’</p><pre class="highlight"><span class="line">lpush a2 a b a b a b</span><br></pre><p>例6.2：从’a2’列表右侧开始删除2个’b’</p><pre class="highlight"><span class="line">lrem a2 -2 b</span><br></pre><p>例6.3：查看列表’py12’的所有元素</p><pre class="highlight"><span class="line">lrange a2 0 -1</span><br></pre><h1 id="set类型"><a href="#set类型" class="headerlink" title="set类型"></a>set类型</h1><ul><li>⽆序集合</li><li>元素为string类型</li><li>元素具有唯⼀性，不重复</li><li>说明：对于集合没有修改操作</li></ul><p><strong>增加<br>添加元素</strong></p><pre class="highlight"><span class="line">sadd key member1 member2 ...</span><br></pre><p>例1：向键’a3’的集合中添加元素’zhangsan’、’lisi’、’wangwu’</p><pre class="highlight"><span class="line">sadd a3 zhangsan sili wangwu</span><br></pre><p><strong>获取<br>返回所有的元素</strong></p><pre class="highlight"><span class="line">smembers key</span><br></pre><p>例2：获取键’a3’的集合中所有元素</p><pre class="highlight"><span class="line">smembers a3</span><br></pre><p><strong>删除<br>删除指定元素</strong></p><pre class="highlight"><span class="line">srem key</span><br></pre><p>例3：删除键’a3’的集合中元素’wangwu’</p><pre class="highlight"><span class="line">srem a3 wangwu</span><br></pre><h1 id="zset类型"><a href="#zset类型" class="headerlink" title="zset类型"></a>zset类型</h1><ul><li>sorted set，有序集合</li><li>元素为string类型</li><li>元素具有唯⼀性，不重复</li><li>每个元素都会关联⼀个double类型的score，表示权重，通过权重将元素从⼩到⼤排序</li><li>说明：没有修改操作</li></ul><p><strong>增加<br>添加</strong></p><pre class="highlight"><span class="line">zadd key score1 member1 score2 member2 ...</span><br></pre><p>例1：向键’a4’的集合中添加元素’lisi’、’wangwu’、’zhaoliu’、’zhangsan’，权重分别为4、5、6、3</p><pre class="highlight"><span class="line">zadd a4 4 lisi 5 wangwu 6 zhaoliu 3 zhangsan</span><br></pre><p><strong>获取<br>返回指定范围内的元素</strong></p><ul><li>start、stop为元素的下标索引</li><li>索引从左侧开始，第⼀个元素为0</li><li>索引可以是负数，表示从尾部开始计数，如-1表示最后⼀个元素<pre class="highlight"><span class="line">zrange key start stop</span><br></pre></li></ul><p>例2：获取键’a4’的集合中所有元素</p><pre class="highlight"><span class="line">zrange a4 0 -1</span><br></pre><p><strong>返回score值在min和max之间的成员</strong></p><pre class="highlight"><span class="line">zrangebyscore key min max</span><br></pre><p>例3：获取键’a4’的集合中权限值在5和6之间的成员</p><pre class="highlight"><span class="line">zrangebyscore a4 5 6</span><br></pre><p><strong>返回成员member的score值</strong></p><pre class="highlight"><span class="line">zscore key member</span><br></pre><p>例4：获取键’a4’的集合中元素’zhangsan’的权重</p><pre class="highlight"><span class="line">zscore a4 zhangsan</span><br></pre><p><strong>删除<br>删除指定元素</strong></p><pre class="highlight"><span class="line">zrem key member1 member2 ...</span><br></pre><p>例5：删除集合’a4’中元素’zhangsan’</p><pre class="highlight"><span class="line">zrem a4 zhangsan</span><br></pre><p><strong>删除权重在指定范围的元素</strong></p><pre class="highlight"><span class="line">zremrangebyscore key min max</span><br></pre><p>例6：删除集合’a4’中权限在5、6之间的元素</p><pre class="highlight"><span class="line">zremrangebyscore a4 5 6</span><br></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis使用教程</title>
      <link href="/2019/04/15/Redis%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2019/04/15/Redis%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Redis的安装过程"><a href="#1-Redis的安装过程" class="headerlink" title="1. Redis的安装过程"></a>1. Redis的安装过程</h1><p>（1） 下载Redis<br>这里就随便下，无论是安装包也好压缩包也好怎么都行</p><p>（2） 配置环境变量<br>配完了之后可以不需要进入Redis的那个目录，然后可以直接敲redis…..把这个服务启动起来。</p><p>（3） 把Redis变成一个服务<br>至少你在服务页面估计能看到他，然后定成自动启动，省的天天手动。</p><p>（4） 设置密码<br>在Redis这个文件夹里面编辑redis.windows-service.conf，类似的conf文件有两个，千万分清楚这个后面带service的。<br>使用这种方式设置是永久性设置。<br><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDc0Mzk3OS1lMGMwODVmMGRlNDdjZjEyLnBuZw?x-oss-process=image/format,png" class="lozad post-image"src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDc0Mzk3OS1lMGMwODVmMGRlNDdjZjEyLnBuZw?x-oss-process=image/format,png"><br>（5） 打开本地客户端<br>如果要查询里面的键值对是什么之类的，就用redis-cli。<br>设置了密码之后，上来输入的就是 auth 123456（根据自己的密码改）</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDc0Mzk3OS0wNDIwZjA0M2U2NWNiN2FjLnBuZw?x-oss-process=image/format,png" class="lozad post-image"src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDc0Mzk3OS0wNDIwZjA0M2U2NWNiN2FjLnBuZw?x-oss-process=image/format,png"></p><p>安装、打开、设置密码（就是配Redis环境）这些应该也可以用docker完成</p><h1 id="2-SpringBoot集成Redis"><a href="#2-SpringBoot集成Redis" class="headerlink" title="2. SpringBoot集成Redis"></a>2. SpringBoot集成Redis</h1><p>（1） 在pom里导入一个jar包<br>（2） yml配置</p><pre class="highlight"><span class="line">redis:</span><br><span class="line">   host: localhost # Redis服务器地址</span><br><span class="line">   database: 0 # Redis数据库索引（默认为0）</span><br><span class="line">   port: 6379 # Redis服务器连接端口</span><br><span class="line">   password:&quot;test&quot; # Redis服务器连接密码（默认为空，以及这里带引号！！！）</span><br><span class="line">   jedis:</span><br><span class="line">     pool:</span><br><span class="line">       max-active: 8 # 连接池最大连接数（使用负值表示没有限制），能制造出来的最大的连接数</span><br><span class="line">       max-wait: -1ms # 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">       max-idle: 8 # 连接池中的最大空闲连接，空闲太多可能销毁</span><br><span class="line">       min-idle: 0 # 连接池中的最小空闲连接，务必保持几个控线连接</span><br><span class="line">   timeout: 3000ms # 连接超时时间（毫秒）</span><br></pre><p>（3） 注入Template开始用<br>经过了上两个步骤之后，其实就已经配置好了，在代码里面注入Template就可以set、get然后启用了。</p><p>Teplate目前已知的有两种，一种是RedisTemplate，一种是<br>StringRedisTemplate（这种其实也就是RedisTemplate&lt;String,String&gt;），就是封装了一下写的高大上了。<br>所以自己用的时候只能用RedisTemplate，如果需要的话自己写泛型。</p><p>序列化器：<br>由于RedisTemplate里面注入的直接就是object，需要被缓存的类实现了Serielizable接口才行。</p><p>简单写一下Serielizable：<br>Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行状态时，这些对象才能存在，即，这些对象的生命周期不会比JVM更长。但在现实中，就可能要求在JVM运行停止后能够保存（持久化），以便下次运行时重新获取对象，Java对象序列化就能够帮助我们实现该功能。<br>网络上远程传递的时候也需要实现这个功能。</p><p>如果仅仅只是让某个类实现Serializable接口，而没有其他处理的话，则就是使用默认序列化机制。使用默认机制，在序列化对象时，不仅会序列化当前对象本身，还会对该对象引用的其他对象也进行序列化，同样的，这些其他对象引用的另外对象也将被序列化，以此类推。所以，如果一个对象的成员变量是容器类对象，而这些容器含有的元素也是容器类对象，那么这个序列化对象的过程就会很复杂，开销也很大。<br>transient关键字可以忽略掉某些字段。</p><h1 id="3-Redis连接池"><a href="#3-Redis连接池" class="headerlink" title="3. Redis连接池"></a>3. Redis连接池</h1><p>（1） 为什么要用连接池：<br>连接池定义：连接池是创建和管理一个连接的缓冲池的技术，这些连接准备好被任何需要它们的线程。</p><p>连接池管理的就是连接，每次存取数据的时候，都要new一个连接对象出来，建立一个TCP连接要经历三次握手什么的，这样挺浪费时间的，所以每次用完连接对象之后不释放，存到连接池里面去，下次用连接对象的时候去连接池里面获取。</p><p>（2） 手写Redis连接池：<br>Redis连接池这东西一共就三个函数，一个init，一个getResource，一个release。<br>其中尤其以getResources为核心。</p><p>首先如果要完成连接池保存，要有存储容器，set、list、queue、array、map这些是要选择一下的。<br>频繁的存取，不能用array，不能用array的也不能用list，map不需要key，queue和set两个平分，最终用queue。<br>那就要有两个queue来放置空闲的和被使用的连接。</p><p>getResource的调用流程：（中间把config都用上了）<br>如果有空闲连接直接返回<br>没有空闲的但是目前总数还没超过max，可以再new一个<br>总数已经到max了，没法new了就只能等<br>如果超过了等待时间，返回报错</p><p>release调用流程：<br>把这个连接从使用中队列移动到空闲队列</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础数据类型的操作</title>
      <link href="/2019/03/28/python%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/03/28/python%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="列表和元组"><a href="#列表和元组" class="headerlink" title="列表和元组"></a>列表和元组</h1><h2 id="1-列表基本操作"><a href="#1-列表基本操作" class="headerlink" title="1.列表基本操作"></a>1.列表基本操作</h2><h3 id="1-1-列表赋值"><a href="#1-1-列表赋值" class="headerlink" title="1.1  列表赋值　"></a>1.1  列表赋值　</h3><pre class="highlight"><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">100</span>        <span class="comment">#the result ： [100, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre><h3 id="1-2-元素删除"><a href="#1-2-元素删除" class="headerlink" title="1.2 元素删除"></a>1.2 元素删除</h3><pre class="highlight"><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="keyword">del</span> a[<span class="number">0</span>]　　                <span class="comment">#the result ： [2, 3, 4, 5, 6, 7, 8]</span></span><br></pre><h3 id="1-3-分片赋值"><a href="#1-3-分片赋值" class="headerlink" title="1.3 分片赋值"></a>1.3 分片赋值</h3><pre class="highlight"><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">a[::<span class="number">2</span>]                  <span class="comment"># [1, 3, 5, 7]</span></span><br><span class="line">a[<span class="number">-2</span>:]                  <span class="comment"># [7, 8]</span></span><br><span class="line">a[<span class="number">1</span>:<span class="number">1</span>] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]             <span class="comment"># the result : [1, 0, 0, 0, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre><h3 id="1-4-使用-for-i-in-range-10-1-1-生成列表"><a href="#1-4-使用-for-i-in-range-10-1-1-生成列表" class="headerlink" title="1.4 使用 for i in range(10,-1,-1) 生成列表"></a>1.4 使用 for i in range(10,-1,-1) 生成列表</h3><pre class="highlight"><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>,<span class="number">-1</span>,<span class="number">-1</span>): </span><br><span class="line"><span class="comment"># 开始位置（10），结束位置（-1）， 步长（-1）</span></span><br><span class="line"><span class="keyword">print</span> i,</span><br><span class="line"><span class="comment"># 打印结果：10 9 8 7 6 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment"># 从10开始，每次向后取一个值，直到遇到结束位置 -1</span></span><br></pre><h2 id="2-列表方法"><a href="#2-列表方法" class="headerlink" title="2.列表方法"></a>2.列表方法</h2><h3 id="2-1-append"><a href="#2-1-append" class="headerlink" title="2.1 append"></a>2.1 append</h3><p>作用：append用于在列表末尾追加新的对象</p><pre class="highlight"><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.append(<span class="number">4</span>)          　　　　　　　<span class="comment">#the result ： [1, 2, 3, 4]</span></span><br></pre><h3 id="2-2-count"><a href="#2-2-count" class="headerlink" title="2.2  count"></a>2.2  count</h3><p>作用：count方法统计某个元素在列表中出现的次数</p><pre class="highlight"><span class="line">a =[<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;bb&#x27;</span>,<span class="string">&#x27;cc&#x27;</span>,<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;aa&#x27;</span>]print(a.count(<span class="string">&#x27;aa&#x27;</span>))                  <span class="comment">#the result ： 3</span></span><br></pre><h3 id="2-3-extend"><a href="#2-3-extend" class="headerlink" title="2.3   extend"></a>2.3   extend</h3><p>作用：extend方法可以在列表的末尾一次性追加另一个序列中的多个值</p><pre class="highlight"><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">a.extend(b)       <span class="comment">#the result ：[1, 2, 3, 4, 5, 6]</span></span><br></pre><h3 id="2-4-index"><a href="#2-4-index" class="headerlink" title="2.4  index"></a>2.4  index</h3><p>作用：index函数用于从列表中找出某个值第一个匹配项的索引位置</p><pre class="highlight"><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]``print(a.index(<span class="number">1</span>))                  <span class="comment">#the result ： 0`</span></span><br></pre><h3 id="2-5-insert"><a href="#2-5-insert" class="headerlink" title="2.5  insert"></a>2.5  insert</h3><p>作用： insert方法用于将对象插入到列表中</p><pre class="highlight"><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]``a.insert(<span class="number">0</span>,``<span class="string">&#x27;aa&#x27;</span>``)      <span class="comment">#the result : [``&#x27;aa&#x27;``, 1, 2, 3]`</span></span><br></pre><h3 id="2-6-pop"><a href="#2-6-pop" class="headerlink" title="2.6  pop"></a>2.6  pop</h3><p>作用：pop方法会移除列表中的一个元素（默认是最后一个），并且返回该元素的值</p><pre class="highlight"><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]``a.pop()                         <span class="comment">#the result ： [1, 2]``a.pop(0)`</span></span><br></pre><h3 id="2-7-remove"><a href="#2-7-remove" class="headerlink" title="2.7   remove"></a>2.7   remove</h3><p>作用：remove方法用于移除列表中某个值的第一个匹配项</p><pre class="highlight"><span class="line">a = [<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;bb&#x27;</span>,<span class="string">&#x27;cc&#x27;</span>,<span class="string">&#x27;aa&#x27;</span>]</span><br><span class="line">a.remove(<span class="string">&#x27;aa&#x27;</span>)            <span class="comment">#the result ： [&#x27;bb&#x27;, &#x27;cc&#x27;, &#x27;aa&#x27;]</span></span><br></pre><h3 id="2-8-reverse"><a href="#2-8-reverse" class="headerlink" title="2.8  reverse"></a>2.8  reverse</h3><p>作用：reverse方法将列表中的元素反向存放</p><pre class="highlight"><span class="line">a = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]a.reverse()         <span class="comment">#the result ： [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]</span></span><br></pre><h3 id="2-9-sort"><a href="#2-9-sort" class="headerlink" title="2.9  sort"></a>2.9  sort</h3><p>　　作用：sort方法用于在原位置对列表进行排序，意味着改变原来的列表，让其中的元素按一定顺序排列</p><pre class="highlight"><span class="line">a = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.sort()            <span class="comment">#the result ：[1, 2, 3, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre><h3 id="2-10-enumrate"><a href="#2-10-enumrate" class="headerlink" title="2.10  enumrate"></a>2.10  enumrate</h3><pre class="highlight"><span class="line">li = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>]</span><br><span class="line"><span class="keyword">for</span>  k,v  <span class="keyword">in</span> enumerate(li, <span class="number">1</span>):</span><br><span class="line">print(k,v)</span><br></pre><h3 id="2-11-range和xrange-指定范围，生成指定的数字"><a href="#2-11-range和xrange-指定范围，生成指定的数字" class="headerlink" title="2.11 range和xrange 指定范围，生成指定的数字"></a>2.11 range和xrange 指定范围，生成指定的数字</h3><p>注：python3中的range类似python2中的xrange，比如a = range(1,4) : a返回的不是列表对象而是一个可迭代对象（&lt;class ‘range’&gt;）</p><pre class="highlight"><span class="line"><span class="comment">#1、range根据start与stop指定的范围以及step设定的步长，生成一个序列：range([start,] stop[, step])``#2、xrange 用法与 range 完全相同，所不同的是生成的不是一个list对象，而是一个生成器for i in range(1,10,2):</span></span><br><span class="line">print(i)`</span><br></pre><h3 id="2-12-列表去空"><a href="#2-12-列表去空" class="headerlink" title="2.12  列表去空"></a>2.12  列表去空</h3><pre class="highlight"><span class="line"><span class="comment">#方法1：</span></span><br><span class="line">filter(<span class="literal">None</span>, your_list)</span><br><span class="line"><span class="comment">#方法2：</span></span><br><span class="line"><span class="keyword">while</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">in</span> your_list:</span><br><span class="line">your_list.remove(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#方法3：</span></span><br><span class="line">your_list = [x  <span class="keyword">for</span> x  <span class="keyword">in</span> your_list  <span class="keyword">if</span> x != <span class="string">&#x27;&#x27;</span>]</span><br></pre><h2 id="3-元组定义：元组和列表一样，也是一种序列，唯一的不同是元组不能修改。"><a href="#3-元组定义：元组和列表一样，也是一种序列，唯一的不同是元组不能修改。" class="headerlink" title="3.元组定义：元组和列表一样，也是一种序列，唯一的不同是元组不能修改。"></a>3.元组定义：元组和列表一样，也是一种序列，唯一的不同是元组不能修改。</h2><h3 id="3-1-创建元组举例"><a href="#3-1-创建元组举例" class="headerlink" title="3.1  创建元组举例"></a>3.1  创建元组举例</h3><pre class="highlight"><span class="line"><span class="comment">#1. 创建元组</span></span><br><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="comment">#2. 将列表转换成元组</span></span><br><span class="line">tuple([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])                  <span class="comment">#the result ： (1, 2, 3, 4)</span></span><br></pre><h2 id="4-列表和元组常用函数"><a href="#4-列表和元组常用函数" class="headerlink" title="4.列表和元组常用函数"></a>4.列表和元组常用函数</h2><p>com(x,y) 比较两个值<br>len(seq) 返回序列的长度<br>list(seq) 把序列转换成列表<br>max(args) 返回序列或者参数集合中得最大值<br>min(args) 返回序列或者参数集合中的最小值<br>reversed(seq) 对序列进行反向迭代<br>sorted(seq) 返回已经排列的包含seq 所有元素的列表<br>tuple(seq) 把序列转换成元组</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="1-字符串格式化"><a href="#1-字符串格式化" class="headerlink" title="1.字符串格式化"></a>1.字符串格式化</h2><h3 id="1-1-使用百分号（-）字符串格式化"><a href="#1-1-使用百分号（-）字符串格式化" class="headerlink" title="1.1 使用百分号（%）字符串格式化"></a>1.1 使用百分号（%）字符串格式化</h3><pre class="highlight"><span class="line">num = <span class="number">100</span></span><br><span class="line">print(<span class="string">&quot;%d to hex is %x&quot;</span>%(num, num))    <span class="comment">#100 to hex is 64 </span></span><br><span class="line">print(<span class="string">&quot;%d to hex is %#x&quot;</span>%(num, num))    <span class="comment">#100 to hex is 0x64</span></span><br></pre><h3 id="1-2-使用format字符串格式化"><a href="#1-2-使用format字符串格式化" class="headerlink" title="1.2  使用format字符串格式化"></a>1.2  使用format字符串格式化</h3><pre class="highlight"><span class="line"><span class="comment">#1. 位置参数</span></span><br><span class="line">print(<span class="string">&quot;&#123;0&#125; is &#123;1&#125; years old&quot;</span></span><br><span class="line">.format(<span class="string">&quot;tom&quot;</span>, <span class="number">28</span>))     </span><br><span class="line"> <span class="comment">#tom ``is` `28 years old``print(``&quot;&#123;&#125; is &#123;&#125; years old&quot;``.format(``&quot;tom&quot;``, 28))       #tom ``is` `28 years old``print(``&quot;Hi, &#123;0&#125;! &#123;0&#125; is &#123;1&#125; years old&quot;``.format(``&quot;tom&quot;``, 28)) #Hi, tom! tom ``is` `28 years old` `#2. 关键字参数``print(``&quot;&#123;name&#125; is &#123;age&#125; years old&quot;``.format(name = ``&quot;tom&quot;``, age = 28))  #tom ``is` `28 years old` `#3. 下标参数``li = [``&quot;tom&quot;``, 28]``print(``&quot;&#123;0[0]&#125; is &#123;0[1]&#125; years old&quot;``.format(li))     #tom ``is` `28 years old`</span></span><br></pre><h2 id="2-字符串方法"><a href="#2-字符串方法" class="headerlink" title="2.字符串方法"></a>2.字符串方法</h2><h3 id="2-1-find方法"><a href="#2-1-find方法" class="headerlink" title="2.1  find方法"></a>2.1  find方法</h3><p>作用：find方法可以在一个较长的字符串中查找子串，他返回子串所在位置的最左端索引，如果没有找到则返回-1</p><pre class="highlight"><span class="line">a=<span class="string">&#x27;abcdefghijk&#x27;</span></span><br><span class="line">print(a.find(<span class="string">&#x27;abc&#x27;</span>))             </span><br><span class="line"><span class="comment">#the result ： 0</span></span><br><span class="line">print(a.find(<span class="string">&#x27;abc&#x27;</span>,<span class="number">10</span>,<span class="number">100</span>))          <span class="comment">#the result ： 11 指定查找的起始和结束查找位置</span></span><br></pre><h3 id="2-2-join方法"><a href="#2-2-join方法" class="headerlink" title="2.2  join方法"></a>2.2  join方法</h3><p>作用：join方法是非常重要的字符串方法，他是split方法的逆方法，用来连接序列中的元素，并且需要被连接的元素都必须是字符串。</p><pre class="highlight"><span class="line">a = [``<span class="string">&#x27;1&#x27;</span>``,``<span class="string">&#x27;2&#x27;</span>``,``<span class="string">&#x27;3&#x27;</span>``]``print(``<span class="string">&#x27;+&#x27;</span>``.``join``(a))                  <span class="comment">#the result ： 1+2+3</span></span><br></pre><h3 id="2-3-split方法"><a href="#2-3-split方法" class="headerlink" title="2.3  split方法"></a>2.3  split方法</h3><p>作用：这是一个非常重要的字符串，它是join的逆方法，用来将字符串分割成序列</p><pre class="highlight"><span class="line">print(&#96;&#96;&#39;1+2+3+4&#39;&#96;&#96;.split(&#96;&#96;&#39;+&#39;&#96;&#96;))              #the result ： [&#96;&#96;&#39;1&#39;&#96;&#96;, &#96;&#96;&#39;2&#39;&#96;&#96;, &#96;&#96;&#39;3&#39;&#96;&#96;, &#96;&#96;&#39;4&#39;&#96;&#96;]</span><br></pre><h3 id="2-4-strip"><a href="#2-4-strip" class="headerlink" title="2.4  strip"></a>2.4  strip</h3><p>作用：strip 方法返回去除首位空格（不包括内部）的字符串</p><pre class="highlight"><span class="line">print(``<span class="string">&quot;  test  test  &quot;</span>``.strip())        </span><br><span class="line"><span class="comment">#the result ：“test  test”</span></span><br></pre><h3 id="2-5-replace"><a href="#2-5-replace" class="headerlink" title="2.5 replace"></a>2.5 replace</h3><p>作用：replace方法返回某字符串所有匹配项均被替换之后得到字符串</p><pre class="highlight"><span class="line">print(``<span class="string">&quot;This is a test&quot;</span>``.replace(``<span class="string">&#x27;is&#x27;</span>``,``<span class="string">&#x27;is_test&#x27;</span>``))   </span><br><span class="line"><span class="comment">#the result ： This_test is_test a test</span></span><br></pre><h3 id="2-6-首字母大写"><a href="#2-6-首字母大写" class="headerlink" title="2.6 首字母大写"></a>2.6 首字母大写</h3><pre class="highlight"><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = ``<span class="string">&#x27;aBdkndfkFFD&#x27;</span>``&gt;&gt;&gt; s.capitalize()``<span class="string">&#x27;Abdkndfkffd&#x27;</span>`</span><br></pre><h3 id="2-7-Pinyin-模块，将汉字转换成拼音"><a href="#2-7-Pinyin-模块，将汉字转换成拼音" class="headerlink" title="2.7 Pinyin 模块，将汉字转换成拼音"></a>2.7 Pinyin 模块，将汉字转换成拼音</h3><pre class="highlight"><span class="line"><span class="keyword">from</span> xpinyin <span class="keyword">import</span> Pinyin </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">p = Pinyin()  </span><br><span class="line">fullname =raw_input(<span class="string">&#x27;name：&#x27;</span>).strip()  fullname = fullname.decode(<span class="string">&#x27;utf8&#x27;</span>)  </span><br><span class="line">print(fullname)  </span><br><span class="line">xin = fullname[<span class="number">0</span>]  </span><br><span class="line">ming = fullname[<span class="number">1</span>:]  </span><br><span class="line">name = ming + ``<span class="string">&#x27;.&#x27;</span>` `+ xin</span><br><span class="line">username = p.get_pinyin(name, <span class="string">&#x27;&#x27;</span>)  </span><br><span class="line"><span class="keyword">print</span> username</span><br><span class="line"><span class="keyword">print</span> username + <span class="string">&#x27;@yiducloud.cn</span></span><br></pre><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="1-字典基本使用"><a href="#1-字典基本使用" class="headerlink" title="1.字典基本使用"></a>1.字典基本使用</h2><h3 id="1-1-键类型：字典的键不一定为整形数据，键可以是任意的不可变类型，比如浮点型（实行），字符串或者元组。-1-2-自动添加：即使键起初在字典中不存在，也可以为他赋值，这样字典就会建立新的项。而（在不适用append方法或者其他类似操作的情况下）不能将值关联到列表之外的索引上。"><a href="#1-1-键类型：字典的键不一定为整形数据，键可以是任意的不可变类型，比如浮点型（实行），字符串或者元组。-1-2-自动添加：即使键起初在字典中不存在，也可以为他赋值，这样字典就会建立新的项。而（在不适用append方法或者其他类似操作的情况下）不能将值关联到列表之外的索引上。" class="headerlink" title="1.1 键类型：字典的键不一定为整形数据，键可以是任意的不可变类型，比如浮点型（实行），字符串或者元组。 ### 1.2 自动添加：即使键起初在字典中不存在，也可以为他赋值，这样字典就会建立新的项。而（在不适用append方法或者其他类似操作的情况下）不能将值关联到列表之外的索引上。"></a>1.1 键类型：字典的键不一定为整形数据，键可以是任意的不可变类型，比如浮点型（实行），字符串或者元组。 ### 1.2 自动添加：即使键起初在字典中不存在，也可以为他赋值，这样字典就会建立新的项。而（在不适用append方法或者其他类似操作的情况下）不能将值关联到列表之外的索引上。</h3><pre class="highlight"><span class="line">phonebook = &#123;``<span class="string">&#x27;Tom&#x27;</span>``:<span class="number">8777</span>,``<span class="string">&#x27;Jack&#x27;</span>``:<span class="number">9999</span>,``<span class="string">&#x27;Fly&#x27;</span>``:<span class="number">6666</span>&#125;</span><br><span class="line">print(``<span class="string">&quot;Tom&#x27;s Phonenumber is %(Tom)s&quot;</span>` `% phonebook)    </span><br><span class="line"><span class="comment">#Tom&#x27;s Phonenumber ``is` `8777`</span></span><br></pre><h2 id="2-字典常用方法"><a href="#2-字典常用方法" class="headerlink" title="2.字典常用方法"></a>2.字典常用方法</h2><h3 id="2-1-clear"><a href="#2-1-clear" class="headerlink" title="2.1 clear"></a>2.1 clear</h3><p>作用：clear方法清除字典中所有的项，这是一个原地操作，所以无返回值（或则说返回None）</p><pre class="highlight"><span class="line">d = &#123;&#125;``d[``<span class="string">&#x27;Tom&#x27;</span>``]=<span class="number">8777</span>``d[``<span class="string">&#x27;Jack&#x27;</span>``]=<span class="number">9999</span>``</span><br><span class="line">print(d)                </span><br><span class="line"><span class="comment">#the result : &#123;``&#x27;Jack&#x27;``: 9999, ``&#x27;</span></span><br><span class="line">Tom<span class="string">&#x27;``: 8777&#125;``</span></span><br><span class="line"><span class="string">d.clear()``print(d)                </span></span><br><span class="line"><span class="string">#the result : &#123;&#125;`</span></span><br></pre><h3 id="2-2-copy"><a href="#2-2-copy" class="headerlink" title="2.2 copy"></a>2.2 copy</h3><p>作用：copy方法返回一个具有相同 ”键-值” 对的新字典，而不是副本</p><pre class="highlight"><span class="line">d = &#123;<span class="string">&#x27;Tom&#x27;</span>:<span class="number">8777</span>,<span class="string">&#x27;Fly&#x27;</span>:<span class="number">6666</span>&#125;</span><br><span class="line">a = d.copy()</span><br><span class="line">a[<span class="string">&#x27;Tom&#x27;</span>] = <span class="string">&#x27;改变后的值&#x27;</span></span><br><span class="line">print(d)           </span><br><span class="line"><span class="comment">#&#123;``&#x27;Fly&#x27;``: 6666, ``&#x27;Tom&#x27;``: 8777&#125;</span></span><br><span class="line">print(a)           </span><br><span class="line"><span class="comment">#&#123;``&#x27;Fly&#x27;``: 6666, ``&#x27;Tom&#x27;: &#x27;改变后的值&#x27;&#125;</span></span><br></pre><h3 id="2-3-fromkeys"><a href="#2-3-fromkeys" class="headerlink" title="2.3 fromkeys"></a>2.3 fromkeys</h3><p>作用：fromkeys方法使用给定的键建立新的字典，每个键都对应一个默认的值None。</p><p>　　首先建造一个空字典，然后调用它的fromkeys方法，建立另一个字典</p><pre class="highlight"><span class="line">print(&#123;&#125;.fromkeys([<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>]))    </span><br><span class="line"> <span class="comment">#the result　：　&#123;``&#x27;age&#x27;``: None, ``&#x27;name&#x27;``: None&#125;`</span></span><br><span class="line"><span class="comment">### 2.4  get</span></span><br><span class="line">作用：get方法是个更宽松的访问字典项的方法，如果试图访问字典中不存在的项时不会报错仅会 返回：<span class="literal">None</span></span><br><span class="line">```python</span><br><span class="line">d = &#123;``<span class="string">&#x27;Tom&#x27;</span>``:<span class="number">8777</span>,``<span class="string">&#x27;Jack&#x27;</span>``:<span class="number">8888</span>,``<span class="string">&#x27;Fly&#x27;</span>``:<span class="number">6666</span>&#125;</span><br><span class="line">print(d.``get``(``<span class="string">&#x27;Tom&#x27;</span>``))               </span><br><span class="line"> <span class="comment">#the result ：  8777``</span></span><br><span class="line"> print(d.``get``(``<span class="string">&#x27;not_exist&#x27;</span>``))             </span><br><span class="line"> <span class="comment">#the result ：   None`</span></span><br></pre><h3 id="2-5-for循环字典的三种方法"><a href="#2-5-for循环字典的三种方法" class="headerlink" title="2.5. for循环字典的三种方法"></a>2.5. for循环字典的三种方法</h3><pre class="highlight"><span class="line">d = &#123;`Tom<span class="string">&#x27;:8777,&#x27;</span>Jack<span class="string">&#x27;:8888,&#x27;</span>Fly<span class="string">&#x27;:6666&#125;</span></span><br><span class="line"><span class="string">for` k,v  in d.items():</span></span><br><span class="line"><span class="string">print(k,v)</span></span><br><span class="line"><span class="string">for` k  in d.values():  </span></span><br><span class="line"><span class="string">print(k) </span></span><br><span class="line"><span class="string">for` k  in d.keys():  </span></span><br><span class="line"><span class="string">print(k)</span></span><br></pre><h3 id="2-6-pop-1"><a href="#2-6-pop-1" class="headerlink" title="2.6  pop"></a>2.6  pop</h3><p>作用：pop方法用于获得对应与给定键的值，然后将这个”键-值”对从字典中移除</p><pre class="highlight"><span class="line">d = &#123;<span class="string">&#x27;Tom&#x27;</span>:<span class="number">8777</span>,<span class="string">&#x27;Jack&#x27;</span>:<span class="number">8888</span>,<span class="string">&#x27;Fly&#x27;</span>:<span class="number">6666</span>&#125;</span><br><span class="line">v = d.pop(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line">print(v)          </span><br><span class="line"><span class="comment">#8777</span></span><br></pre><h3 id="2-7-popitem"><a href="#2-7-popitem" class="headerlink" title="2.7  popitem"></a>2.7  popitem</h3><p>① popitem方法类似于list.pop，list.pop会弹出列表的最后一个元素，但是popitem仅仅会弹出随机的项，因为字典没有”最后的元素”或则其他有关顺序的概念 　　<br>② 所以想一个接一个的移除并处理字典中的项，popitem是非常有效的（因为不用获取键的列表） 　　<br>③ 尽管popitem和列表的pop方法很类似，但是字典中没有与append等价的方法，因为字典是无序的，类似于append得方法是没有任何意义的</p><pre class="highlight"><span class="line">d = &#123;<span class="string">&#x27;Tom&#x27;</span>:<span class="number">8777</span>,<span class="string">&#x27;Jack&#x27;</span>:<span class="number">8888</span>,<span class="string">&#x27;Fly&#x27;</span>:<span class="number">6666</span>&#125;</span><br><span class="line">d.popitem()</span><br></pre><h3 id="2-8-setdefault"><a href="#2-8-setdefault" class="headerlink" title="2.8  setdefault"></a>2.8  setdefault</h3><p>作用：setdefault方法在某种程度上类似于get方法，能够获得与给定键相关联的值，除此之外，setdefault还能在字典中不含有给定键的情况下设定相应的键值</p><pre class="highlight"><span class="line">d = &#123;<span class="string">&#x27;Tom&#x27;</span>:<span class="number">8777</span>,<span class="string">&#x27;Jack&#x27;</span>:<span class="number">8888</span>,<span class="string">&#x27;Fly&#x27;</span>:<span class="number">6666</span>&#125;</span><br><span class="line">d.setdefault(``<span class="string">&#x27;Tom&#x27;</span>``)              </span><br><span class="line"><span class="comment">#the result ： 8777</span></span><br><span class="line">print(d.setdefault(<span class="string">&#x27;Test&#x27;</span>))          </span><br><span class="line"><span class="comment">#the result ： None</span></span><br><span class="line">print(d)                  </span><br><span class="line"><span class="comment">#&#123;&#x27;Fly&#x27;: 6666, &#x27;Jack&#x27;: 8888, &#x27;Tom&#x27;: 8777, &#x27;Test&#x27;: None&#125;</span></span><br></pre><h3 id="2-9-update"><a href="#2-9-update" class="headerlink" title="2.9  update"></a>2.9  update</h3><p>作用：update方法可以利用一个字典项更新另一个字典，提供的字典中的项会被添加到旧的字典中，如有相同的键则会被覆盖</p><pre class="highlight"><span class="line">d = &#123;<span class="string">&#x27;Tom&#x27;</span>:<span class="number">8777</span>,<span class="string">&#x27;Jack&#x27;</span>:<span class="number">8888</span>,<span class="string">&#x27;Fly&#x27;</span>:<span class="number">6666</span>&#125;``</span><br><span class="line">a = &#123;<span class="string">&#x27;Tom&#x27;</span>:<span class="number">110</span>,<span class="string">&#x27;Test&#x27;</span>:<span class="number">119</span>&#125;</span><br><span class="line">d.update(a)</span><br><span class="line">prin t(d)            </span><br><span class="line"><span class="comment">#the result ：&#123;&#x27;Fly&#x27;: 6666, &#x27;Test&#x27;: 119, &#x27;Jack&#x27;: 8888, &#x27;Tom&#x27;: 110&#125;</span></span><br></pre><h3 id="2-10-将两个列表组合成字典"><a href="#2-10-将两个列表组合成字典" class="headerlink" title="2.10 将两个列表组合成字典"></a>2.10 将两个列表组合成字典</h3><pre class="highlight"><span class="line">keys = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment">#1、zip生成字典print(dict(zip(keys,values)))                   # &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br><span class="line"><span class="comment">#2、for循环推倒字典</span></span><br><span class="line">print(&#123;keys[i]: values[i] </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(keys))&#125;)       </span><br><span class="line"><span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br></pre><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="1-集合作用"><a href="#1-集合作用" class="headerlink" title="1.集合作用　"></a>1.集合作用　</h2><p>1.1  去重 　　<br>1.2 取两个列表的交集 　<br>1.3 取两个列表的并集</p><pre class="highlight"><span class="line">list_1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#1、去重(去除list_1中重复元素1,2)</span></span><br><span class="line">list_1 = set(list_1)                  </span><br><span class="line"></span><br><span class="line"><span class="comment">#去重： &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line">print(list_1)</span><br><span class="line">list_2 = set([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、交集（在list_1和list_2中都有的元素4,5）</span></span><br><span class="line">print(list_1.intersection(list_2))           </span><br><span class="line"></span><br><span class="line"><span class="comment">#交集： &#123;4, 5&#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3、并集（在list_1和list_2中的元素全部打印出来，重复元素仅打印一次）</span></span><br><span class="line">print(list_1.union(list_2))               </span><br><span class="line"></span><br><span class="line"><span class="comment">#并集： &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4、差集</span></span><br><span class="line">print(list_1.difference(list_2))            </span><br><span class="line"><span class="comment">#差集：在list_1中有在list_2中没有：  &#123;1, 2, 3&#125;</span></span><br><span class="line">print(list_2.difference(list_1))            </span><br><span class="line"></span><br><span class="line"><span class="comment">#差集：在list_1中有在list_2中没有：  &#123;8, 6, 7&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5、子集</span></span><br><span class="line">print(list_1.issubset(list_2))             </span><br><span class="line"></span><br><span class="line"><span class="comment">#子集：  False  List_1中的元素是否全部在list2中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#6、父集</span></span><br><span class="line">print(list_1.issuperset(list_2))            </span><br><span class="line"></span><br><span class="line"><span class="comment">#父集：  False  List_1中是否包含list_2中的所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#7、交集</span></span><br><span class="line">print(list_1 &amp; list_2)                 </span><br><span class="line"></span><br><span class="line"><span class="comment">#交集  &#123;4, 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#8、union并集</span></span><br><span class="line">print(list_1 | list_2)                 </span><br><span class="line"></span><br><span class="line"><span class="comment">#并集： &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#9、difference差集</span></span><br><span class="line">print(list_1 - list_2)                 <span class="comment">#差集：  &#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#10、在集合中添加一个元素999</span></span><br><span class="line">list_1.add(<span class="number">999</span>)</span><br><span class="line">print(list_1)                      </span><br><span class="line"></span><br><span class="line"><span class="comment">#Add()方法：     </span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">999</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#11、删除集合中任意一个元素不会打印删除的值</span></span><br><span class="line">list_1.pop()                      </span><br><span class="line"></span><br><span class="line"><span class="comment">#Pop()方法：      </span></span><br><span class="line">无返回值</span><br><span class="line"></span><br><span class="line"><span class="comment">#12、discard删除集合中的指定元素，如过没有则返回None</span></span><br><span class="line">print(list_1.discard(<span class="string">&quot;ddd&quot;</span>))       </span><br><span class="line"></span><br><span class="line"><span class="comment">#Discard()方法：  删除指定的值，没有返回None</span></span><br></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常见基础算法题</title>
      <link href="/2019/03/01/Python%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2019/03/01/Python%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数"><a href="#1-判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数" class="headerlink" title="1.判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数."></a>1.判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数.</h3><p>示例 1:<br>输入: 121<br>输出: true</p><p>示例 2:<br>输入: -121<br>输出: false<br>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p><p>示例 3:<br>输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_num</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    判断传递的参数是否是回文数</span></span><br><span class="line"><span class="string">    :param num: 传递的参数</span></span><br><span class="line"><span class="string">    :return: 是回文数返回True 不是则false</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    num1 = str(num)</span><br><span class="line">    <span class="keyword">if</span> num1[::<span class="number">-1</span>] == num1:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(is_num(<span class="number">121</span>))</span><br></pre><h3 id="2-分别用生成器和迭代器生成斐波那契"><a href="#2-分别用生成器和迭代器生成斐波那契" class="headerlink" title="2.分别用生成器和迭代器生成斐波那契"></a>2.分别用生成器和迭代器生成斐波那契</h3><p>示例 1:</p><p>输出: 1  1   2   3   5  8  13   </p><pre class="highlight"><span class="line"><span class="comment"># 迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibIterator</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;实例属性的初始花和赋值&quot;&quot;&quot;</span></span><br><span class="line">        self.n = n      <span class="comment">#  数列长度</span></span><br><span class="line">        self.current = <span class="number">0</span>    <span class="comment">#  设置两个初始值</span></span><br><span class="line">        self.num1 = <span class="number">0</span></span><br><span class="line">        self.num2 = <span class="number">1</span>   <span class="comment">#  初始下标</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回迭代器对象的下一位置数据&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 能拿到数据的情况</span></span><br><span class="line">        <span class="keyword">if</span> self.current &lt; self.n:</span><br><span class="line">            num = self.num1</span><br><span class="line">            self.num1,self.num2 = self.num2,self.num1+self.num2</span><br><span class="line">            self.current+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        <span class="comment"># 拿不到数据的情况</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span>  StopIteration    <span class="comment">#主动抛出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fib = FibIterator(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> fib:</span><br><span class="line">        print(num)</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">n</span>):</span> <span class="comment"># 创建一个函数</span></span><br><span class="line">    num1,num2 = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">    current = <span class="number">1</span>    <span class="comment"># 初始值</span></span><br><span class="line">    <span class="keyword">while</span> current &lt;= n:    <span class="comment"># i小于等于n，n次数 循环的控制条件</span></span><br><span class="line">        <span class="keyword">yield</span> num1    <span class="comment"># 返回a的值，但不结束函数</span></span><br><span class="line">        num1,num2 = num2 , num1 + num2</span><br><span class="line">        current += <span class="number">1</span>     <span class="comment"># 步长值</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> fib(<span class="number">10</span>):    <span class="comment"># 以for循环来获取yield每次的值</span></span><br><span class="line">    print(x)</span><br></pre><h3 id="3-字符串相乘：给定两个以字符串形式表示的非负整数-num1-和-num2，返回-num1-和-num2-的乘积，它们的乘积也表示为字符串形式"><a href="#3-字符串相乘：给定两个以字符串形式表示的非负整数-num1-和-num2，返回-num1-和-num2-的乘积，它们的乘积也表示为字符串形式" class="headerlink" title="3.字符串相乘：给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式"></a>3.字符串相乘：给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式</h3><p>示例 :<br>输入: num1 = “123”, num2 = “456”<br>输出: “56088”</p><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Func</span>(<span class="params">num1,num2</span>):</span></span><br><span class="line">    alist1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    alist2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num1:</span><br><span class="line">        <span class="keyword">if</span> i.isdigit():</span><br><span class="line">           alist1 += i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> num2:</span><br><span class="line">        <span class="keyword">if</span>  j.isdigit():</span><br><span class="line">            alist2 += j</span><br><span class="line">    str1=str(int(alist1) * int(alist2 ))</span><br><span class="line">    <span class="keyword">return</span> str1</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(Func(<span class="string">&#x27;11qq&#x27;</span>,<span class="string">&#x27;zz99xx&#x27;</span>))</span><br><span class="line"></span><br></pre><h3 id="4-实现一个算法来实现反转字符数组的功能-反转的要求如下：将字符数组的字符进行反转-例如-‘b’-‘-‘-‘a’-‘r’-变成-‘r’-‘a’-‘-‘-‘b’-将字符数组替换为反转后的数组。"><a href="#4-实现一个算法来实现反转字符数组的功能-反转的要求如下：将字符数组的字符进行反转-例如-‘b’-‘-‘-‘a’-‘r’-变成-‘r’-‘a’-‘-‘-‘b’-将字符数组替换为反转后的数组。" class="headerlink" title="4.实现一个算法来实现反转字符数组的功能,反转的要求如下：将字符数组的字符进行反转,例如 [‘b’, ‘ ‘, ‘a’, ‘r’],变成 [‘r’, ‘a’, ‘ ‘, ‘b’] , 将字符数组替换为反转后的数组。"></a>4.实现一个算法来实现反转字符数组的功能,反转的要求如下：将字符数组的字符进行反转,例如 [‘b’, ‘ ‘, ‘a’, ‘r’],变成 [‘r’, ‘a’, ‘ ‘, ‘b’] , 将字符数组替换为反转后的数组。</h3><h5 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h5><p>常规的解法是创建一个相同长度的新数组，<br>然后把第一个数组中的元素，按倒序放入新数组中。<br>但更简单的方法是：利用 Python 交换变量的特性，<br>不需要新建数组，直接在原数组里即可完成</p><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, chars</span>):</span></span><br><span class="line">    <span class="keyword">if</span> chars:</span><br><span class="line">        size = len(chars)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size // <span class="number">2</span>):</span><br><span class="line">            chars[i], chars[size - <span class="number">1</span> - i] = chars[size - <span class="number">1</span> - i], chars[i]</span><br><span class="line">        <span class="keyword">return</span> chars</span><br><span class="line">print(reverse(<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;a&#x27;</span>))</span><br></pre><h3 id="5-栈：也称下压栈，堆栈，是仅允许在表尾进行插入和删除操作的线性表"><a href="#5-栈：也称下压栈，堆栈，是仅允许在表尾进行插入和删除操作的线性表" class="headerlink" title="5.栈：也称下压栈，堆栈，是仅允许在表尾进行插入和删除操作的线性表,"></a>5.栈：也称下压栈，堆栈，是仅允许在表尾进行插入和删除操作的线性表,</h3><p>特点：先进后出   后进先出</p><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化&quot;&quot;&quot;</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self,item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;push(item)添加一个新的元素item到栈顶&quot;&quot;&quot;</span></span><br><span class="line">        self.stack.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;pop()弹出栈顶元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.stack == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;peek()返回栈顶元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.stack == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;is_empty()判断栈是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.stack == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;size()返回栈的元素个数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> len(self.stack)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    stack = Stack()</span><br><span class="line">    stack.push(<span class="number">1</span>)</span><br><span class="line">    stack.pop()</span><br><span class="line">    print(stack.peek())</span><br><span class="line">    print(stack.isEmpty())</span><br><span class="line">    print(stack.size())</span><br></pre><h3 id="6-队列：是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。"><a href="#6-队列：是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。" class="headerlink" title="6.队列：是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。"></a>6.队列：是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</h3><p>特点：先进先出   后进后出</p><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;实例属性的初始化和赋值创建一个空的队列&quot;&quot;&quot;</span></span><br><span class="line">        self.queue = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self,item</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;往队列中添加一个item元素&quot;&quot;&quot;</span></span><br><span class="line">        self.queue.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断一个队列是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.queue==[]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;从队列头部删除一个元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.queue==[]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span>  self.queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回队列大小&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span>  len(self.queue)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q=Queue()</span><br><span class="line">    q.enqueue(<span class="number">1</span>)</span><br><span class="line">    q.enqueue(<span class="number">2</span>)</span><br><span class="line">    q.enqueue(<span class="number">3</span>)</span><br><span class="line">    q.enqueue(<span class="number">4</span>)</span><br><span class="line">    q.enqueue(<span class="number">5</span>)</span><br><span class="line">    print(q.is_empty())</span><br><span class="line">    print(<span class="string">&quot;长度为：&quot;</span>,q.size())</span><br><span class="line">    print(q.dequeue())</span><br></pre><h3 id="7-去掉空格"><a href="#7-去掉空格" class="headerlink" title="7.去掉空格"></a>7.去掉空格</h3><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_num</span>(<span class="params">par_str</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param par_str: 字符串</span></span><br><span class="line"><span class="string">    :return: num</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    par_list = par_str.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    print([i <span class="keyword">for</span> i <span class="keyword">in</span> par_list <span class="keyword">if</span> i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> par_list:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;&quot;</span> <span class="keyword">in</span> par_list:</span><br><span class="line">            par_list.remove(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    print(par_list)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_num(<span class="string">&#x27;hello, python   hello ,   world&#x27;</span>)</span><br></pre><h3 id="8-两数之和"><a href="#8-两数之和" class="headerlink" title="8.两数之和"></a>8.两数之和</h3><p> 方法1：<br> <pre class="highlight"><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">get_num_index</span>(<span class="params">llist,target</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        :param target: 俩个下标值的和</span></span><br><span class="line"><span class="string">        :param llist: 查看下标所用的列表</span></span><br><span class="line"><span class="string">        :return: 返回符合条件的两个下标值</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,val <span class="keyword">in</span> enumerate(llist):</span><br><span class="line">            y += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> llist[x] +llist[y]==target:</span><br><span class="line">                <span class="keyword">return</span> (x,y)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(get_num_index([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],<span class="number">7</span>))</span><br></pre></p><p>方法2：</p><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_num_index</span>(<span class="params">llist, target</span>):</span></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            :param target: 给定值</span></span><br><span class="line"><span class="string">            :param llist: 查看条件列表</span></span><br><span class="line"><span class="string">            :return: 返回符合条件的下标值</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> llist:</span><br><span class="line">                y = target - i</span><br><span class="line">                <span class="keyword">if</span> y != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> y <span class="keyword">in</span> llist:</span><br><span class="line">                        <span class="keyword">if</span> llist.index(i) == llist.index(y):</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="comment"># if llist.index(i) &lt;= llist.index(y):</span></span><br><span class="line">                        <span class="keyword">return</span> llist.index(y), llist.index(i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> llist.index(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(get_num_index([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">13</span>],<span class="number">13</span>))</span><br></pre><h3 id="9-比较：取值第三个大的数"><a href="#9-比较：取值第三个大的数" class="headerlink" title="9.比较：取值第三个大的数"></a>9.比较：取值第三个大的数</h3><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(num)&gt;=<span class="number">3</span>:</span><br><span class="line">        alist=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sorted(num):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                alist.index(i)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                alist.append(i)</span><br><span class="line">        <span class="keyword">return</span> alist[<span class="number">-3</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    num=[<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">8</span>]</span><br><span class="line">    print(func(num))</span><br></pre><h3 id="10-反转字符数组"><a href="#10-反转字符数组" class="headerlink" title="10.反转字符数组"></a>10.反转字符数组</h3><pre class="highlight"><span class="line"><span class="comment"># 反转字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseString</span>(<span class="params">s</span>):</span></span><br><span class="line">    s[<span class="number">0</span>::] = s[::<span class="number">-1</span>]</span><br><span class="line">    print(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    reverseString([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>])</span><br></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx简介</title>
      <link href="/2019/02/23/nginx%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/02/23/nginx%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-nginx-功能介绍"><a href="#1-nginx-功能介绍" class="headerlink" title="1. nginx 功能介绍"></a>1. nginx 功能介绍</h1><p>Nginx因为它的稳定性、丰富的模块库、灵活的配置和低系统资源的消耗而闻名．业界一致认为它是Apache2.2＋mod_proxy_balancer的轻量级代替者，不仅是因为响应静态页面的速度非常快，而且它的模块数量达到Apache的近2/3。对proxy和rewrite模块的支持很彻底，还支持mod_fcgi、ssl、vhosts ，适合用来做mongrel clusters的前端HTTP响应。<br>nginx和Apache一样使用模块化设计，nginx模块包括内置模块和第三方模块，其中内置模块中包含主模块和事件模块。</p><p>nginx处理请求逻辑图<br><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20190511170603322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70" class="lozad post-image"src="https://img-blog.csdnimg.cn/20190511170603322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70"></p><h1 id="2-nginx可以提供的服务"><a href="#2-nginx可以提供的服务" class="headerlink" title="2. nginx可以提供的服务"></a>2. nginx可以提供的服务</h1><pre class="highlight"><span class="line">1. web 服务.</span><br><span class="line">2. 负载均衡 （反向代理）</span><br><span class="line">3. web cache（web 缓存）</span><br></pre><h1 id="3-nginx-的优点"><a href="#3-nginx-的优点" class="headerlink" title="3. nginx 的优点"></a>3. nginx 的优点</h1><pre class="highlight"><span class="line">1. 高并发。静态小文件</span><br><span class="line">2. 占用资源少。2万并发、10个线程，内存消耗几百M。</span><br><span class="line">3. 功能种类比较多。web,cache,proxy。每一个功能都不是特别强。</span><br><span class="line">4. 支持epoll模型，使得nginx可以支持高并发。</span><br><span class="line">5. nginx 配合动态服务和Apache有区别。（FASTCGI 接口）</span><br><span class="line">6. 利用nginx可以对IP限速，可以限制连接数。</span><br><span class="line">7. 配置简单，更灵活。</span><br></pre><h1 id="4-nginx应用场合"><a href="#4-nginx应用场合" class="headerlink" title="4. nginx应用场合"></a>4. nginx应用场合</h1><pre class="highlight"><span class="line">1. 静态服务器。（图片，视频服务）另一个lighttpd。并发几万，html，js，css，flv，jpg，gif等。</span><br><span class="line">2. 动态服务，nginx——fastcgi 的方式运行PHP，jsp。（PHP并发在500-1500，MySQL 并发在300-1500）。</span><br><span class="line">3. 反向代理，负载均衡。日pv2000W以下，都可以直接用nginx做代理。</span><br><span class="line">4. 缓存服务。类似 SQUID,VARNISH。</span><br></pre><h1 id="5-主流web服务产品对比说明"><a href="#5-主流web服务产品对比说明" class="headerlink" title="5. 主流web服务产品对比说明"></a>5. 主流web服务产品对比说明</h1><h2 id="5-1-Apache-特性"><a href="#5-1-Apache-特性" class="headerlink" title="5.1 Apache-特性"></a>5.1 Apache-特性</h2><pre class="highlight"><span class="line">1. 2.2版本本身稳定强大，据官方说：其2.4版本性能更强。</span><br><span class="line">2. prefork模式取消了进程创建开销，性能很高。</span><br><span class="line">3. 处理动态业务数据时，因关联到后端的引擎和数据库，瓶颈不在与Apache本身。</span><br><span class="line">4. 高并发时消耗系统资源相对多一些。</span><br><span class="line">5. 基于传统的select模型。</span><br><span class="line">6. 扩展库，DSO方法。</span><br></pre><h2 id="5-2-nginx-特性"><a href="#5-2-nginx-特性" class="headerlink" title="5.2 nginx-特性"></a>5.2 nginx-特性</h2><pre class="highlight"><span class="line">1. 基于异步IO模型，（epoll，kqueue），性能强，能够支持上万并发。</span><br><span class="line">2. 对小文件支持很好，性能很高（限静态小文件1M）。</span><br><span class="line">3. 代码优美，扩展库必须编译进主程序。</span><br><span class="line">4. 消耗代码资源比较低。</span><br><span class="line">5.  ighttpd（百度贴吧，豆瓣）</span><br><span class="line">6. 基于异步IO模式，性能和nginx相近。</span><br><span class="line">7. 扩展库是SO模式，比nginx要灵活。</span><br><span class="line">8. 通过差距（mod_secdownload）可实现文件URL地址加密。</span><br></pre><h2 id="5-3-web服务产品性能对比测试"><a href="#5-3-web服务产品性能对比测试" class="headerlink" title="5.3 web服务产品性能对比测试"></a>5.3 web服务产品性能对比测试</h2><h3 id="5-3-1-静态数据性能对比"><a href="#5-3-1-静态数据性能对比" class="headerlink" title="5.3.1 静态数据性能对比"></a>5.3.1 静态数据性能对比</h3><pre class="highlight"><span class="line">1. 处理静态文件Apache性能比nginx和lighttpd要差。</span><br><span class="line">2. nginx在处理小文件优势明显。</span><br><span class="line">3. 处理静态小文件（小于1M），nginx和lighttpd比Apache更有优势，lighttpd最强。</span><br></pre><h3 id="5-3-2-动态数据性能对比"><a href="#5-3-2-动态数据性能对比" class="headerlink" title="5.3.2 动态数据性能对比"></a>5.3.2 动态数据性能对比</h3><pre class="highlight"><span class="line">1. 处理动态内容三者相差不大，主要取决于PHP和数据库的压力。</span><br><span class="line">2. 当处理动态数据时，三者差距不大，从测试结果看，Apache更有优势一点。这是因为处理动态数据能力取决于PHP和后端数据的提供服务能力。也就是说瓶颈不在web服务器上。</span><br><span class="line">3. 一般PHP引擎支持的并发参考值300-1000，JAVA引擎并发300-1000，数据库的并发300-1000.</span><br></pre><h3 id="5-3-3-为什么nginx的总体性能比Apache高。"><a href="#5-3-3-为什么nginx的总体性能比Apache高。" class="headerlink" title="5.3.3 为什么nginx的总体性能比Apache高。"></a>5.3.3 为什么nginx的总体性能比Apache高。</h3><pre class="highlight"><span class="line">1. nginx使用最新的epoll和kqueue网络IO模型，而Apache使用床头的select模式。</span><br><span class="line">2. 目前Linux下能够承受高并发访问的squid、Memcached 都采用的是epoll网络IO模型。</span><br></pre><h3 id="5-3-4-如何选择WEB服务器"><a href="#5-3-4-如何选择WEB服务器" class="headerlink" title="5.3.4 如何选择WEB服务器"></a>5.3.4 如何选择WEB服务器</h3><pre class="highlight"><span class="line">静态业务：高并发、采用nginx，lighttpd，根据自己的掌握程度或公司的要求。</span><br><span class="line">动态业务：采用nginx和Apache均可。</span><br><span class="line">既有静态业务又有动态业务：nginx或Apache，不要多选要单选。</span><br><span class="line">动态业务可以由前端代理（haproxy）,根据页面元素的类型，向后转发相应的服务器进行处理。</span><br><span class="line">思想：我们工作都不要追求一步到位，满足需求的前提下，先用，然后逐步完善。</span><br><span class="line">提示：nginx做web（Apache，lighttpd）、反向代理（haproxy,lvs,nat）及缓存服务器（squid）也是不错的。</span><br><span class="line">最终建议：对外的业务nginx，对内的业务Apache（yum httpd mysql-server php）。</span><br></pre><h1 id="6-nginx实战过程"><a href="#6-nginx实战过程" class="headerlink" title="6. nginx实战过程"></a>6. nginx实战过程</h1><h2 id="6-1-安装依赖包"><a href="#6-1-安装依赖包" class="headerlink" title="6.1 安装依赖包"></a>6.1 安装依赖包</h2><ul><li>nginx安装依赖GCC、openssl-devel、pcre-devel和zlib-devel软件库。</li><li>Pcre全称（Perl Compatible Regular Expressions），中文perl兼容正则表达式，<a href="http://www.pcre.org/">pcre官方站点</a>。<pre class="highlight"><span class="line">yum install  pcre pcre-devel -y </span><br><span class="line">yum install openssl openssl-devel -y </span><br></pre></li></ul><h2 id="6-2-开始编译"><a href="#6-2-开始编译" class="headerlink" title="6.2 开始编译"></a>6.2 开始编译</h2><p>使用**./configure –help<strong>查看各个模块的使用情况，使用</strong>–without-http_ssi_module<strong>的方式关闭不需要的模块。可以使用</strong>–with-http_perl_modules**方式安装需要的模块。</p><h3 id="6-2-1-编译命令"><a href="#6-2-1-编译命令" class="headerlink" title="6.2.1 编译命令"></a>6.2.1 编译命令</h3><pre class="highlight"><span class="line">tar -zxf nginx<span class="number">-1.10</span><span class="number">.1</span>.tar.gz </span><br><span class="line">cd nginx<span class="number">-1.10</span><span class="number">.1</span>/</span><br><span class="line">./configure --prefix=/data/nginx<span class="number">-1.10</span><span class="number">.1</span> --user=nginx --group=nginx  --<span class="keyword">with</span>-http_ssl_module  --<span class="keyword">with</span>-http_stub_status_module</span><br><span class="line"></span><br><span class="line">useradd nginx -M -s /sbin/nologin </span><br><span class="line">make &amp;&amp; make install </span><br><span class="line">ln -s /data/nginx<span class="number">-1.10</span><span class="number">.1</span> /data/nginx</span><br></pre><h3 id="6-2-2-测试nginx配置文件是否正常"><a href="#6-2-2-测试nginx配置文件是否正常" class="headerlink" title="6.2.2 测试nginx配置文件是否正常"></a>6.2.2 测试nginx配置文件是否正常</h3><pre class="highlight"><span class="line">/data/nginx/sbin/nginx -t </span><br><span class="line">nginx: the configuration file /data/nginx<span class="number">-1.10</span><span class="number">.1</span>/conf/nginx.conf syntax <span class="keyword">is</span> ok</span><br><span class="line">nginx: configuration file /data/nginx<span class="number">-1.10</span><span class="number">.1</span>/conf/nginx.conf test <span class="keyword">is</span> successful</span><br></pre><h3 id="6-2-3-启动nginx服务器"><a href="#6-2-3-启动nginx服务器" class="headerlink" title="6.2.3 启动nginx服务器"></a>6.2.3 启动nginx服务器</h3><pre class="highlight"><span class="line">/data/nginx/sbin/nginx  -t  <span class="comment">##检查配置文件</span></span><br><span class="line">/data/nginx/sbin/nginx      <span class="comment">##确定nginx服务</span></span><br><span class="line">netstat -lntup |grep nginx      <span class="comment">## 检查进程是否正常</span></span><br><span class="line">curl http://localhost           <span class="comment">## 确认结果</span></span><br></pre><h3 id="6-2-4-nginx其他命令"><a href="#6-2-4-nginx其他命令" class="headerlink" title="6.2.4 nginx其他命令"></a>6.2.4 nginx其他命令</h3><pre class="highlight"><span class="line">nginx -s signal</span><br><span class="line">signal：</span><br><span class="line">stop — fast shutdown</span><br><span class="line">quit — graceful shutdown</span><br><span class="line">reload — reloading the configuration file</span><br><span class="line">reopen — reopening the log files</span><br><span class="line">用来打开日志文件，这样nginx会把新日志信息写入这个新的文件中</span><br></pre><hr><p><strong>/data/nginx/sbin/nginx -V</strong> 查看已经编译的参数。</p><p>使用kill命令操作nginx。格式：<em>kill -信号 PID</em></p><p>信号名称</p><ul><li>TERM,INT 快速关闭</li><li>QUIT 优雅的关闭，保持吸纳有的客户端连接</li><li>HUP 重启应用新的配置文件</li><li>USR1 重新打开日志文件</li><li>USR2 升级程序</li><li>WINCH 优雅的关闭工作进程</li></ul><p><strong>例子：</strong></p><pre class="highlight"><span class="line">kill -QUIT  &#96;cat &#x2F;data&#x2F;nginx&#x2F;nginx.pid&#96;</span><br><span class="line">kill -HUP &#96;cat &#x2F;data&#x2F;nginx&#x2F;nginx.pid&#96;</span><br></pre><h1 id="7-nginx配置文件"><a href="#7-nginx配置文件" class="headerlink" title="7. nginx配置文件"></a>7. nginx配置文件</h1><p><strong>配置基础配置文件</strong></p><pre class="highlight"><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">### 测试配置文件是否正常</span><br><span class="line">shell&gt; &#x2F;data&#x2F;nginx&#x2F;sbin&#x2F;nginx -t </span><br><span class="line">nginx: the configuration file &#x2F;data&#x2F;nginx-1.10.3&#x2F;conf&#x2F;nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file &#x2F;data&#x2F;nginx-1.10.3&#x2F;conf&#x2F;nginx.conf test is successful</span><br><span class="line">shell&gt; curl -I http:&#x2F;&#x2F;localhost</span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br></pre><h1 id="8-nginx监控"><a href="#8-nginx监控" class="headerlink" title="8. nginx监控"></a>8. nginx监控</h1><p><strong>开启nginx的监控服务</strong></p><h2 id="8-1-开启状态页"><a href="#8-1-开启状态页" class="headerlink" title="8.1 开启状态页"></a>8.1 开启状态页</h2><pre class="highlight"><span class="line"><span class="comment">#设定查看Nginx状态的地址   </span></span><br><span class="line">location /status &#123;  </span><br><span class="line">  stub_status on;   <span class="comment">#表示开启stubStatus的工作状态统计功能。</span></span><br><span class="line">  access_log off;   <span class="comment">#access_log off; 关闭access_log 日志记录功能。</span></span><br><span class="line">  <span class="comment">#auth_basic &quot;status&quot;;   #auth_basic 是nginx的一种认证机制。</span></span><br><span class="line">  <span class="comment">#auth_basic_user_file conf/htpasswd;#用来指定密码文件的位置。</span></span><br><span class="line">&#125;</span><br></pre><h2 id="8-2-配置登录密码"><a href="#8-2-配置登录密码" class="headerlink" title="8.2 配置登录密码"></a>8.2 配置登录密码</h2><pre class="highlight"><span class="line">yum install -y httpd-tools</span><br><span class="line">/usr/local/apache/bin/htpasswd -c /data/nginx/conf/htpasswd biglittleant </span><br><span class="line">New password:</span><br></pre><p><strong>完成后会在/*data/nginx/conf/*目录下生成htpasswd文件。</strong></p><h2 id="8-3-访问URL"><a href="#8-3-访问URL" class="headerlink" title="8.3 访问URL"></a>8.3 访问URL</h2><pre class="highlight"><span class="line">curl http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/status</span><br><span class="line"></span><br><span class="line">Active connections:  <span class="number">1</span></span><br><span class="line">server accepts handled requests</span><br><span class="line"> <span class="number">16</span> <span class="number">16</span> <span class="number">18</span></span><br><span class="line">Reading: <span class="number">0</span> Writing: <span class="number">1</span> Waiting: <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#active connections – 活跃的连接数量</span></span><br><span class="line"><span class="comment">#server accepts handled requests — 总共处理了16个连接 , 成功创建16次握手, 总共处理了18个请求</span></span><br><span class="line"><span class="comment">#Reading — 读取客户端的连接数: Writing 响应数据到客户端的数量; Waiting 开启 keep-alive 的情况下,这个值等于 active – (reading+writing), 意思就是 Nginx 已经处理完正在等候下一次请求指令的驻留连接.</span></span><br></pre><h2 id="8-4-编写zabbix监控脚本"><a href="#8-4-编写zabbix监控脚本" class="headerlink" title="8.4 编写zabbix监控脚本"></a>8.4 编写zabbix监控脚本</h2><pre class="highlight"><span class="line">nginx_status_fun()&#123;</span><br><span class="line">    NGINX_PORT=$<span class="number">1</span></span><br><span class="line">    NGINX_COMMAND=$<span class="number">2</span></span><br><span class="line">    nginx_active()&#123;</span><br><span class="line">        /usr/bin/curl <span class="string">&quot;http://127.0.0.1:&quot;</span>$NGINX_PORT<span class="string">&quot;/status/&quot;</span> <span class="number">2</span>&gt;/dev/null| grep <span class="string">&#x27;Active&#x27;</span> | awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    nginx_reading()&#123;</span><br><span class="line">        /usr/bin/curl <span class="string">&quot;http://127.0.0.1:&quot;</span>$NGINX_PORT<span class="string">&quot;/status/&quot;</span> <span class="number">2</span>&gt;/dev/null| grep <span class="string">&#x27;Reading&#x27;</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">    nginx_writing()&#123;</span><br><span class="line">        /usr/bin/curl <span class="string">&quot;http://127.0.0.1:&quot;</span>$NGINX_PORT<span class="string">&quot;/status/&quot;</span> <span class="number">2</span>&gt;/dev/null| grep <span class="string">&#x27;Writing&#x27;</span> | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">    nginx_waiting()&#123;</span><br><span class="line">        /usr/bin/curl <span class="string">&quot;http://127.0.0.1:&quot;</span>$NGINX_PORT<span class="string">&quot;/status/&quot;</span> <span class="number">2</span>&gt;/dev/null| grep <span class="string">&#x27;Waiting&#x27;</span> | awk <span class="string">&#x27;&#123;print $6&#125;&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">    nginx_accepts()&#123;</span><br><span class="line">        /usr/bin/curl <span class="string">&quot;http://127.0.0.1:&quot;</span>$NGINX_PORT<span class="string">&quot;/status/&quot;</span> <span class="number">2</span>&gt;/dev/null| awk NR==<span class="number">3</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">    nginx_handled()&#123;</span><br><span class="line">        /usr/bin/curl <span class="string">&quot;http://127.0.0.1:&quot;</span>$NGINX_PORT<span class="string">&quot;/status/&quot;</span> <span class="number">2</span>&gt;/dev/null| awk NR==<span class="number">3</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">    nginx_requests()&#123;</span><br><span class="line">        /usr/bin/curl <span class="string">&quot;http://127.0.0.1:&quot;</span>$NGINX_PORT<span class="string">&quot;/status/&quot;</span> <span class="number">2</span>&gt;/dev/null| awk NR==<span class="number">3</span> | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">    case $NGINX_COMMAND <span class="keyword">in</span></span><br><span class="line">        active)</span><br><span class="line">            nginx_active;</span><br><span class="line">            ;;</span><br><span class="line">        reading)</span><br><span class="line">            nginx_reading;</span><br><span class="line">            ;;</span><br><span class="line">        writing)</span><br><span class="line">            nginx_writing;</span><br><span class="line">            ;;</span><br><span class="line">        waiting)</span><br><span class="line">            nginx_waiting;</span><br><span class="line">            ;;</span><br><span class="line">        accepts)</span><br><span class="line">            nginx_accepts;</span><br><span class="line">            ;;</span><br><span class="line">        handled)</span><br><span class="line">            nginx_handled;</span><br><span class="line">            ;;</span><br><span class="line">        requests)</span><br><span class="line">            nginx_requests;</span><br><span class="line">        esac </span><br><span class="line">&#125;</span><br></pre><h1 id="9-nginx优化"><a href="#9-nginx优化" class="headerlink" title="9. nginx优化"></a>9. nginx优化</h1><h2 id="9-1-nginx内核优化"><a href="#9-1-nginx内核优化" class="headerlink" title="9.1 nginx内核优化"></a>9.1 nginx内核优化</h2><pre class="highlight"><span class="line">net.ipv4.tcp_fin_timeout = <span class="number">2</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = <span class="number">1</span></span><br><span class="line">net.ipv4.tcp_syncookies = <span class="number">1</span></span><br><span class="line">net.ipv4.tcp_keepalive_time = <span class="number">600</span></span><br><span class="line">net.ipv4.ip_local_port_range = <span class="number">4000</span>    <span class="number">65000</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = <span class="number">16384</span></span><br><span class="line">net.ipv4.tcp_max_tw_buckets = <span class="number">36000</span></span><br><span class="line">net.ipv4.route.gc_timeout = <span class="number">100</span></span><br><span class="line">net.ipv4.tcp_syn_retries = <span class="number">1</span></span><br><span class="line">net.ipv4.tcp_synack_retries = <span class="number">1</span></span><br><span class="line">net.core.somaxconn = <span class="number">16384</span></span><br><span class="line">net.core.netdev_max_backlog = <span class="number">16384</span></span><br><span class="line">net.ipv4.tcp_max_orphans = <span class="number">16384</span></span><br><span class="line"><span class="comment">#以下参数是对iptables防火墙的优化，防火墙不开会提示，可以忽略不理。</span></span><br><span class="line">net.ipv4.ip_conntrack_max = <span class="number">25000000</span></span><br><span class="line">net.ipv4.netfilter.ip_conntrack_max=<span class="number">25000000</span></span><br><span class="line">net.ipv4.netfilter.ip_conntrack_tcp_timeout_established=<span class="number">180</span></span><br><span class="line">net.ipv4.netfilter.ip_conntrack_tcp_timeout_time_wait=<span class="number">120</span></span><br><span class="line">net.ipv4.netfilter.ip_conntrack_tcp_timeout_close_wait=<span class="number">60</span></span><br><span class="line">net.ipv4.netfilter.ip_conntrack_tcp_timeout_fin_wait=<span class="number">120</span></span><br><span class="line"></span><br></pre><h1 id="10-扩展一："><a href="#10-扩展一：" class="headerlink" title="10. 扩展一："></a>10. 扩展一：</h1><h2 id="10-1-nginx全局变量"><a href="#10-1-nginx全局变量" class="headerlink" title="10.1  nginx全局变量"></a>10.1  nginx全局变量</h2><pre class="highlight"><span class="line">$args：这个变量等于请求行中的参数，同$query_string。</span><br><span class="line">$is_args: 如果已经设置$args，则该变量的值为&quot;?&quot;，否则为&quot;&quot;。</span><br><span class="line">$content_length： 请求头中的Content-length字段。</span><br><span class="line">$content_type： 请求头中的Content-Type字段。</span><br><span class="line">$document_uri： 与$uri相同。</span><br><span class="line">$document_root： 当前请求在root指令中指定的值。</span><br><span class="line">$host： 请求主机头字段，否则为服务器名称。</span><br><span class="line">$http_user_agent： 客户端agent信息。</span><br><span class="line">$http_cookie： 客户端cookie信息。</span><br><span class="line">$limit_rate： 这个变量可以限制连接速率。</span><br><span class="line">$request_method： 客户端请求的动作，通常为GET或POST。</span><br><span class="line">$remote_addr： 客户端的IP地址。</span><br><span class="line">$remote_port： 客户端的端口。</span><br><span class="line">$remote_user： 已经经过Auth Basic Module验证的用户名。</span><br><span class="line">$request_body_file&#96;: 客户端请求主体的临时文件名。</span><br><span class="line">$request_uri: 请求的URI，带参数</span><br><span class="line">$request_filename： 当前请求的文件路径，由root或alias指令与URI请求生成。</span><br><span class="line">$scheme： 所用的协议，比如http或者是https，比如rewrite ^(.+)$ $scheme:&#x2F;&#x2F;example.com$1 redirect;。</span><br><span class="line">$server_protocol： 请求使用的协议，通常是HTTP&#x2F;1.0或HTTP&#x2F;1.1。</span><br><span class="line">$server_addr： 服务器地址，在完成一次系统调用后可以确定这个值。</span><br><span class="line">$server_name： 服务器名称。</span><br><span class="line">$server_port： 请求到达服务器的端口号。</span><br><span class="line">$request_uri： 包含请求参数的原始URI，不包含主机名，如：&#x2F;foo&#x2F;bar.php?arg&#x3D;baz，它无法修改。</span><br><span class="line">$uri： 不带请求参数的当前URI，$uri不包含主机名，如&#x2F;foo&#x2F;bar.html可能和最初的值有不同，比如经过重定向之类的。它可以通过内部重定向，或者使用index指令进行修改。不包括协议和主机名，例如&#x2F;foo&#x2F;bar.html。</span><br></pre><p><strong>例子：</strong></p><pre class="highlight"><span class="line">访问链接是：http://localhost:<span class="number">88</span>/test1/test.php </span><br><span class="line">网站路径是：/var/www/html</span><br><span class="line"></span><br><span class="line">$host：localhost</span><br><span class="line">$server_port：<span class="number">88</span></span><br><span class="line">$request_uri：http://localhost:<span class="number">88</span>/test1/test.php</span><br><span class="line">$document_uri：/test1/test.php</span><br><span class="line">$document_root：/var/www/html</span><br><span class="line">$request_filename：/var/www/html/test1/test.php</span><br><span class="line"></span><br></pre><p><strong>nginx plus – ngx_http_status_module</strong></p><p>商业版的 nginx plus 通过他的 ngx_http_status_module 提供了比 nginx 更多的监控指标，可以参看 <a href="http://demo.nginx.com/status.html">http://demo.nginx.com/status.html</a></p><p><strong>nginx access log 分析</strong><br>nginx 的 access log 中可以记录很多有价值的信息，通过分析 access log，可以收集到很多指标。<br>python 编写的 linux 工具 ngxtop 就实现了对 access log 的分析功能。</p><p><strong>NDK – ngx_devel_kit</strong><br>NDK 是一个拓展nginx服务器核心功能的模块，第三方模块开发可以基于它来快速实现。NDK提供函数和宏处理一些基本任务，减轻第三方模块开发的代码量。</p><p><strong>nginx lua – lua-nginx-module</strong><br>nginx的lua模块，通过这个模块，可以对nginx做定制开发</p><h2 id="10-2-web服务器事件处理模型"><a href="#10-2-web服务器事件处理模型" class="headerlink" title="10.2  web服务器事件处理模型"></a>10.2  web服务器事件处理模型</h2><p><strong>select</strong><br>select最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。<br>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，事实上从现在看来，这也是它所剩不多的优点之一。<br>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。<br>另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。</p><p><strong>poll</strong><br>poll在1986年诞生于System V Release 3，它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。<br>poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。<br>另外，select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll()的时候将再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。</p><p><strong>epoll</strong><br>直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll，它几乎具备了之前所说的一切优点，被公认为Linux2.6下性能最好的多路I/O就绪通知方法。<br>epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。<br>epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。<br>另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</p><p><strong>nginx -s reload 过程</strong><br>nginx主进程读取配置文件，如果发现配置文件变更，会创建一个新的主进程，然后同时旧的进程，及旧的子进程关闭，旧进程会拒绝新的连接，服务到自己的连接结束，然后关闭。</p><p><strong>Apache select模型和 nginx epoll 模型对比讲解</strong></p><p>Nginx的高并发得益于其采用了epoll模型，与传统的服务器程序架构不同，epoll是linux内核2.6以后才出现的。下面通过比较Apache和Nginx工作原理来比较。</p><p>传统Apache都是多进程或者多线程来工作，假设是多进程工作（prefork），apache会先生成几个进程，类似进程池的工作原理，只不过这里的进程池会随着请求数目的增加而增加。对于每一个连接，apache都是在一个进程内处理完毕。具体是 recv（），以及根据 URI 去进行磁盘I/O来寻找文件，还有 send（）都是阻塞的。其实说白了都是 apche 对于套接字的I/O，读或者写，但是读或者写都是阻塞的，阻塞意味着进程就得挂起进入sleep状态，那么一旦连接数很多，Apache必然要生成更多的进程来响应请求，一旦进程多了，CPU对于进程的切换就频繁了，很耗资源和时间，所以就导致apache性能下降了，说白了就是处理不过来这么多进程了。其实仔细想想，如果对于进程每个请求都没有阻塞，那么效率肯定会提高很多。</p><p>Nginx采用epoll模型，异步非阻塞。对于Nginx来说，把一个完整的连接请求处理都划分成了事件，一个一个的事件。比如accept（）， recv（），磁盘I/O，send（）等，每部分都有相应的模块去处理，一个完整的请求可能是由几百个模块去处理。真正核心的就是事件收集和分发模块，这就是管理所有模块的核心。只有核心模块的调度才能让对应的模块占用CPU资源，从而处理请求。拿一个HTTP请求来说，首先在事件收集分发模块注册感兴趣的监听事件，注册好之后不阻塞直接返回，接下来就不需要再管了，等待有连接来了内核会通知你(epoll的轮询会告诉进程)，cpu就可以处理其他事情去了。一旦有请求来，那么对整个请求分配相应的上下文（其实已经预先分配好），这时候再注册新的感兴趣的事件(read函数)，同样客户端数据来了内核会自动通知进程可以去读数据了，读了数据之后就是解析，解析完后去磁盘找资源（I/O），一旦I/O完成会通知进程，进程开始给客户端发回数据send()，这时候也不是阻塞的，调用后就等内核发回通知发送的结果就行。整个下来把一个请求分成了很多个阶段，每个阶段都到很多模块去注册，然后处理，都是异步非阻塞。异步这里指的就是做一个事情，不需要等返回结果，做好了会自动通知你。</p><p><strong>select/epoll的特点</strong></p><p><strong>select的特点</strong>：select 选择句柄的时候，是遍历所有句柄，也就是说句柄有事件响应时，select需要遍历所有句柄才能获取到哪些句柄有事件通知，因此效率是非常低。但是如果连接很少的情况下， select和epoll的LT触发模式相比， 性能上差别不大。<br>这里要多说一句，select支持的句柄数是有限制的， 同时只支持1024个，这个是句柄集合限制的，如果超过这个限制，很可能导致溢出，而且非常不容易发现问题， 当然可以通过修改linux的socket内核调整这个参数。<br><strong>epoll的特点</strong>：epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高，内核将句柄用红黑树保存的。<br>对于epoll而言还有ET和LT的区别，LT表示水平触发，ET表示边缘触发，两者在性能以及代码实现上差别也是非常大的。</p><p>不管是Nginx还是Squid这种反向代理，其网络模式都是事件驱动。事件驱动其实是很老的技术，早期的select、poll都是如此。后来基于内核通知的更高级事件机制出现，如libevent里的epoll，使事件驱动性能得以提高。事件驱动的本质还是IO事件，应用程序在多个IO句柄间快速切换，实现所谓的异步IO。事件驱动服务器，最适合做的就是这种IO密集型工作，如反向代理，它在客户端与WEB服务器之间起一个数据中转作用，纯粹是IO操作，自身并不涉及到复杂计算。反向代理用事件驱动来做，显然更好，一个工作进程就可以run了，没有进程、线程管理的开销，CPU、内存消耗都小。</p><p>所以Nginx、Squid都是这样做的。当然，Nginx也可以是多进程 + 事件驱动的模式，几个进程跑libevent，不需要Apache那样动辄数百的进程数。Nginx处理静态文件效果也很好，那是因为静态文件本身也是磁盘IO操作，处理过程一样。至于说多少万的并发连接，这个毫无意义。随手写个网络程序都能处理几万的并发，但如果大部分客户端阻塞在那里，就没什么价值。</p><p>再看看Apache或者Resin这类应用服务器，之所以称他们为应用服务器，是因为他们真的要跑具体的业务应用，如科学计算、图形图像、数据库读写等。它们很可能是CPU密集型的服务，事件驱动并不合适。例如一个计算耗时2秒，那么这2秒就是完全阻塞的，什么event都没用。想想MySQL如果改成事件驱动会怎么样，一个大型的join或sort就会阻塞住所有客户端。这个时候多进程或线程就体现出优势，每个进程各干各的事，互不阻塞和干扰。当然，现代CPU越来越快，单个计算阻塞的时间可能很小，但只要有阻塞，事件编程就毫无优势。所以进程、线程这类技术，并不会消失，而是与事件机制相辅相成，长期存在。</p><p><strong>总言之，事件驱动适合于IO密集型服务，多进程或线程适合于CPU密集型服务，它们各有各的优势，并不存在谁取代谁的倾向。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql锁</title>
      <link href="/2019/02/14/Mysql%E9%94%81/"/>
      <url>/2019/02/14/Mysql%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>锁是计算机协调多个进程或线程并发访问某一资源的机制。锁保证数据并发访问的一致性、有效性；锁冲突也是影响数据库并发访问性能的一个重要因素。锁是Mysql在服务器层和存储引擎层的的并发控制。</p><p>加锁是消耗资源的，锁的各种操作，包括获得锁、检测锁是否是否已解除、释放锁等。<br><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczEuYmRzdGF0aWMuY29tLzcwY0Z2WFNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTI0MTU0OTYwOTYsMzQyMTczMjE1OSZmbT0yNiZncD0wLmpwZw?x-oss-process=image/format,png" class="lozad post-image"src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczEuYmRzdGF0aWMuY29tLzcwY0Z2WFNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTI0MTU0OTYwOTYsMzQyMTczMjE1OSZmbT0yNiZncD0wLmpwZw?x-oss-process=image/format,png"></p><h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><h2 id="共享锁与排他锁"><a href="#共享锁与排他锁" class="headerlink" title="共享锁与排他锁"></a>共享锁与排他锁</h2><ul><li><p>共享锁（读锁）：其他事务可以读，但不能写。</p></li><li><p>排他锁（写锁） ：其他事务不能读取，也不能写。</p><h2 id="粒度锁"><a href="#粒度锁" class="headerlink" title="粒度锁"></a>粒度锁</h2><p>MySQL 不同的存储引擎支持不同的锁机制，所有的存储引擎都以自己的方式显现了锁机制，服务器层完全不了解存储引擎中的锁实现：</p></li><li><p>MyISAM 和 MEMORY 存储引擎采用的是表级锁（table-level locking）</p></li><li><p>BDB 存储引擎采用的是页面锁（page-level locking），但也支持表级锁</p></li><li><p>InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。</p></li></ul><p>默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。</p><p>但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。</p><p><strong>不同粒度锁的比较：</strong></p><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<ul><li>这些存储引擎通过总是一次性同时获取所有需要的锁以及总是按相同的顺序获取表锁来避免死锁。</li><li>表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用</li></ul></li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<ul><li>最大程度的支持并发，同时也带来了最大的锁开销。</li><li>在 InnoDB 中，除单个 SQL 组成的事务外，<br>锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。</li><li>行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统</li></ul></li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。<h1 id="MyISAM-表锁"><a href="#MyISAM-表锁" class="headerlink" title="MyISAM 表锁"></a>MyISAM 表锁</h1><h2 id="MyISAM表级锁模式："><a href="#MyISAM表级锁模式：" class="headerlink" title="MyISAM表级锁模式："></a>MyISAM表级锁模式：</h2></li><li>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li><li>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；</li></ul><p>MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。 其他线程的读、 写操作都会等待，直到锁被释放为止。</p><p>默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。 （This ensures that updates to a table are not “starved” even when there is heavy SELECT activity for the table. However, if there are many updates for a table, SELECT statements wait until there are no more updates.）。</p><p>这也正是 MyISAM 表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。同时，一些需要长时间运行的查询操作，也会使写线程“饿死” ，应用中应尽量避免出现长时间运行的查询操作（在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解” ，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行）。</p><p><strong>可以设置改变读锁和写锁的优先级：</strong></p><ul><li>通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。</li><li>通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。</li><li>通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。</li><li>给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。<h2 id="MyISAM加表锁方法："><a href="#MyISAM加表锁方法：" class="headerlink" title="MyISAM加表锁方法："></a>MyISAM加表锁方法：</h2>MyISAM 在执行查询语句（SELECT）前，会自动给涉及的表加读锁，在执行更新操作<br>（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。</li></ul><p>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因。</p><p>MyISAM存储引擎支持并发插入，以减少给定表的读和写操作之间的争用：</p><p>如果MyISAM表在数据文件中间没有空闲块，则行始终插入数据文件的末尾。 在这种情况下，你可以自由混合并发使用MyISAM表的INSERT和SELECT语句而不需要加锁——你可以在其他线程进行读操作的时候，同时将行插入到MyISAM表中。 文件中间的空闲块可能是从表格中间删除或更新的行而产生的。 如果文件中间有空闲快，则并发插入会被禁用，但是当所有空闲块都填充有新数据时，它又会自动重新启用。 要控制此行为，可以使用MySQL的concurrent_insert系统变量。</p><p>如果你使用LOCK TABLES显式获取表锁，则可以请求READ LOCAL锁而不是READ锁，以便在锁定表时，其他会话可以使用并发插入。</p><ul><li>当concurrent_insert设置为0时，不允许并发插入。</li><li>当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个线程读表的同时，另一个线程从表尾插入记录。这也是MySQL的默认设置。</li><li>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。</li></ul><p><strong>查询表级锁争用情况：</strong><br>可以通过检查 table_locks_waited 和 table_locks_immediate 状态变量来分析系统上的表锁的争夺，如果 Table_locks_waited 的值比较高，则说明存在着较严重的表级锁争用情况：</p><pre class="highlight"><span class="line">mysql&gt; SHOW STATUS LIKE &#39;Table%&#39;;</span><br><span class="line">+-----------------------+---------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-----------------------+---------+</span><br><span class="line">| Table_locks_immediate | 1151552 |</span><br><span class="line">| Table_locks_waited | 15324 |</span><br><span class="line">+-----------------------+---------+</span><br></pre><h1 id="InnoDB行级锁和表级锁"><a href="#InnoDB行级锁和表级锁" class="headerlink" title="InnoDB行级锁和表级锁"></a>InnoDB行级锁和表级锁</h1><h2 id="InnoDB锁模式："><a href="#InnoDB锁模式：" class="headerlink" title="InnoDB锁模式："></a>InnoDB锁模式：</h2><p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p><ul><li><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</p></li><li><p>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。<br>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p></li><li><p>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</p></li><li><p>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</p></li></ul><p><strong>锁模式的兼容情况：</strong></p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0zNzc2MTYxMmVhZDExZGRjMzc2MmE0YzIwZGRhYjNmM183MjB3LmpwZw?x-oss-process=image/format,png" class="lozad post-image"src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0zNzc2MTYxMmVhZDExZGRjMzc2MmE0YzIwZGRhYjNmM183MjB3LmpwZw?x-oss-process=image/format,png"></p><p>（如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务； 反之， 如果两者不兼容，该事务就要等待锁释放。）</p><h2 id="InnoDB加锁方法："><a href="#InnoDB加锁方法：" class="headerlink" title="InnoDB加锁方法："></a>InnoDB加锁方法：</h2><ul><li>意向锁是 InnoDB 自动加的， 不需用户干预。</li><li>对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB<br>会自动给涉及数据集加排他锁（X)；</li><li>对于普通 SELECT 语句，InnoDB 不会加任何锁；<br>事务可以通过以下语句显式给记录集加共享锁或排他锁：<ul><li>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</li><li>排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</li></ul></li></ul><ul><li>隐式锁定：<br>InnoDB在事务执行过程中，使用两阶段锁协议：</li></ul><p>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</p><p>锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。</p><ul><li>显式锁定 ：<pre class="highlight"><span class="line">select ... lock in share mode &#x2F;&#x2F;共享锁 </span><br><span class="line">select ... for update &#x2F;&#x2F;排他锁 </span><br></pre></li></ul><p><strong>select for update：</strong></p><p>在执行这个 select 查询语句的时候，会将对应的索引访问条目进行上排他锁（X 锁），也就是说这个语句对应的锁就相当于update带来的效果。</p><p>select *** for update 的使用场景：为了让自己查到的数据确保是最新数据，并且查到后的数据只允许自己来修改的时候，需要用到 for update 子句。</p><p><strong>select lock in share mode</strong> ：in share mode 子句的作用就是将查找到的数据加上一个 share 锁，这个就是表示其他的事务只能对这些数据进行简单的select 操作，并不能够进行 DML 操作。select *** lock in share mode 使用场景：为了确保自己查到的数据没有被其他的事务正在修改，也就是说确保查到的数据是最新的数据，并且不允许其他人来修改数据。但是自己不一定能够修改数据，因为有可能其他的事务也对这些数据 使用了 in share mode 的方式上了 S 锁。</p><p><strong>性能影响：</strong><br>select for update 语句，相当于一个 update 语句。在业务繁忙的情况下，如果事务没有及时的commit或者rollback 可能会造成其他事务长时间的等待，从而影响数据库的并发使用效率。<br>select lock in share mode 语句是一个给查找的数据上一个共享锁（S 锁）的功能，它允许其他的事务也对该数据上S锁，但是不能够允许对该数据进行修改。如果不及时的commit 或者rollback 也可能会造成大量的事务等待。</p><p><strong>for update 和 lock in share mode 的区别：</strong></p><p>前一个上的是排他锁（X 锁），一旦一个事务获取了这个锁，其他的事务是没法在这些数据上执行 for update ；后一个是共享锁，多个事务可以同时的对相同数据执行 lock in share mode。</p><h2 id="InnoDB-行锁实现方式："><a href="#InnoDB-行锁实现方式：" class="headerlink" title="InnoDB 行锁实现方式："></a>InnoDB 行锁实现方式：</h2><ul><li>InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</li><li>不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。</li><li>只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时，<br>别忘了检查 SQL 的执行计划（可以通过 explain 检查 SQL 的执行计划），以确认是否真正使用了索引。（更多阅读：MySQL索引总结）</li><li>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个session是访问不同行的记录， 但是如果是使用相同的索引键， 是会出现锁冲突的（后使用这些索引的session需要等待先使用索引的session释放锁后，才能获取锁）。 应用设计的时候要注意这一点。<h2 id="InnoDB的间隙锁："><a href="#InnoDB的间隙锁：" class="headerlink" title="InnoDB的间隙锁："></a>InnoDB的间隙锁：</h2>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</li></ul><p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p><h2 id="InnoDB使用间隙锁的目的："><a href="#InnoDB使用间隙锁的目的：" class="headerlink" title="InnoDB使用间隙锁的目的："></a>InnoDB使用间隙锁的目的：</h2><ol><li>防止幻读，以满足相关隔离级别的要求；</li><li>满足恢复和复制的需要：</li></ol><p>MySQL 通过 BINLOG 录入执行成功的 INSERT、UPDATE、DELETE 等更新数据的 SQL 语句，并由此实现 MySQL 数据库的恢复和主从复制。MySQL 的恢复机制（复制其实就是在 Slave Mysql 不断做基于 BINLOG 的恢复）有以下特点：</p><p>一是 MySQL 的恢复是 SQL 语句级的，也就是重新执行 BINLOG 中的 SQL 语句。</p><p>二是 MySQL 的 Binlog 是按照事务提交的先后顺序记录的， 恢复也是按这个顺序进行的。</p><p>由此可见，MySQL 的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读。</p><p><strong>InnoDB 在不同隔离级别下的一致性读及锁的差异：</strong><br>锁和多版本数据（MVCC）是 InnoDB 实现一致性读和 ISO/ANSI SQL92 隔离级别的手段。</p><p>因此，在不同的隔离级别下，InnoDB 处理 SQL 时采用的一致性读策略和需要的锁是不同的：<br><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWNiLnpoaW1nLmNvbS84MC92Mi1jODNjNjQ1OWY4ZGM5M2E1ZjE1N2ZlMWUzMDgwMDg4ZF83MjB3LmpwZw?x-oss-process=image/format,png" class="lozad post-image"src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWNiLnpoaW1nLmNvbS84MC92Mi1jODNjNjQ1OWY4ZGM5M2E1ZjE1N2ZlMWUzMDgwMDg4ZF83MjB3LmpwZw?x-oss-process=image/format,png"></p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi01Njg5NTFmNGNkZmViOTQxNjA0MjYyN2E3Yjk0YzRhY183MjB3LmpwZw?x-oss-process=image/format,png" class="lozad post-image"src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi01Njg5NTFmNGNkZmViOTQxNjA0MjYyN2E3Yjk0YzRhY183MjB3LmpwZw?x-oss-process=image/format,png"></p><p>对于许多 SQL，隔离级别越高，InnoDB 给记录集加的锁就越严格（尤其是使用范围条件的时候），产生锁冲突的可能性也就越高，从而对并发性事务处理性能的 影响也就越大。</p><p>因此， 我们在应用中， 应该尽量使用较低的隔离级别， 以减少锁争用的机率。实际上，通过优化事务逻辑，大部分应用使用 Read Commited 隔离级别就足够了。对于一些确实需要更高隔离级别的事务， 可以通过在程序中执行 SET SESSION TRANSACTION ISOLATION</p><p>LEVEL REPEATABLE READ 或 SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE 动态改变隔离级别的方式满足需求。</p><h2 id="获取-InnoDB-行锁争用情况："><a href="#获取-InnoDB-行锁争用情况：" class="headerlink" title="获取 InnoDB 行锁争用情况："></a>获取 InnoDB 行锁争用情况：</h2><p>可以通过检查 InnoDB_row_lock 状态变量来分析系统上的行锁的争夺情况：</p><pre class="highlight"><span class="line">mysql&gt; show status like &#39;innodb_row_lock%&#39;; </span><br><span class="line">+-------------------------------+-------+ </span><br><span class="line">| Variable_name | Value | </span><br><span class="line">+-------------------------------+-------+ </span><br><span class="line">| InnoDB_row_lock_current_waits | 0 | </span><br><span class="line">| InnoDB_row_lock_time | 0 | </span><br><span class="line">| InnoDB_row_lock_time_avg | 0 | </span><br><span class="line">| InnoDB_row_lock_time_max | 0 | </span><br><span class="line">| InnoDB_row_lock_waits | 0 | </span><br><span class="line">+-------------------------------+-------+ </span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre><p><strong>LOCK TABLES 和 UNLOCK TABLES</strong><br>Mysql也支持lock tables和unlock tables，这都是在服务器层（MySQL Server层）实现的，和存储引擎无关，它们有自己的用途，并不能替代事务处理。 （除了禁用了autocommint后可以使用，其他情况不建议使用）：</p><p>LOCK TABLES 可以锁定用于当前线程的表。如果表被其他线程锁定，则当前线程会等待，直到可以获取所有锁定为止。<br>UNLOCK TABLES 可以释放当前线程获得的任何锁定。当前线程执行另一个 LOCK TABLES 时，<br>或当与服务器的连接被关闭时，所有由当前线程锁定的表被隐含地解锁</p><h2 id="LOCK-TABLES语法："><a href="#LOCK-TABLES语法：" class="headerlink" title="LOCK TABLES语法："></a>LOCK TABLES语法：</h2><ul><li>在用 LOCK TABLES 对 InnoDB 表加锁时要注意，要将 AUTOCOMMIT 设为 0，否则MySQL 不会给表加锁；</li><li>事务结束前，不要用 UNLOCK TABLES 释放表锁，因为 UNLOCK TABLES会隐含地提交事务；</li><li>COMMIT 或 ROLLBACK 并不能释放用 LOCK TABLES 加的表级锁，必须用UNLOCK TABLES 释放表锁。<br>正确的方式见如下语句：<br>例如，如果需要写表 t1 并从表 t 读，可以按如下做：<pre class="highlight"><span class="line">SET AUTOCOMMIT&#x3D;0; </span><br><span class="line">LOCK TABLES t1 WRITE, t2 READ, ...; </span><br><span class="line">[do something with tables t1 and t2 here]; </span><br><span class="line">COMMIT; </span><br><span class="line">UNLOCK TABLES;</span><br></pre></li></ul><h2 id="使用LOCK-TABLES的场景："><a href="#使用LOCK-TABLES的场景：" class="headerlink" title="使用LOCK TABLES的场景："></a>使用LOCK TABLES的场景：</h2><p>给表显示加表级锁（InnoDB表和MyISAM都可以），一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。（与MyISAM默认的表锁行为类似）</p><p>在用 LOCK TABLES 给表显式加表锁时，必须同时取得所有涉及到表的锁，并且 MySQL 不支持锁升级。也就是说，在执行 LOCK TABLES 后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。</p><p>其实，在MyISAM自动加锁（表锁）的情况下也大致如此，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因。</p><p>例如，有一个订单表 orders，其中记录有各订单的总金额 total，同时还有一个 订单明细表 order_detail，其中记录有各订单每一产品的金额小计 subtotal，假设我们需要检 查这两个表的金额合计是否相符，可能就需要执行如下两条 SQL：</p><pre class="highlight"><span class="line">Select sum(total) from orders; </span><br><span class="line">Select sum(subtotal) from order_detail; </span><br></pre><p>这时，如果不先给两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，<br>order_detail 表可能已经发生了改变。因此，正确的方法应该是：</p><pre class="highlight"><span class="line">Lock tables orders read local, order_detail read local; </span><br><span class="line">Select sum(total) from orders; </span><br><span class="line">Select sum(subtotal) from order_detail; </span><br><span class="line">Unlock tables;</span><br></pre><p>（在 LOCK TABLES 时加了“local”选项，其作用就是允许当你持有表的读锁时，其他用户可以在满足 MyISAM 表并发插入条件的情况下，在表尾并发插入记录（MyISAM 存储引擎支持“并发插入”））</p><h1 id="死锁（Deadlock-Free）"><a href="#死锁（Deadlock-Free）" class="headerlink" title="死锁（Deadlock Free）"></a>死锁（Deadlock Free）</h1><ul><li><p>死锁产生：</p><ul><li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</li><li>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。</li><li>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li></ul></li><li><p><strong>检测死锁</strong>：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p></li><li><p>死锁恢复：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p></li><li><p>外部锁的死锁检测：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决</p></li><li><p>死锁影响性能：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖innodb_lock_wait_timeout设置进行事务回滚。</p><h2 id="MyISAM避免死锁："><a href="#MyISAM避免死锁：" class="headerlink" title="MyISAM避免死锁："></a>MyISAM避免死锁：</h2></li><li><p>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。</p><h2 id="InnoDB避免死锁："><a href="#InnoDB避免死锁：" class="headerlink" title="InnoDB避免死锁："></a>InnoDB避免死锁：</h2></li><li><p>为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用SELECT … FOR UPDATE语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</p></li><li><p>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</p></li><li><p>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</p></li><li><p>通过SELECT … LOCK IN SHARE MODE获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</p></li><li><p>改变事务隔离级别</p></li></ul><p>如果出现死锁，可以用 SHOW INNODB STATUS 命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p><h2 id="一些优化锁性能的建议"><a href="#一些优化锁性能的建议" class="headerlink" title="一些优化锁性能的建议"></a>一些优化锁性能的建议</h2><ol><li>尽量使用较低的隔离级别；</li><li>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会</li><li>选择合理的事务大小，小事务发生锁冲突的几率也更小</li><li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁</li><li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会</li><li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响</li><li>不要申请超过实际需要的锁级别</li><li>除非必须，查询时不要显示加锁。 MySQL的MVCC可以实现事务中的查询不用加锁，优化事务性能；MVCC只在COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作</li><li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能<h1 id="乐观锁、悲观锁"><a href="#乐观锁、悲观锁" class="headerlink" title="乐观锁、悲观锁"></a>乐观锁、悲观锁</h1></li></ol><ul><li><p>**乐观锁(Optimistic Lock)**：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。<br>乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p></li><li><p>**悲观锁(Pessimistic Lock)**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。<br>悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql事务</title>
      <link href="/2019/02/08/Mysql%E4%BA%8B%E5%8A%A1/"/>
      <url>/2019/02/08/Mysql%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h1><ul><li>简单来说就是：做一件事件必须有有头有尾，一旦开始，只有两种结果，要么失败，要么成功，而不能出现成功了部分失败了部分。</li><li>专业点说就是：一个事务必须具备 ACID属性，所谓得 ACID即：<br> 1. Atomicity–原子性:<br> 事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。<br> 2. Consistency–一致性<br> 事务进行过后和执行前，所有数据都是预期一致的（一致性的理解有很多，大概是这样子的）<br> 3. Isolation–隔离性<br> 并发得事务之间不会互相影响，<br> 4. Durability–持久性<br> 一个事务成功了，那么他的的改变应该是永久性的。<h1 id="为什么要事务"><a href="#为什么要事务" class="headerlink" title="为什么要事务"></a>为什么要事务</h1>这个其实用脚趾头想想也知道它的重要性，举个简单的例子：<br>一个用户提交了一个订单，那么这条数据包含了两个信息，用户信息 和购买的 商品信息，我需要把他们分别存到 用户表 和 商品表，如果不采用事务，可能会出现，商品信息插入成功，而用户信息没有，这时候就会出现无主商品了，用户付了钱，却得不到商品，这就尴尬了，而如果采用事务，就可以保证，用户信息 和 商品信息 都必须插入成功，该次事务才算成功，那就不会出现这种问题了</li></ul><h1 id="支持事务的引擎"><a href="#支持事务的引擎" class="headerlink" title="支持事务的引擎"></a>支持事务的引擎</h1><p>有时候事务并不一定是必须的，为了提升查询效率，有些mysql引擎是不支持事务的，比如 MyISAM，当然目前新版（好像是5.6以后）默认的引擎是 innoDB 是支持事务的，一般为了提升mysql速度，也会做读写分离，因为事务一般是针对写来说的。</p><h1 id="事务的使用"><a href="#事务的使用" class="headerlink" title="事务的使用"></a>事务的使用</h1><p>我们主要从以下几个术语开始：</p><ul><li><p>事务（transaction）执行一组SQL语句；<br>start transaction即可开始一个事务</p></li><li><p>回退（rollback）撤销指定SQL语句的过程；<br>rollback即可回退一个事务：rollback 必须是在一个事务里面才能使用，没有事务，就不能谈回退</p></li><li><p>提交（commit）将未存储的SQL语句结果写入数据库表；<br>commit使用 commit 来结束一个事务的处理：一般使用事务，我们需要自己手动提交，mysql 默认是自动提交的，所以我们需要设置set autocommit = 0来更改提交模式。其中值得注意的是 rollback也会触发提交事务</p></li><li><p>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），然后你就可以回退到该点。<br>savepoint s1生成一个保留点，然后可以通过 rollback to s1来回退到 s1 这个保留</p></li></ul><p><strong>实例</strong><br>讲了这么多，不来一个实例操作一下，实在是不舒心。。。。下面你可以打开你的mysql 库，按照下面步骤来操作一下，加深下理解：</p><pre class="highlight"><span class="line">truncate info：</span><br><span class="line">先清除一下表,记得用测试表噢，数据没了可别赖我</span><br><span class="line">select * from info：</span><br><span class="line">查询一下，这里表应该是空的了</span><br><span class="line">start transaction：</span><br><span class="line">开启一个事务，正式我们的测试</span><br><span class="line">insert into info values(1,&quot;s1 before&quot;,20181019)：</span><br><span class="line">插入一条数据 “s1 before”</span><br><span class="line">savepoint s1：</span><br><span class="line">创建一个保留点</span><br><span class="line">insert into info values(1,&quot;s1 after&quot;,20181019)：</span><br><span class="line">再插入一条数据 “s1 after”</span><br><span class="line">select * from info：</span><br><span class="line">查询看一下数据，此时应该是可以看到我们上面插入的两条数据。但是你要知道，这两条数据是没有正式入库的，他们只存在你的这个session里面，因为我们的事务还没提交呢。。。不信？你重开一个客户端，查看一下这个表，还是空的噢。</span><br><span class="line">rollback to s1：</span><br><span class="line">回滚到 s1 保留点。</span><br><span class="line">select * from info：</span><br><span class="line">这个时候你应该是只能看到 “s1 after” 这条数据了，并且事务没有提交，验证的话，还是重启一个客户端查看就好</span><br><span class="line">rollback：</span><br><span class="line">回滚事务，也就是说，我们之前做的操作我都不要了，回滚到开始事务时候的状态，并结束事务。</span><br><span class="line">insert into info values(1,&quot;no transaction&quot;,20181019)：</span><br><span class="line">再插入一条数据</span><br><span class="line">select * from info：</span><br><span class="line">再另外一个客户端直接查询，立马看到上面插入的数据 “no transaction”，也是验证了事务确实结束了</span><br><span class="line">set autocommit&#x3D;0：</span><br><span class="line">上面我们插入数据，另外一个客户端立马就查询到了，说明是自动提交了我们的插入，现在我们设置不自动提交。</span><br><span class="line">insert into info values(1,&quot;autocommit&#x3D;0&quot;,20181019)：</span><br><span class="line">插入一条数据 “autocommit&#x3D;0”</span><br><span class="line">select * from info;</span><br><span class="line">在另外一个客户端查询，你会发现，上面这条 &quot;autocommit&#x3D;0&quot; 数据并没有插入</span><br><span class="line">commit</span><br><span class="line">提交，这个时候你再去查询，才能查到你提交的数据 &quot;autocommit&#x3D;0&quot;</span><br></pre><p><strong><em>这里需要注意的是，不要将非自动提交和事务搞混淆了，非自动提交，一般是为了批次提交从而提升效率，但是并不具备事务性，而事务是在批次提交的基础上保证了事务性，所以还是有一定区别的噢</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL慢查询—开启慢查询</title>
      <link href="/2019/01/30/MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E2%80%94%E5%BC%80%E5%90%AF%E6%85%A2%E6%9F%A5%E8%AF%A2/"/>
      <url>/2019/01/30/MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E2%80%94%E5%BC%80%E5%90%AF%E6%85%A2%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。</p><h3 id="二、参数说明"><a href="#二、参数说明" class="headerlink" title="二、参数说明"></a>二、参数说明</h3><p>slow_query_log 慢查询开启状态<br>slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）<br>long_query_time 查询超过多少秒才记录</p><h3 id="三、设置步骤"><a href="#三、设置步骤" class="headerlink" title="三、设置步骤"></a>三、设置步骤</h3><p><strong>1.查看慢查询相关参数</strong></p><pre class="highlight"><span class="line">mysql&gt; show variables like <span class="string">&#x27;slow_query%&#x27;</span>;</span><br><span class="line">+---------------------------+----------------------------------+</span><br><span class="line">| Variable_name             | Value                            |</span><br><span class="line">+---------------------------+----------------------------------+</span><br><span class="line">| slow_query_log            | OFF                              |</span><br><span class="line">| slow_query_log_file       | /mysql/data/localhost-slow.log   |</span><br><span class="line">+---------------------------+----------------------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like <span class="string">&#x27;long_query_time&#x27;</span>;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | <span class="number">10.000000</span> |</span><br><span class="line">+-----------------+-----------+</span><br></pre><p><strong>2.设置方法</strong></p><p>方法一：全局变量设置<br>将 slow_query_log 全局变量设置为“ON”状态</p><pre class="highlight"><span class="line">mysql&gt; set global slow_query_log&#x3D;&#39;ON&#39;; </span><br></pre><p>设置慢查询日志存放的位置</p><pre class="highlight"><span class="line">mysql&gt; set global slow_query_log_file&#x3D;&#39;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;slow.log&#39;;</span><br></pre><p>查询超过1秒就记录</p><pre class="highlight"><span class="line">mysql&gt; set global long_query_time&#x3D;1;</span><br></pre><p>方法二：配置文件设置<br>修改配置文件my.cnf，在[mysqld]下的下方加入</p><pre class="highlight"><span class="line">[mysqld]</span><br><span class="line">slow_query_log &#x3D; ON</span><br><span class="line">slow_query_log_file &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;slow.log</span><br><span class="line">long_query_time &#x3D; 1</span><br></pre><p>3.重启MySQL服务</p><pre class="highlight"><span class="line">service mysqld restart</span><br></pre><p>4.查看设置后的参数</p><pre class="highlight"><span class="line">mysql&gt; show variables like &#39;slow_query%&#39;;</span><br><span class="line">+---------------------+--------------------------------+</span><br><span class="line">| Variable_name       | Value                          |</span><br><span class="line">+---------------------+--------------------------------+</span><br><span class="line">| slow_query_log      | ON                             |</span><br><span class="line">| slow_query_log_file | &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;slow.log |</span><br><span class="line">+---------------------+--------------------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#39;long_query_time&#39;;</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Variable_name   | Value    |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| long_query_time | 1.000000 |</span><br><span class="line">+-----------------+----------+</span><br></pre><h3 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h3><p>1.执行一条慢查询SQL语句</p><pre class="highlight"><span class="line">mysql&gt; select sleep(2);</span><br></pre><p>2.查看是否生成慢查询日志</p><pre class="highlight"><span class="line">ls &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;slow.log</span><br></pre><p>如果日志存在，MySQL开启慢查询设置成功！</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL存储引擎</title>
      <link href="/2019/01/19/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2019/01/19/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是存储引擎"><a href="#什么是存储引擎" class="headerlink" title="什么是存储引擎"></a>什么是存储引擎</h1><p>数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。</p><p>现在许多数据库管理系统都支持多种不同的存储引擎。MySQL 的核心就是存储引擎。</p><p><strong><em>提示：InnoDB 事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5 之后，InnoDB 作为默认存储引擎。</em></strong></p><p>MyISAM 是基于 ISAM 的存储引擎，并对其进行扩展，是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。</p><p>MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他数据提供快速访问。</p><h1 id="MySQL-5-7-支持的存储引擎"><a href="#MySQL-5-7-支持的存储引擎" class="headerlink" title="MySQL 5.7 支持的存储引擎"></a>MySQL 5.7 支持的存储引擎</h1><p>MySQL 支持多种类型的数据库引擎，可分别根据各个引擎的功能和特性为不同的数据库处理任务提供各自不同的适应性和灵活性。在 MySQL 中，可以利用 SHOW ENGINES 语句来显示可用的数据库引擎和默认引擎。</p><p>MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。</p><p>MySQL 5.7 支持的存储引擎有 InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE 等。可以使用SHOW ENGINES语句查看系统所支持的引擎类型，结果如图所示。</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTAyMjIvNC0xWjIyMjFLMDA2MTI1LmdpZg" class="lozad post-image"src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTAyMjIvNC0xWjIyMjFLMDA2MTI1LmdpZg"></p><p>Support 列的值表示某种引擎是否能使用，<strong>YES</strong>表示可以使用，<strong>NO</strong>表示不能使用，<strong>DEFAULT</strong>表示该引擎为当前默认的存储引擎。</p><h1 id="如何选择-MySQL-存储引擎"><a href="#如何选择-MySQL-存储引擎" class="headerlink" title="如何选择 MySQL 存储引擎"></a>如何选择 MySQL 存储引擎</h1><p>不同的存储引擎都有各自的特点，以适应不同的需求，如表所示。为了做出选择，首先要考虑每一个存储引擎提供了哪些不同的功能。</p><p><img src="https://img-blog.csdnimg.cn/20200804140854255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU4Nzg2NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200804140854255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU4Nzg2NA==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>可以根据以下的原则来选择 MySQL 存储引擎：</p><ul><li>如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 是一个很好的选择。</li><li>如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。</li><li>如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。</li><li>如果只有 INSERT 和 SELECT 操作，可以选择Archive 引擎，Archive 存储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive 存储引擎非常适合存储归档数据，如记录日志信息可以使用 Archive 引擎。</li></ul><p><strong><em>提示：使用哪一种引擎要根据需要灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。</em></strong></p><h1 id="MySQL-默认存储引擎"><a href="#MySQL-默认存储引擎" class="headerlink" title="MySQL 默认存储引擎"></a>MySQL 默认存储引擎</h1><p>InnoDB 是系统的默认引擎，支持可靠的事务处理。</p><p>使用下面的语句可以修改数据库临时的默认存储引擎</p><pre class="highlight"><span class="line">SET default_storage_engine&#x3D;&lt; 存储引擎名 &gt;</span><br></pre><p>例如，将 MySQL 数据库的临时默认存储引擎修改为 MyISAM，输入的 SQL 语句和运行结果如图所示。<br><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTAyMjIvNC0xWjIyMjFLNTAxTDEuZ2lm" class="lozad post-image"src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTAyMjIvNC0xWjIyMjFLNTAxTDEuZ2lm"></p><p>此时，可以发现 MySQL 的默认存储引擎已经变成了 MyISAM。但是当再次重启客户端时，默认存储引擎仍然是 InnoDB。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 优化</title>
      <link href="/2019/01/12/MySQL%20%E4%BC%98%E5%8C%96/"/>
      <url>/2019/01/12/MySQL%20%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="1-选取最适用的字段属性"><a href="#1-选取最适用的字段属性" class="headerlink" title="1. 选取最适用的字段属性"></a>1. 选取最适用的字段属性</h1><p>表中字段的宽度设得尽可能小：char 的上限为 255 字节（固定占用空间），varchar 的上限 65535 字节（实际占用空间），text 的上限为 65535。char 比 varchar 处理效率高。</p><p>尽量把字段设置为 NOT NULL，执行查询的时候，数据库不用去比较 NULL 值。</p><h1 id="2-使用连接（JOIN）来代替子查询-Sub-Queries"><a href="#2-使用连接（JOIN）来代替子查询-Sub-Queries" class="headerlink" title="2. 使用连接（JOIN）来代替子查询 (Sub-Queries)"></a>2. 使用连接（JOIN）来代替子查询 (Sub-Queries)</h1><p>连接（JOIN）之所以更有效率一些，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作（联合查询的条件加索引更快）。</p><h1 id="3-使用联合-UNION-来代替手动创建的临时表"><a href="#3-使用联合-UNION-来代替手动创建的临时表" class="headerlink" title="3. 使用联合 (UNION) 来代替手动创建的临时表"></a>3. 使用联合 (UNION) 来代替手动创建的临时表</h1><p>把需要使用临时表的两条或更多的 SELECT 查询合并的一个查询中。</p><p>SELECT Name, Phone FROM client UNION SELECT Name, BirthDate FROM author UNION SELECT Name, Supplier FROM product;</p><h1 id="4-事务"><a href="#4-事务" class="headerlink" title="4. 事务"></a>4. 事务</h1><p>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条 SQL 语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。</p><p>作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以 BEGIN 关键字开始，COMMIT 关键字结束。在这之间的一条 SQL 操作失败，那么，ROLLBACK 命令就可以把数据库恢复到 BEGIN 开始之前的状态。</p><h1 id="5-锁定表"><a href="#5-锁定表" class="headerlink" title="5. 锁定表"></a>5. 锁定表</h1><p>尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在很大的应用系统中。由于在事务执行的过程中，数据库将会被锁定，因此其它的用户请求只能暂时等待直到该事务结束。</p><pre class="highlight"><span class="line">LOCK TABLE inventory WRITE </span><br><span class="line">SELECT Quantity FROM inventory </span><br><span class="line">WHEREItem=<span class="string">&#x27;book&#x27;</span>; </span><br><span class="line"><span class="meta">... </span></span><br><span class="line">UPDATE inventory SET Quantity=<span class="number">11</span> </span><br><span class="line">WHEREItem=<span class="string">&#x27;book&#x27;</span>; </span><br><span class="line">UNLOCK TABLES</span><br></pre><p>这里，我们用一个 SELECT 语句取出初始数据，通过一些计算，用 UPDATE 语句将新值更新到表中。包含有 WRITE 关键字的 LOCK TABLE 语句可以保证在 UNLOCK TABLES 命令被执行之前，不会有其它的访问来对 inventory 进行插入、更新或者删除的操作。</p><h1 id="6、使用外键"><a href="#6、使用外键" class="headerlink" title="6、使用外键"></a>6、使用外键</h1><p>锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。例如，外键可以保证每一条销售记录都指向某一个存在的客户。在这里，外键可以把 customerinfo 表中的 CustomerID 映射到 salesinfo 表中 CustomerID，任何一条没有合法 CustomerID 的记录都不会被更新或插入到 salesinfo 中。</p><pre class="highlight"><span class="line">CREATE TABLE customerinfo </span><br><span class="line">( </span><br><span class="line">CustomerID INT NOT NULL , </span><br><span class="line">PRIMARY KEY ( CustomerID ) </span><br><span class="line">) TYPE = INNODB; </span><br><span class="line">CREATE TABLE salesinfo </span><br><span class="line">( </span><br><span class="line">SalesID INT NOT NULL, </span><br><span class="line">CustomerID INT NOT NULL, </span><br><span class="line">PRIMARY KEY(CustomerID, SalesID), </span><br><span class="line">FOREIGN KEY (CustomerID) REFERENCES customerinfo </span><br><span class="line">(CustomerID) ON DELETECASCADE </span><br><span class="line">) TYPE = INNODB;</span><br></pre><p>注意例子中的参数 “ON DELETE CASCADE”。该参数保证当 customerinfo 表中的一条客户记录被删除的时候，salesinfo 表中所有与该客户相关的记录也会被自动删除。如果要在 MySQL 中使用外键，一定要记住在创建表的时候将表的类型定义为事务安全表 InnoDB 类型。该类型不是 MySQL 表的默认类型。定义的方法是在 CREATE TABLE 语句中加上 TYPE=INNODB。</p><h1 id="7-使用索引"><a href="#7-使用索引" class="headerlink" title="7. 使用索引"></a>7. 使用索引</h1><p>查询语句当中包含有 MAX (), MIN () 和 ORDERBY 这些命令的时候，性能提高更为明显。</p><p>索引应建立在那些将用于 JOIN, WHERE 判断和 ORDER BY 排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个 ENUM 类型的字段来说，出现大量重复值是很有可能的情况，例如 customerinfo 中的 “province”.. 字段，在这样的字段上建立索引将不会有什么帮助；相反，还有可能降低数据库的性能。</p><p>普通索引（由关键字 KEY 或 INDEX 定义的索引）的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHEREcolumn=）或排序条件（ORDERBYcolumn）中的数据列创建索引。</p><p>唯一索引的好处：一是简化了 MySQL 对这个索引的管理工作，这个索引也因此而变得更有效率；二是 MySQL 会在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过了；如果是，MySQL 将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。在许多场合，创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。</p><h1 id="8-优化的查询语句"><a href="#8-优化的查询语句" class="headerlink" title="8. 优化的查询语句"></a>8. 优化的查询语句</h1><pre class="highlight"><span class="line">SELECT FROM order WHERE YEAR(OrderDate)&lt;<span class="number">2001</span>; </span><br><span class="line">SELECT FROM order WHERE OrderDate&lt;<span class="string">&quot;2001-01-01&quot;</span>;</span><br><span class="line">SELECT FROM inventory WHERE Amount/<span class="number">7</span>&lt;<span class="number">24</span>; </span><br><span class="line">SELECT FROM inventory WHERE Amount&lt;<span class="number">24</span>*<span class="number">7</span>;</span><br></pre><p>避免在查询中让 MySQL 进行自动类型转换，因为转换过程也会使索引变得不起作用。</p><h1 id="9-索引失效情况"><a href="#9-索引失效情况" class="headerlink" title="9. 索引失效情况"></a>9. 索引失效情况</h1><p>like 以 % 开头，索引无效；当 like 前缀没有 %，后缀有 % 时，索引有效。</p><p>or 语句前后没有同时使用索引。当 or 左右查询字段只有一个是索引，该索引失效，只有当 or 左右查询字段均为索引时，才会生效。</p><p>组合索引，不是使用第一列索引，索引失效。</p><p>数据类型出现隐式转化。如 varchar 不加单引号的话可能会自动转换为 int 型，使索引无效，产生全表扫描。</p><p>在索引字段上使用 not，&lt;&gt;，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 优化方法： key&lt;&gt;0 改为 key&gt;0 or key&lt;0。</p><p>当全表扫描速度比索引速度快时，mysql 会使用全表扫描，此时索引失效。</p><p>应尽量避免在 where 子句中使用 or,and,in,not in 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，合理使用 union all（允许重复的值，请使用 UNION ALL）。</p><pre class="highlight"><span class="line">select id <span class="keyword">from</span> t where num=<span class="number">10</span> <span class="keyword">or</span> num=<span class="number">20</span></span><br></pre><p>可以这样查询：</p><pre class="highlight"><span class="line">select id <span class="keyword">from</span> t where num=<span class="number">10</span>    </span><br><span class="line">union all    </span><br><span class="line">select id <span class="keyword">from</span> t where num=<span class="number">20</span></span><br></pre><h1 id="10-引擎的选取"><a href="#10-引擎的选取" class="headerlink" title="10. 引擎的选取"></a>10. 引擎的选取</h1><p>MyISAM 索引文件在数据库中存放的对应表的磁盘文件有.frm,.MYD,*.MYI 结尾的三个文件：</p><p>frm 文件是存放的表结构，表的定义信息；</p><p>MYD 文件是存放着表中的数据；</p><p>MYI 文件存放着表的索引信息；</p><p>InnoDB 存储引擎在磁盘中存放的对应的表的磁盘文件有.frm,.ibd 这两个文件；</p><p>frm 文件是存放表结构，表的定义信息；</p><p>ibd 文件是存放 表中的数据、索引信息；</p><h1 id="性能方面的优化："><a href="#性能方面的优化：" class="headerlink" title="性能方面的优化："></a>性能方面的优化：</h1><h2 id="1-分表的分类（单表记录条数达到百万到千万级别时就要使用分表）"><a href="#1-分表的分类（单表记录条数达到百万到千万级别时就要使用分表）" class="headerlink" title="1.分表的分类（单表记录条数达到百万到千万级别时就要使用分表）"></a>1.分表的分类（单表记录条数达到百万到千万级别时就要使用分表）</h2><ol><li>纵向分表</li></ol><p>文章标题，作者，分类，创建时间等，是变化频率慢，查询次数多，而且最好有很好的实时性的数据，我们把它叫做冷数据。</p><p>浏览量，回复数等，类似的统计信息，或者别的变化频率比较高的数据，我们把它叫做活跃数据。</p><p>首先存储引擎的使用不同，冷数据使用 MyIsam 可以有更好的查询数据。活跃数据，可以使用 Innodb , 可以有更好的更新速度。</p><p>就是把原来一张表里的字段，冷数据的字段和活跃数据的字段分别建立 2 张表来管理。</p><ol start="2"><li>横向分表</li></ol><p>把大的表结构，横向切割为同样结构的不同表，如，用户信息表，user_1,user_2 等，表结构是完全一样。</p><h2 id="2-慢查询"><a href="#2-慢查询" class="headerlink" title="2. 慢查询"></a>2. 慢查询</h2><pre class="highlight"><span class="line">show variables like <span class="string">&#x27;slow%&#x27;</span>;</span><br><span class="line">show <span class="keyword">global</span> status like <span class="string">&#x27;slow%&#x27;</span>;</span><br></pre><p>使用 mysqlreport；</p><p>正确使用索引：explain 分析查询语句，组合索引，索引副作用（占空间、update）</p><p>开启慢查询日志、使用慢查询分析工具 mysqlsla；</p><p>索引缓存、索引代价（插入更新索引）；</p><p>表锁，行锁，行锁副作用（update 多时候变慢），在 select 和 update 混合的情况下，行锁巧妙解决了读写互斥的问题；</p><p>开启使用查询缓存；</p><p>修改临时表内存空间；</p><p>开启线程池；</p><h1 id="MySQL-Query-语句优化的基本思路和原则"><a href="#MySQL-Query-语句优化的基本思路和原则" class="headerlink" title="MySQL Query 语句优化的基本思路和原则"></a>MySQL Query 语句优化的基本思路和原则</h1><p>1、优化需要优化的 Query；</p><p>2、定位优化对象的性能瓶颈；</p><p>3、明确优化目标；</p><p>4、从 Explaing 入手；</p><p>5、多使用 Profile；</p><p>6、永远用小结果集推动大的结果集；</p><p>7、尽可能在索引中完成排序；</p><p>8、只取自己需要的 Columns；</p><p>9、仅仅使用最有效的过滤条件；</p><p>10、尽可能避免复杂的 Join 和子查询。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MD基本语法</title>
      <link href="/2019/01/07/MD%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/01/07/MD%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="md是什么"><a href="#md是什么" class="headerlink" title="md是什么"></a>md是什么</h2><h6 id="md即markdown文件的基本常用编写语法-是一种快速标记、快速排版语言"><a href="#md即markdown文件的基本常用编写语法-是一种快速标记、快速排版语言" class="headerlink" title=".md即markdown文件的基本常用编写语法,是一种快速标记、快速排版语言"></a>.md即markdown文件的基本常用编写语法,是一种快速标记、快速排版语言</h6><hr><h2 id="1-基本符号：-gt"><a href="#1-基本符号：-gt" class="headerlink" title="1.基本符号：* - + &gt;"></a>1.基本符号：* - + &gt;</h2><h6 id="基本上所有的markdown标记都是基于这四个符号或组合，需要注意的是，如果以基本符号开头的标记，注意基本符号后有一个用于分割标记符和内容的空格。"><a href="#基本上所有的markdown标记都是基于这四个符号或组合，需要注意的是，如果以基本符号开头的标记，注意基本符号后有一个用于分割标记符和内容的空格。" class="headerlink" title="基本上所有的markdown标记都是基于这四个符号或组合，需要注意的是，如果以基本符号开头的标记，注意基本符号后有一个用于分割标记符和内容的空格。"></a>基本上所有的markdown标记都是基于这四个符号或组合，需要注意的是，如果以基本符号开头的标记，注意基本符号后有一个用于分割标记符和内容的空格。</h6><hr><h2 id="2-标题"><a href="#2-标题" class="headerlink" title="2.标题"></a>2.标题</h2><h6 id="前面带-号，后面带文字，分别表示h1-h6-只到h6，而且h1下面会有一条横线-–-gt-相当于标签闭合"><a href="#前面带-号，后面带文字，分别表示h1-h6-只到h6，而且h1下面会有一条横线-–-gt-相当于标签闭合" class="headerlink" title="前面带#号，后面带文字，分别表示h1-h6,只到h6，而且h1下面会有一条横线  –&gt; 相当于标签闭合"></a>前面带#号，后面带文字，分别表示h1-h6,只到h6，而且h1下面会有一条横线  –&gt; 相当于标签闭合</h6><pre class="highlight"><span class="line"><span class="comment"># 一级标题</span></span><br><span class="line"><span class="comment">## 二级标题</span></span><br><span class="line"><span class="comment">### 三级标题</span></span><br><span class="line"><span class="comment">#### 四级标题</span></span><br><span class="line"><span class="comment">##### 五级标题</span></span><br><span class="line"><span class="comment">###### 六级标题</span></span><br></pre><pre class="highlight"><span class="line"><span class="comment"># 一级标题 #</span></span><br><span class="line"><span class="comment">## 二级标题 ##</span></span><br><span class="line"><span class="comment">### 三级标题 ###</span></span><br><span class="line"><span class="comment">#### 四级标题 ####</span></span><br><span class="line"><span class="comment">##### 五级标题 #####</span></span><br><span class="line"><span class="comment">###### 六级标题 #####</span></span><br></pre><h6 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h6><p><img src="/hugoblog/md.png" alt="md" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/md.png" class="lozad post-image"></p><hr><h2 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h2><ul><li>无序列表<pre class="highlight"><span class="line">//形式一</span><br><span class="line">+ a</span><br><span class="line">+ b</span><br><span class="line">+ c</span><br><span class="line"></span><br><span class="line">//形式二</span><br><span class="line">- d</span><br><span class="line">- e</span><br><span class="line">- f</span><br><span class="line"></span><br><span class="line">//形式三</span><br><span class="line">* g</span><br><span class="line">* h</span><br><span class="line">* i</span><br></pre></li></ul><h6 id="以上三种形式，效果其实都是一样的："><a href="#以上三种形式，效果其实都是一样的：" class="headerlink" title="以上三种形式，效果其实都是一样的："></a>以上三种形式，效果其实都是一样的：</h6><p><img src="/hugoblog/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8.png" alt="无序列表" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8.png" class="lozad post-image"></p><hr><ul><li>有序列表<pre class="highlight"><span class="line"></span><br><span class="line">//正常形式</span><br><span class="line"><span class="number">1.</span> abc</span><br><span class="line"><span class="number">2.</span> bcd</span><br><span class="line"><span class="number">3.</span> cde</span><br><span class="line">//错序效果</span><br><span class="line"><span class="number">2.</span> fgh</span><br><span class="line"><span class="number">3.</span> ghi</span><br><span class="line"><span class="number">5.</span> hij</span><br></pre><h6 id="效果图：-1"><a href="#效果图：-1" class="headerlink" title="效果图："></a>效果图：</h6><img src="/hugoblog/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8.png" alt="有序列表" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8.png" class="lozad post-image"></li></ul><hr><h6 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h6><pre class="highlight"><span class="line">如图,数字后面的点只能是英文的点，有序列表的序号是根据第一行列表的数字顺序来的，</span><br><span class="line">错序列表的序号本来是序号是乱的， 但是还是显示 2 3 5</span><br></pre><hr><ul><li>嵌套列表<pre class="highlight"><span class="line">//无序列表嵌套</span><br><span class="line">+ <span class="number">123</span></span><br><span class="line">    + abc</span><br><span class="line">    + bcd</span><br><span class="line">    + cde</span><br><span class="line">+ <span class="number">465</span></span><br><span class="line">+ <span class="number">789</span></span><br><span class="line">//有序列表嵌套</span><br><span class="line"><span class="number">1.</span> abcd</span><br><span class="line">    <span class="number">1.</span> abcde</span><br><span class="line">    <span class="number">2.</span> abcde</span><br><span class="line">    <span class="number">3.</span> abcde</span><br><span class="line"><span class="number">2.</span> bcde</span><br><span class="line"><span class="number">3.</span> cdef</span><br></pre><h6 id="效果图：-2"><a href="#效果图：-2" class="headerlink" title="效果图："></a>效果图：</h6><img src="/hugoblog/%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8.png" alt="嵌套列表" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8.png" class="lozad post-image"></li></ul><h6 id="列表可以嵌套，使用时在嵌套列表前按-tab-或-空格-来缩进-去控制列表的层数"><a href="#列表可以嵌套，使用时在嵌套列表前按-tab-或-空格-来缩进-去控制列表的层数" class="headerlink" title="列表可以嵌套，使用时在嵌套列表前按 tab 或 空格 来缩进,去控制列表的层数"></a>列表可以嵌套，使用时在嵌套列表前按 tab 或 空格 来缩进,去控制列表的层数</h6><hr><h2 id="4-引用说明区块"><a href="#4-引用说明区块" class="headerlink" title="4.引用说明区块"></a>4.引用说明区块</h2><h6 id="对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语法。"><a href="#对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语法。" class="headerlink" title="对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语法。"></a>对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语法。</h6><ul><li>正常形式<pre class="highlight"><span class="line">&gt; 引用内容、说明内容。在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等。</span><br></pre><h6 id="效果图：-3"><a href="#效果图：-3" class="headerlink" title="效果图："></a>效果图：</h6><img src="/hugoblog/%E5%BC%95%E7%94%A8%E8%AF%B4%E6%98%8E.png" alt="引用说明" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E5%BC%95%E7%94%A8%E8%AF%B4%E6%98%8E.png" class="lozad post-image"></li></ul><hr><ul><li>嵌套区块<h6 id="这里我只介绍一下我常用的方法，也是个人认为比较规范的一种方法，就是给区块的下一级区块多加一个右尖括号"><a href="#这里我只介绍一下我常用的方法，也是个人认为比较规范的一种方法，就是给区块的下一级区块多加一个右尖括号" class="headerlink" title="这里我只介绍一下我常用的方法，也是个人认为比较规范的一种方法，就是给区块的下一级区块多加一个右尖括号"></a>这里我只介绍一下我常用的方法，也是个人认为比较规范的一种方法，就是给区块的下一级区块多加一个右尖括号</h6><pre class="highlight"><span class="line">&gt; 一级引用</span><br><span class="line">&gt;&gt; 二级引用</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>三级引用</span><br><span class="line">&gt;&gt;&gt;&gt; 四级引用</span><br><span class="line">&gt;&gt;&gt;&gt;&gt; 五级引用</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt; 六级引用</span><br></pre></li></ul><h6 id="效果图：-4"><a href="#效果图：-4" class="headerlink" title="效果图："></a>效果图：</h6><p><img src="/hugoblog/%E5%B5%8C%E5%A5%97%E5%BC%95%E7%94%A8.png" alt="嵌套引用" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E5%B5%8C%E5%A5%97%E5%BC%95%E7%94%A8.png" class="lozad post-image"></p><hr><h2 id="5-代码块"><a href="#5-代码块" class="headerlink" title="5.代码块"></a>5.代码块</h2><h6 id="在发布一些技术文章会涉及展示代码的问题，这时候代码块就显得尤为重要。"><a href="#在发布一些技术文章会涉及展示代码的问题，这时候代码块就显得尤为重要。" class="headerlink" title="在发布一些技术文章会涉及展示代码的问题，这时候代码块就显得尤为重要。"></a>在发布一些技术文章会涉及展示代码的问题，这时候代码块就显得尤为重要。</h6><hr><ul><li>少量代码，单行使用，直接用`包裹起来就行了<pre class="highlight"><span class="line">` shaoliangdaima,danhangshiyong `</span><br></pre><h6 id="效果图：-5"><a href="#效果图：-5" class="headerlink" title="效果图："></a>效果图：</h6><img src="/hugoblog/%E4%BB%A3%E7%A0%81%E5%8D%95%E8%A1%8C.png" alt="代码单行" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E4%BB%A3%E7%A0%81%E5%8D%95%E8%A1%8C.png" class="lozad post-image"></li></ul><hr><ul><li>大量代码，需要多行使用，用```包裹起来<pre class="highlight"><span class="line">```</span><br><span class="line">    daliangdaima,xuyaoduohangshiyong</span><br><span class="line">    daliangdaima,xuyaoduohangshiyong</span><br><span class="line">    daliangdaima,xuyaoduohangshiyong</span><br><span class="line">    daliangdaima,xuyaoduohangshiyong</span><br><span class="line">    daliangdaima,xuyaoduohangshiyong</span><br></pre><pre class="highlight"><span class="line">###### 效果图：</span><br><span class="line">![多行代码](&#x2F;hugoblog&#x2F;多行代码.png)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 6.链接</span><br><span class="line">- 行内式</span><br><span class="line">###### 链接的文字放在[]中，链接地址放在随后的()中，链接也可以带title属性，链接地址后面空一格，然后用引号引起来</span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">[简书](https:&#x2F;&#x2F;www.jianshu.com &quot;创作你的创作&quot;),</span><br><span class="line">是一个创作社区,任何人均可以在其上进行创作。用户在简书上面可以方便的创作自己的作品,互相交流。 </span><br></pre></li></ul><hr><ul><li>参数式<h6 id="链接的文字放在-中，链接地址放在随后的-后，链接地址后面空一格，然后用引号引起来"><a href="#链接的文字放在-中，链接地址放在随后的-后，链接地址后面空一格，然后用引号引起来" class="headerlink" title="链接的文字放在[]中，链接地址放在随后的:后，链接地址后面空一格，然后用引号引起来"></a>链接的文字放在[]中，链接地址放在随后的:后，链接地址后面空一格，然后用引号引起来</h6></li></ul><pre class="highlight"><span class="line">[简书]: https://www.jianshu.com <span class="string">&quot;创作你的创作&quot;</span></span><br><span class="line">[简书]是一个创作社区,任何人均可以在其上进行创作。用户在简书上面可以方便的创作自己的作品,互相交流。</span><br><span class="line">//参数定义的其他写法</span><br><span class="line">[简书]: https://www.jianshu.com <span class="string">&#x27;创作你的创作&#x27;</span></span><br><span class="line">[简书]: https://www.jianshu.com (创作你的创作)</span><br><span class="line">[简书]: &lt;https://www.jianshu.com&gt; <span class="string">&quot;创作你的创作&quot;</span></span><br></pre><hr><h6 id="以上两种方式其效果图都是一样的，如下："><a href="#以上两种方式其效果图都是一样的，如下：" class="headerlink" title="以上两种方式其效果图都是一样的，如下："></a>以上两种方式其效果图都是一样的，如下：</h6><p><img src="/hugoblog/%E9%93%BE%E6%8E%A5.png" alt="链接" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E9%93%BE%E6%8E%A5.png" class="lozad post-image"></p><hr><h2 id="7-图片"><a href="#7-图片" class="headerlink" title="7.图片"></a>7.图片</h2><ul><li>行内式<h6 id="和链接的形式差不多，图片的名字放在-中，图片地址放在随后的-中，title属性（图片地址后面空一格，然后用引号引起来）-注意的是-前要加上"><a href="#和链接的形式差不多，图片的名字放在-中，图片地址放在随后的-中，title属性（图片地址后面空一格，然后用引号引起来）-注意的是-前要加上" class="headerlink" title="和链接的形式差不多，图片的名字放在[]中，图片地址放在随后的()中，title属性（图片地址后面空一格，然后用引号引起来）,注意的是[]前要加上!"></a>和链接的形式差不多，图片的名字放在[]中，图片地址放在随后的()中，title属性（图片地址后面空一格，然后用引号引起来）,注意的是[]前要加上!</h6></li></ul><pre class="highlight"><span class="line">![my-logo.png](https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 &quot;my-logo&quot;)</span><br></pre><ul><li>参数式<h6 id="图片的文字放在-中，图片地址放在随后的-后，title属性（图片地址后面空一格，然后用引号引起来）-注意引用图片的时候在-前要加上"><a href="#图片的文字放在-中，图片地址放在随后的-后，title属性（图片地址后面空一格，然后用引号引起来）-注意引用图片的时候在-前要加上" class="headerlink" title="图片的文字放在[]中，图片地址放在随后的:后，title属性（图片地址后面空一格，然后用引号引起来）,注意引用图片的时候在[]前要加上!"></a>图片的文字放在[]中，图片地址放在随后的:后，title属性（图片地址后面空一格，然后用引号引起来）,注意引用图片的时候在[]前要加上!</h6></li></ul><pre class="highlight"><span class="line">[my-logo.png]: https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 &quot;my-logo&quot;</span><br><span class="line"></span><br><span class="line">![my-logo.png]</span><br><span class="line"></span><br><span class="line">//参数定义的其他写法</span><br><span class="line">[my-logo.png]: https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 &#x27;my-logo&#x27;</span><br><span class="line"></span><br><span class="line">[my-logo.png]: https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 (my-logo)</span><br><span class="line"></span><br><span class="line">[my-logo.png]: &lt;https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&gt; &quot;my-logo&quot;</span><br></pre><h6 id="以上两种方式其效果图都是一样的，如下：-1"><a href="#以上两种方式其效果图都是一样的，如下：-1" class="headerlink" title="以上两种方式其效果图都是一样的，如下："></a>以上两种方式其效果图都是一样的，如下：</h6><p><img src="/hugoblog/%E5%8F%82%E6%95%B0%E5%BC%8F.png" alt="图片" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E5%8F%82%E6%95%B0%E5%BC%8F.png" class="lozad post-image"></p><hr><h2 id="8-分割线"><a href="#8-分割线" class="headerlink" title="8.分割线"></a>8.分割线</h2><h6 id="分割线可以由-（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以"><a href="#分割线可以由-（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以" class="headerlink" title="分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以"></a>分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</h6><pre class="highlight"><span class="line">---</span><br><span class="line">- - -</span><br><span class="line">------</span><br><span class="line">***</span><br><span class="line">* * *</span><br><span class="line">******</span><br><span class="line">___</span><br><span class="line">_ _ _</span><br><span class="line">______</span><br></pre><p>效果图：</p><p><img src="/hugoblog/%E5%88%86%E5%89%B2%E7%BA%BF.png" alt="分割线" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E5%88%86%E5%89%B2%E7%BA%BF.png" class="lozad post-image"></p><hr><h2 id="9-其他"><a href="#9-其他" class="headerlink" title="9.其他"></a>9.其他</h2><ul><li>强调字体<h6 id="一个星号或者是一个下划线包起来，会转换为倾斜，如果是2个，会转换为加粗"><a href="#一个星号或者是一个下划线包起来，会转换为倾斜，如果是2个，会转换为加粗" class="headerlink" title="一个星号或者是一个下划线包起来，会转换为倾斜，如果是2个，会转换为加粗"></a>一个星号或者是一个下划线包起来，会转换为<em>倾斜，如果是2个，会转换为<strong>加粗</h6><pre class="highlight"><span class="line"></span><br><span class="line">*md*    </span><br><span class="line">**md**</span><br><span class="line">_md_   </span><br><span class="line"> __md__</span><br></pre></li></ul><h6 id="效果图：-6"><a href="#效果图：-6" class="headerlink" title="效果图："></a>效果图：</h6><p><img src="/hugoblog/%E5%BC%BA%E8%B0%83%E5%AD%97%E4%BD%93.png" alt="强调字体" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E5%BC%BA%E8%B0%83%E5%AD%97%E4%BD%93.png" class="lozad post-image"></p><hr><ul><li>转义<h6 id="基本上和js转义一样-加需要转义的字符"><a href="#基本上和js转义一样-加需要转义的字符" class="headerlink" title="基本上和js转义一样,\加需要转义的字符"></a>基本上和js转义一样,\加需要转义的字符</h6></li></ul><pre class="highlight"><span class="line">\\</span><br><span class="line">\*</span><br><span class="line">\+</span><br><span class="line">\-</span><br><span class="line">\`</span><br><span class="line">\_</span><br></pre><ul><li>删除线<h6 id="用-把需要显示删除线的字符包裹起来"><a href="#用-把需要显示删除线的字符包裹起来" class="headerlink" title="用~~把需要显示删除线的字符包裹起来"></a>用~~把需要显示删除线的字符包裹起来</h6><pre class="highlight"><span class="line"></span><br><span class="line">~~删除~~</span><br></pre><h6 id="效果图：-7"><a href="#效果图：-7" class="headerlink" title="效果图："></a>效果图：</h6><img src="/hugoblog/%E5%88%A0%E9%99%A4.png" alt="删除" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E5%88%A0%E9%99%A4.png" class="lozad post-image"></li></ul><hr><h2 id="10-表格"><a href="#10-表格" class="headerlink" title="10.表格"></a>10.表格</h2><pre class="highlight"><span class="line"></span><br><span class="line">//例子一</span><br><span class="line">|<span class="number">123</span>|<span class="number">234</span>|<span class="number">345</span>|</span><br><span class="line">|:-|:-:|-:|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">//例子二</span><br><span class="line">|<span class="number">123</span>|<span class="number">234</span>|<span class="number">345</span>|</span><br><span class="line">|:---|:---:|---:|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">//例子三</span><br><span class="line"><span class="number">123</span>|<span class="number">234</span>|<span class="number">345</span></span><br><span class="line">:-|:-:|-:</span><br><span class="line">abc|bcd|cde</span><br><span class="line">abc|bcd|cde</span><br><span class="line">abc|bcd|cde</span><br></pre><h6 id="上面三个例子的效果一样，由此可得："><a href="#上面三个例子的效果一样，由此可得：" class="headerlink" title="上面三个例子的效果一样，由此可得："></a>上面三个例子的效果一样，由此可得：</h6><ol><li>表格的格式不一定要对的非常起，但是为了良好的变成风格，尽量对齐是最好的</li><li>分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中</li></ol><h6 id="效果图：-8"><a href="#效果图：-8" class="headerlink" title="效果图："></a>效果图：</h6><p><img src="/hugoblog/%E8%A1%A8%E6%A0%BC.png" alt="表格" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E8%A1%A8%E6%A0%BC.png" class="lozad post-image"></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>md5加密原理</title>
      <link href="/2018/12/31/md5%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"/>
      <url>/2018/12/31/md5%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h6 id="用户在进行注册和登录行为时-都会涉及到密码这一敏感参数的传递-出于保护隐私的需求-我们要对于接收到的敏感参数做加密处理-对于django自带的加密算法-步骤如下："><a href="#用户在进行注册和登录行为时-都会涉及到密码这一敏感参数的传递-出于保护隐私的需求-我们要对于接收到的敏感参数做加密处理-对于django自带的加密算法-步骤如下：" class="headerlink" title="用户在进行注册和登录行为时 都会涉及到密码这一敏感参数的传递 出于保护隐私的需求 我们要对于接收到的敏感参数做加密处理 对于django自带的加密算法  步骤如下："></a>用户在进行注册和登录行为时 都会涉及到密码这一敏感参数的传递 出于保护隐私的需求 我们要对于接收到的敏感参数做加密处理 对于django自带的加密算法  步骤如下：</h6><ol><li>首先导入django自带的加密算法模块<pre class="highlight"><span class="line"><span class="keyword">from</span> django.contrib.auth.hashers <span class="keyword">import</span> make_password, check_password</span><br></pre><pre class="highlight"><span class="line">make_password(参数1， 参数2， 参数3)</span><br><span class="line">参数1： 需要加密的字符串</span><br><span class="line"></span><br><span class="line">参数2： 是否每次都生成不同的加密串，默认为None, 如果给定任意一个字符串，    则表示每次生成相同的加密串。</span><br><span class="line"></span><br><span class="line">参数3： 表示加密算法，常见的加密算法如下： df2_sha256’,  ‘pbkdf2_sha1’,   ‘bcrypt_sha256’,  ‘unsalted_md5’ 等…</span><br></pre></li></ol><pre class="highlight"><span class="line">my_password = make_password(<span class="string">&#x27;1234567890&#x27;</span>, <span class="literal">None</span>, <span class="string">&#x27;pbkdf2_sha256&#x27;</span>)</span><br><span class="line">print(my_password)     </span><br></pre><h6 id="加密后的效果："><a href="#加密后的效果：" class="headerlink" title="加密后的效果："></a>加密后的效果：</h6><pre class="highlight"><span class="line">pbkdf2_sha256$<span class="number">12000</span>$xzMLhCNvQbb8$i1XDnJIpb/cRRGRX2x7Ym74RNfPRCUp5pbU6Sn+V3J0=</span><br></pre><pre class="highlight"><span class="line">check_password（参数1， 参数2）</span><br><span class="line">返回值： True或False 参数： 参数1：原始密码，参数2： 数据库查询出的密码</span><br></pre><pre class="highlight"><span class="line">isSame = check_password(<span class="string">&#x27;1234567890&#x27;</span>, sha_pwd )</span><br><span class="line">print(isSame)</span><br><span class="line"><span class="comment"># 如果为： True: 表示密码相同，如果为：False，则表示密码不相同。</span></span><br></pre><hr><h3 id="md5加密的内部逻辑"><a href="#md5加密的内部逻辑" class="headerlink" title="md5加密的内部逻辑"></a>md5加密的内部逻辑</h3><h4 id="转码时需要注意接收到的数据类型-如果是int需要强转"><a href="#转码时需要注意接收到的数据类型-如果是int需要强转" class="headerlink" title="转码时需要注意接收到的数据类型,如果是int需要强转"></a>转码时需要注意接收到的数据类型,如果是int需要强转</h4><pre class="highlight"><span class="line"><span class="comment">#导入加密库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># md5加密方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_password</span>(<span class="params">pass</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#生成md5对象</span></span><br><span class="line"></span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line"></span><br><span class="line"><span class="comment">#转码操作</span></span><br><span class="line"></span><br><span class="line">new_pass = str(<span class="keyword">pass</span>).encode(encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#加密操作</span></span><br><span class="line"></span><br><span class="line">md5.update(new_pass)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回密文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> md5.hexdigest()</span><br></pre><hr>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令</title>
      <link href="/2018/12/26/Linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/12/26/Linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-系统信息"><a href="#1-系统信息" class="headerlink" title="1.系统信息"></a>1.系统信息</h2><pre class="highlight"><span class="line">arch 显示机器的处理器架构</span><br><span class="line">uname -m 显示机器的处理器架构</span><br><span class="line">uname -r 显示正在使用的内核版本</span><br><span class="line">cat &#x2F;proc&#x2F;cpuinfo 显示CPU info的信息</span><br><span class="line">cat &#x2F;proc&#x2F;interrupts 显示中断</span><br><span class="line">cat &#x2F;proc&#x2F;meminfo 校验内存使用</span><br><span class="line">cat &#x2F;proc&#x2F;swaps 显示哪些swap被使用</span><br></pre><h2 id="2-关机"><a href="#2-关机" class="headerlink" title="2.关机"></a>2.关机</h2><pre class="highlight"><span class="line">shutdown -h now 关闭系统</span><br><span class="line">init 0 关闭系统</span><br><span class="line">telinit 0 关闭系统</span><br><span class="line">shutdown -h hours:minutes &amp; 按预定时间关闭系统</span><br><span class="line">shutdown -c 取消按预定时间关闭系统</span><br><span class="line">shutdown -r now 重启</span><br><span class="line">reboot 重启</span><br><span class="line">logout 注销</span><br></pre><h2 id="3-文件和目录"><a href="#3-文件和目录" class="headerlink" title="3.文件和目录"></a>3.文件和目录</h2><pre class="highlight"><span class="line">cd &#x2F;home 进入 &#39;&#x2F; home&#39; 目录&#39; </span><br><span class="line">cd .. 返回上一级目录 </span><br><span class="line">cd ..&#x2F;.. 返回上两级目录 </span><br><span class="line">cd 进入个人的主目录 </span><br><span class="line">cd ~user1 进入个人的主目录 </span><br><span class="line">cd - 返回上次所在的目录</span><br><span class="line"></span><br><span class="line">pwd 显示工作路径 </span><br><span class="line">ls 查看目录中的文件 </span><br><span class="line">ls -F 查看目录中的文件 </span><br><span class="line">ls -l 显示文件和目录的详细资料 </span><br><span class="line">ls -a 显示隐藏文件 </span><br><span class="line">ls [0-9] 显示包含数字的文件名和目录名 </span><br><span class="line">tree 显示文件和目录由根目录开始的树形结构</span><br><span class="line">lstree 显示文件和目录由根目录开始的树形结构</span><br><span class="line"></span><br><span class="line">mkdir dir1 创建一个叫做 &#39;dir1&#39; 的目录&#39; </span><br><span class="line">mkdir dir1 dir2 同时创建两个目录 </span><br><span class="line">mkdir -p &#x2F;tmp&#x2F;dir1&#x2F;dir2 创建一个目录树 </span><br><span class="line"></span><br><span class="line">rm -f file1 删除一个叫做 &#39;file1&#39; 的文件&#39; </span><br><span class="line">rmdir dir1 删除一个叫做 &#39;dir1&#39; 的目录&#39; </span><br><span class="line">rm -rf dir1 删除一个叫做 &#39;dir1&#39; 的目录并同时删除其内容 </span><br><span class="line">rm -rf dir1 dir2 同时删除两个目录及它们的内容 </span><br><span class="line">mv dir1 new_dir 重命名&#x2F;移动 一个目录 </span><br><span class="line"></span><br><span class="line">cp file1 file2 复制一个文件 </span><br><span class="line">cp dir&#x2F;* . 复制一个目录下的所有文件到当前工作目录 </span><br><span class="line">cp -a &#x2F;tmp&#x2F;dir1 . 复制一个目录到当前工作目录 </span><br><span class="line">cp -a dir1 dir2 复制一个目录</span><br><span class="line">cp -r dir1 dir2 复制一个目录及子目录</span><br><span class="line"></span><br><span class="line">ln -s file1 lnk1 创建一个指向文件或目录的软链接 </span><br><span class="line">ln file1 lnk1 创建一个指向文件或目录的物理链接 </span><br><span class="line">touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) </span><br></pre><h2 id="4-文件搜索"><a href="#4-文件搜索" class="headerlink" title="4.文件搜索"></a>4.文件搜索</h2><pre class="highlight"><span class="line">find &#x2F; -name file1 从 &#39;&#x2F;&#39; 开始进入根文件系统搜索文件和目录 </span><br><span class="line">find &#x2F; -user user1 搜索属于用户 &#39;user1&#39; 的文件和目录 </span><br><span class="line">find &#x2F;home&#x2F;user1 -name *.bin 在目录 &#39;&#x2F; home&#x2F;user1&#39; 中搜索带有&#39;.bin&#39; 结尾的文件 </span><br><span class="line">find &#x2F;usr&#x2F;bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 </span><br><span class="line">find &#x2F;usr&#x2F;bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 </span><br><span class="line">find &#x2F; -name *.rpm -exec chmod 755 &#39;&#123;&#125;&#39; \; 搜索以 &#39;.rpm&#39; 结尾的文件并定义其权限 </span><br><span class="line">find &#x2F; -xdev -name *.rpm 搜索以 &#39;.rpm&#39; 结尾的文件，忽略光驱、捷盘等可移动设备 </span><br><span class="line">locate *.ps 寻找以 &#39;.ps&#39; 结尾的文件 - 先运行 &#39;updatedb&#39; 命令 </span><br><span class="line">whereis halt 显示一个二进制文件、源码或man的位置 </span><br><span class="line">which halt 显示一个二进制文件或可执行文件的完整路径</span><br></pre><h2 id="5-挂载系统"><a href="#5-挂载系统" class="headerlink" title="5.挂载系统"></a>5.挂载系统</h2><pre class="highlight"><span class="line">mount &#x2F;dev&#x2F;hda2 &#x2F;mnt&#x2F;hda2 挂载一个叫做hda2的盘 - 确定目录 &#39;&#x2F; mnt&#x2F;hda2&#39; 已经存在 </span><br><span class="line">umount &#x2F;dev&#x2F;hda2 卸载一个叫做hda2的盘 - 先从挂载点 &#39;&#x2F; mnt&#x2F;hda2&#39; 退出 </span><br><span class="line">fuser -km &#x2F;mnt&#x2F;hda2 当设备繁忙时强制卸载 </span><br><span class="line">umount -n &#x2F;mnt&#x2F;hda2 运行卸载操作而不写入 &#x2F;etc&#x2F;mtab 文件- 当文件为只读或当磁盘写满时非常有用 </span><br><span class="line">mount &#x2F;dev&#x2F;fd0 &#x2F;mnt&#x2F;floppy 挂载一个软盘 </span><br><span class="line">mount &#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom 挂载一个cdrom或dvdrom </span><br><span class="line">mount &#x2F;dev&#x2F;hdc &#x2F;mnt&#x2F;cdrecorder 挂载一个cdrw或dvdrom </span><br><span class="line">mount &#x2F;dev&#x2F;hdb &#x2F;mnt&#x2F;cdrecorder 挂载一个cdrw或dvdrom </span><br><span class="line">mount -o loop file.iso &#x2F;mnt&#x2F;cdrom 挂载一个文件或ISO镜像文件 </span><br><span class="line">mount -t vfat &#x2F;dev&#x2F;hda5 &#x2F;mnt&#x2F;hda5 挂载一个Windows FAT32文件系统 </span><br><span class="line">mount &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;usbdisk 挂载一个usb 捷盘或闪存设备 </span><br></pre><h2 id="6-RPM管理工具"><a href="#6-RPM管理工具" class="headerlink" title="6.RPM管理工具"></a>6.RPM管理工具</h2><pre class="highlight"><span class="line">rpm -ivh package.rpm 安装一个rpm包 </span><br><span class="line">rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告 </span><br><span class="line">rpm -U package.rpm 更新一个rpm包但不改变其配置文件 </span><br><span class="line">rpm -F package.rpm 更新一个确定已经安装的rpm包 </span><br><span class="line">rpm -e package_name.rpm 删除一个rpm包 </span><br><span class="line">rpm -qa 显示系统中所有已经安装的rpm包 </span><br><span class="line">rpm -qa | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的rpm包 </span><br><span class="line">rpm -qi package_name 获取一个已安装包的特殊信息 </span><br><span class="line">rpm -qg &quot;System Environment&#x2F;Daemons&quot; 显示一个组件的rpm包 </span><br><span class="line">rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表 </span><br><span class="line">rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表 </span><br><span class="line">rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表 </span><br><span class="line">rpm -q package_name --whatprovides 显示一个rpm包所占的体积 </span><br><span class="line">rpm -q package_name --scripts 显示在安装&#x2F;删除期间所执行的脚本l </span><br><span class="line">rpm -q package_name --changelog 显示一个rpm包的修改历史 </span><br><span class="line">rpm -qf &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf 确认所给的文件由哪个rpm包所提供 </span><br><span class="line">rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表 </span><br><span class="line">rpm --import &#x2F;media&#x2F;cdrom&#x2F;RPM-GPG-KEY 导入公钥数字证书 </span><br><span class="line">rpm --checksig package.rpm 确认一个rpm包的完整性 </span><br><span class="line">rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性 </span><br><span class="line">rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 </span><br><span class="line">rpm -Va 检查系统中所有已安装的rpm包- 小心使用 </span><br><span class="line">rpm -Vp package.rpm 确认一个rpm包还未安装 </span><br><span class="line">rpm2cpio package.rpm | cpio --extract --make-directories bin 从一个rpm包运行可执行文件 </span><br><span class="line">rpm -ivh &#x2F;usr&#x2F;src&#x2F;redhat&#x2F;RPMS&#x2F;arch&#x2F;package.rpm 从一个rpm源码安装一个构建好的包 </span><br><span class="line">rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包</span><br></pre><h2 id="7-YUM管理工具"><a href="#7-YUM管理工具" class="headerlink" title="7.YUM管理工具"></a>7.YUM管理工具</h2><pre class="highlight"><span class="line">yum install package_name 下载并安装一个rpm包 </span><br><span class="line">yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 </span><br><span class="line">yum update package_name.rpm 更新当前系统中所有安装的rpm包 </span><br><span class="line">yum update package_name 更新一个rpm包 </span><br><span class="line">yum remove package_name 删除一个rpm包 </span><br><span class="line">yum list 列出当前系统中安装的所有包 </span><br><span class="line">yum search package_name 在rpm仓库中搜寻软件包 </span><br><span class="line">yum clean packages 清理rpm缓存删除下载的包 </span><br><span class="line">yum clean headers 删除所有头文件 </span><br><span class="line">yum clean all 删除所有缓存的包和头文件</span><br></pre><h2 id="38查看文件内容"><a href="#38查看文件内容" class="headerlink" title="38查看文件内容"></a>38查看文件内容</h2><pre class="highlight"><span class="line">cat file1 从第一个字节开始正向查看文件的内容 </span><br><span class="line">tac file1 从最后一行开始反向查看一个文件的内容 </span><br><span class="line">more file1 查看一个长文件的内容 </span><br><span class="line">less file1 类似于 &#39;more&#39; 命令，但是它允许在文件中和正向操作一样的反向操作 </span><br><span class="line">head -2 file1 查看一个文件的前两行 </span><br><span class="line">tail -2 file1 查看一个文件的最后两行 </span><br><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;messages 实时查看被添加到一个文件中的内容</span><br></pre><h2 id="9-字符设置、文件格式转换"><a href="#9-字符设置、文件格式转换" class="headerlink" title="9.字符设置、文件格式转换"></a>9.字符设置、文件格式转换</h2><pre class="highlight"><span class="line">dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX </span><br><span class="line">unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS </span><br><span class="line">recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html </span><br><span class="line">recode -l | more 显示所有允许的转换格式</span><br><span class="line"></span><br></pre><h2 id="10-备份"><a href="#10-备份" class="headerlink" title="10.备份"></a>10.备份</h2><pre class="highlight"><span class="line"></span><br><span class="line">dump -0aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home 制作一个 &#39;&#x2F;home&#39; 目录的完整备份 </span><br><span class="line">dump -1aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home 制作一个 &#39;&#x2F;home&#39; 目录的交互式备份 </span><br><span class="line">restore -if &#x2F;tmp&#x2F;home0.bak 还原一个交互式备份 </span><br><span class="line">rsync -rogpav --delete &#x2F;home &#x2F;tmp 同步两边的目录 </span><br><span class="line">rsync -rogpav -e ssh --delete &#x2F;home ip_address:&#x2F;tmp 通过SSH通道</span><br><span class="line">rsync rsync -az -e ssh --delete ip_addr:&#x2F;home&#x2F;public &#x2F;home&#x2F;local 通过ssh和压缩将一个远程目录同步到本地目录 </span><br><span class="line">rsync -az -e ssh --delete &#x2F;home&#x2F;local ip_addr:&#x2F;home&#x2F;public 通过ssh和压缩将本地目录同步到远程目录 </span><br><span class="line">dd bs&#x3D;1M if&#x3D;&#x2F;dev&#x2F;hda | gzip | ssh user@ip_addr &#39;dd of&#x3D;hda.gz&#39; 通过ssh在远程主机上执行一次备份本地磁盘的操作 </span><br><span class="line">dd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D;&#x2F;tmp&#x2F;file1 备份磁盘内容到一个文件 </span><br><span class="line">tar -Puf backup.tar &#x2F;home&#x2F;user 执行一次对 &#39;&#x2F;home&#x2F;user&#39; 目录的交互式备份操作 </span><br><span class="line">( cd &#x2F;tmp&#x2F;local&#x2F; &amp;&amp; tar c . ) | ssh -C user@ip_addr &#39;cd &#x2F;home&#x2F;share&#x2F; &amp;&amp; tar x -p&#39; 通过ssh在远程目录中复制一个目录内容 </span><br><span class="line">( tar c &#x2F;home ) | ssh -C user@ip_addr &#39;cd &#x2F;home&#x2F;backup-home &amp;&amp; tar x -p&#39; 通过ssh在远程目录中复制一个本地目录 </span><br><span class="line">tar cf - . | (cd &#x2F;tmp&#x2F;backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 </span><br><span class="line">find &#x2F;home&#x2F;user1 -name &#39;*.txt&#39; | xargs cp -av --target-directory&#x3D;&#x2F;home&#x2F;backup&#x2F; --parents 从一个目录查找并复制所有以 &#39;.txt&#39; 结尾的文件到另一个目录 </span><br><span class="line">find &#x2F;var&#x2F;log -name &#39;*.log&#39; | tar cv --files-from&#x3D;- | bzip2 &gt; log.tar.bz2 查找所有以 &#39;.log&#39; 结尾的文件并做成一个bzip包 </span><br><span class="line">dd if&#x3D;&#x2F;dev&#x2F;hda of&#x3D;&#x2F;dev&#x2F;fd0 bs&#x3D;512 count&#x3D;1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 </span><br><span class="line">dd if&#x3D;&#x2F;dev&#x2F;fd0 of&#x3D;&#x2F;dev&#x2F;hda bs&#x3D;512 count&#x3D;1 从已经保存到软盘的备份中恢复MBR内容</span><br></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT使用</title>
      <link href="/2018/12/21/JWT%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/12/21/JWT%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h6 id="Json-Web-Token-JWT-是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准-JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。"><a href="#Json-Web-Token-JWT-是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准-JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。" class="headerlink" title="Json Web Token(JWT) 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准,JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。"></a>Json Web Token(JWT) 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准,JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</h6><hr><h2 id="什么场景使用JWTPermalink"><a href="#什么场景使用JWTPermalink" class="headerlink" title="什么场景使用JWTPermalink"></a>什么场景使用JWTPermalink</h2><h6 id="在前后端分离情况下前端的每一次请求都会携带指定url地址和参数，-从而很可能被不法分子根据指定的url来仿照前端直接请求后端，造成性能与数据的流失-，-只需更换一些参数就能获取其他用户的数据-岂不是很不安全"><a href="#在前后端分离情况下前端的每一次请求都会携带指定url地址和参数，-从而很可能被不法分子根据指定的url来仿照前端直接请求后端，造成性能与数据的流失-，-只需更换一些参数就能获取其他用户的数据-岂不是很不安全" class="headerlink" title="在前后端分离情况下前端的每一次请求都会携带指定url地址和参数， 从而很可能被不法分子根据指定的url来仿照前端直接请求后端，造成性能与数据的流失 ， 只需更换一些参数就能获取其他用户的数据 岂不是很不安全"></a>在前后端分离情况下前端的每一次请求都会携带指定url地址和参数， 从而很可能被不法分子根据指定的url来仿照前端直接请求后端，造成性能与数据的流失 ， 只需更换一些参数就能获取其他用户的数据 岂不是很不安全</h6><h6 id="我们需要在请求的时候加一些身份验证，保证后端服务器不能被第三方访问"><a href="#我们需要在请求的时候加一些身份验证，保证后端服务器不能被第三方访问" class="headerlink" title="我们需要在请求的时候加一些身份验证，保证后端服务器不能被第三方访问"></a>我们需要在请求的时候加一些身份验证，保证后端服务器不能被第三方访问</h6><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/jwt.jpg" class="lozad post-image"src="/hugoblog/jwt.jpg"></p><h5 id="生成jwt-Permalink-amp-使用jwt模块-jwt-encode-参数-秘钥-加密方式"><a href="#生成jwt-Permalink-amp-使用jwt模块-jwt-encode-参数-秘钥-加密方式" class="headerlink" title="生成jwt:Permalink&amp;使用jwt模块 jwt.encode(参数,秘钥,加密方式)"></a>生成jwt:Permalink&amp;使用jwt模块 jwt.encode(参数,秘钥,加密方式)</h5><pre class="highlight"><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># playload 载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</span></span><br><span class="line">playload = &#123;</span><br><span class="line">    <span class="comment"># 创建一个过期时间</span></span><br><span class="line">    <span class="string">&#x27;exp&#x27;</span>: int((datetime.datetime.now() + datetime.timedelta(hours=<span class="number">4</span>)).timestamp()),</span><br><span class="line">    <span class="string">&#x27;data&#x27;</span>: &#123;<span class="string">&#x27;uid&#x27;</span>: user.id&#125;</span><br><span class="line">&#125;</span><br><span class="line">encode_jwt = jwt.encode(playload, <span class="string">&#x27;秘钥&#x27;</span>, algorithm=<span class="string">&#x27;HS256&#x27;</span>)</span><br><span class="line"><span class="comment">#加密后是二进制形式 要转码为str</span></span><br><span class="line">encode_str = str(encode_jwt, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> Response(&#123;<span class="string">&quot;code&quot;</span>: <span class="number">200</span>, <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;登录成功&quot;</span>,<span class="string">&#x27;jwt&#x27;</span>:encode_str&#125;)</span><br></pre><hr><h5 id="这样在登录的时候就将认证的jwt传递给前端并且有过期时间-当jwt过期的时候就重新登录-如何验证jwt"><a href="#这样在登录的时候就将认证的jwt传递给前端并且有过期时间-当jwt过期的时候就重新登录-如何验证jwt" class="headerlink" title="这样在登录的时候就将认证的jwt传递给前端并且有过期时间 当jwt过期的时候就重新登录   如何验证jwt:"></a>这样在登录的时候就将认证的jwt传递给前端并且有过期时间 当jwt过期的时候就重新登录   如何验证jwt:</h5><pre class="highlight"><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator  <span class="comment"># 导入django自带的方法装饰器模块</span></span><br><span class="line"><span class="comment"># 定义权限检测装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warpper</span>(<span class="params">request,*args,**kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 拦截获取参数</span></span><br><span class="line">        uid=request.GET.get(<span class="string">&#x27;uid&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">        myjwt=request.GET.get(<span class="string">&#x27;jwt&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 对jwt进行解码  algorithms=[&#x27;HS256&#x27;] 加密方式 HS256</span></span><br><span class="line">            <span class="comment"># 如果jwt过期会报错 就需要使用try</span></span><br><span class="line">            decode_jwt = jwt.decode(myjwt, <span class="string">&#x27;秘钥&#x27;</span>, algorithms=[<span class="string">&#x27;HS256&#x27;</span>])</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">401</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;您的秘钥已失效&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断jwt内的参数是否被篡改</span></span><br><span class="line">        <span class="keyword">if</span> int(uid)!= int(decode_jwt[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;uid&#x27;</span>]):</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;code&#x27;</span>:<span class="number">401</span>,<span class="string">&#x27;msg&#x27;</span>:<span class="string">&#x27;您的秘钥无权限&#x27;</span>&#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> func(request,*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> warpper</span><br><span class="line"></span><br></pre><h3 id="创建一个装饰器-在需要验证的函数上方进行拦截验证"><a href="#创建一个装饰器-在需要验证的函数上方进行拦截验证" class="headerlink" title="创建一个装饰器 在需要验证的函数上方进行拦截验证"></a>创建一个装饰器 在需要验证的函数上方进行拦截验证</h3><pre class="highlight"><span class="line"><span class="comment"># 当使用的是类方法需要这样注册装饰器</span></span><br><span class="line"><span class="meta">@method_decorator(my_decorator)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">slef,request</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre>]]></content>
      
      
      <categories>
          
          <category> jwt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>json的转换</title>
      <link href="/2018/12/18/json%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
      <url>/2018/12/18/json%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h4 id="在vue中-我们需要将数据转成json格式和将json格式转成字符串"><a href="#在vue中-我们需要将数据转成json格式和将json格式转成字符串" class="headerlink" title="在vue中,我们需要将数据转成json格式和将json格式转成字符串"></a>在vue中,我们需要将数据转成json格式和将json格式转成字符串</h4><pre class="highlight"><span class="line">改为json格式：JSON.stringify()</span><br><span class="line">将json格式转为字典格式：JSON.parse()</span><br></pre><hr><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    商品名称：</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;name&quot;</span> placeholder=<span class="string">&quot;请输入商品名称&quot;</span>&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    商品价格：</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;input type=<span class="string">&quot;number&quot;</span> v-model=<span class="string">&quot;price&quot;</span> placeholder=<span class="string">&quot;请输入商品价格&quot;</span>&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    商品颜色：</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;color&quot;</span> placeholder=<span class="string">&quot;请输入商品颜色&quot;</span>&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    商品尺寸：</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;size&quot;</span> placeholder=<span class="string">&quot;请输入商品尺寸&quot;</span>&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    商品季节：</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;season&quot;</span> placeholder=<span class="string">&quot;请输入商品季节&quot;</span>&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt; </span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;Button color=&quot;blue&quot; @click=&quot;submit&quot;&gt;添加商品&lt;/Button&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;      </span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;  </span><br><span class="line">      name:<span class="string">&quot;&quot;</span>,//商品名</span><br><span class="line">      price:<span class="number">0</span>,//商品价格</span><br><span class="line">      color:<span class="string">&quot;&quot;</span>,//商品颜色</span><br><span class="line">      size:<span class="string">&quot;&quot;</span>,//商品尺寸</span><br><span class="line">      season:<span class="string">&quot;&quot;</span>,//商品季节</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">      //进行添加商品</span><br><span class="line">      submit()&#123;</span><br><span class="line">          //将季节，颜色规格等字段转换为json</span><br><span class="line">          var param = &#123;&#125;;</span><br><span class="line">          param[<span class="string">&#x27;color&#x27;</span>] = this.color;</span><br><span class="line">          param[<span class="string">&#x27;size&#x27;</span>] = this.size;</span><br><span class="line">          param[<span class="string">&#x27;season&#x27;</span>] = this.season;</span><br><span class="line">          console.log(param);         //&#123;color: <span class="string">&quot;green&quot;</span>, size: <span class="string">&quot;xxl&quot;</span>, season: <span class="string">&quot;夏季&quot;</span>&#125;</span><br><span class="line">          //将字段转换为json类型      JSON.stringify</span><br><span class="line">          param = JSON.stringify(param)</span><br><span class="line">          console.log(param)          //&#123;<span class="string">&quot;color&quot;</span>:<span class="string">&quot;green&quot;</span>,<span class="string">&quot;size&quot;</span>:<span class="string">&quot;xxl&quot;</span>,<span class="string">&quot;season&quot;</span>:<span class="string">&quot;夏季&quot;</span>&#125;</span><br><span class="line">          //将json类型转为字符串      JSON.parse</span><br><span class="line">          // param = JSON.parse(param)</span><br><span class="line">          // console.log(param)          //&#123;color: <span class="string">&quot;gray&quot;</span>, size: <span class="string">&quot;xxl&quot;</span>, season: <span class="string">&quot;秋季&quot;</span>&#125;</span><br><span class="line">          this.axios(&#123;</span><br><span class="line">              url: <span class="string">&quot;http://localhost:8000/insertgoods/&quot;</span>,</span><br><span class="line">              method: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">              params:&#123;</span><br><span class="line">                  name:this.name,</span><br><span class="line">                  price:this.price,</span><br><span class="line">                  params:param,</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;).then(resp =&gt; &#123;</span><br><span class="line">              console.log(resp)</span><br><span class="line">              this.$Message(resp.data.message)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP与HTTPS</title>
      <link href="/2018/12/12/HTTP%E4%B8%8EHTTPS/"/>
      <url>/2018/12/12/HTTP%E4%B8%8EHTTPS/</url>
      
        <content type="html"><![CDATA[<p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS9IVFRQLXZzLUhUVFBTLnBuZw?x-oss-process=image/format,png" class="lozad post-image"src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS9IVFRQLXZzLUhUVFBTLnBuZw?x-oss-process=image/format,png"></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>HTTP</strong>（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。</p><p>HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 HTTP 服务。</p><p>HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><p><strong>HTTPS</strong>（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p><p><strong><em>HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：</em></strong></p><ol><li>TCP 三次同步握手</li><li>客户端验证服务器数字证书</li><li>DH 算法协商对称加密算法的密钥、hash 算法的密钥</li><li>SSL 安全加密隧道协商完成</li><li>网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。<h1 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h1></li></ol><ul><li>HTTP <strong>明文传输</strong>，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是<strong>加密</strong>的，安全性较好。<br>使用 HTTPS 协议需要到 <strong>CA（Certificate Authority，数字证书认证机构） 申请证书</strong>，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li><li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li><li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 <strong>80</strong>，后者是 <strong>443</strong>。</li><li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li><li><h1 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h1></li></ul><p><strong>在TCP/IP协议中，TCP协议通过三次握手建立一个可靠的连接</strong><br><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS8wNTIzNDIzMy1lZWQ2ZGRjYmE5M2M0MmJlODg0N2U5OGQ2ZGE2MjgwMi5qcGc?x-oss-process=image/format,png" class="lozad post-image"src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS8wNTIzNDIzMy1lZWQ2ZGRjYmE5M2M0MmJlODg0N2U5OGQ2ZGE2MjgwMi5qcGc?x-oss-process=image/format,png"></p><ul><li><strong>第一次握手</strong>：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认</li><li><strong>第二次握手</strong>：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态</li><li><strong>第三次握手</strong>：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手<br><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS9kZmZkZmYucG5n?x-oss-process=image/format,png" class="lozad post-image"src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS9kZmZkZmYucG5n?x-oss-process=image/format,png"><h1 id="客户端在使用HTTPS方式与Web服务器通信时的步骤"><a href="#客户端在使用HTTPS方式与Web服务器通信时的步骤" class="headerlink" title="客户端在使用HTTPS方式与Web服务器通信时的步骤"></a>客户端在使用HTTPS方式与Web服务器通信时的步骤</h1></li></ul><p><strong>1. 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。<br>2. Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。<br>3. 客户端的浏览器与Web服务器开始协商SSL/TLS连接的安全等级，也就是信息加密的等级。<br>4. 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。<br>5. Web服务器利用自己的私钥解密出会话密钥。<br>6. Web服务器利用会话密钥加密与客户端之间的通信。</strong></p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdn.net/20180920154005922?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" class="lozad post-image"src="https://img-blog.csdn.net/20180920154005922?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdn.net/20180920154006193?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" class="lozad post-image"src="https://img-blog.csdn.net/20180920154006193?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p> <strong>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，但他大幅增加了中间人攻击的成本</strong></p><h1 id="CA证书的申请及其使用过程"><a href="#CA证书的申请及其使用过程" class="headerlink" title="CA证书的申请及其使用过程"></a>CA证书的申请及其使用过程</h1><p>上面客户端使用HTTPS与服务器通信中使用到了CA认证，这里可能大家会问为什么不直接使用非对称加密的形式直接进行，首先这里先介绍下非对称加密。</p><p>非对称加密：客户端和服务端均拥有一个公有密匙和一个私有密匙。公有密匙可以对外暴露，而私有密匙只有自己可见。</p><p>使用公有密匙加密的消息，只有对应的私有密匙才能解开。反过来，使用私有密匙加密的消息，只有公有密匙才能解开。这样客户端在发送消息前，先用服务器的公匙对消息进行加密，服务器收到后再用自己的私匙进行解密。<br>重做：</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20190426151155832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2,size_16,color_FFFFFF,t_70" class="lozad post-image"src="https://img-blog.csdnimg.cn/20190426151155832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2,size_16,color_FFFFFF,t_70"></p><h2 id="非对称加密的优点："><a href="#非对称加密的优点：" class="headerlink" title="非对称加密的优点："></a>非对称加密的优点：</h2><p>非对称加密采用公有密匙和私有密匙的方式，解决了http中消息保密性问题，而且使得私有密匙泄露的风险降低。</p><p>因为公匙加密的消息只有对应的私匙才能解开，所以较大程度上保证了消息的来源性以及消息的准确性和完整性。</p><h2 id="非对称加密的缺点："><a href="#非对称加密的缺点：" class="headerlink" title="非对称加密的缺点："></a>非对称加密的缺点：</h2><p>非对称加密时需要使用到接收方的公匙对消息进行加密，但是公匙不是保密的，任何人都可以拿到，中间人也可以。那么中间人可以做两件事，第一件是中间人可以在客户端与服务器交换公匙的时候，将客户端的公匙替换成自己的。这样服务器拿到的公匙将不是客户端的，而是中间人的。服务器也无法判断公匙来源的正确性。第二件是中间人可以不替换公匙，但是他可以截获客户端发来的消息，然后篡改，然后用服务器的公匙加密再发往服务器，服务器将收到错误的消息。</p><p>非对称加密的性能相对对称加密来说会慢上几倍甚至几百倍，比较消耗系统资源。正是因为如此，https将两种加密结合了起来。</p><p>为了应对上面非对称加密带来的问题，我们就引入了<strong>数字证书与数字签名</strong></p><p>故CA认证介入我们的HTTPS连接的过程如下：</p><p>1、服务器拥有自己的私钥与公钥</p><p>2、服务器将公钥交给CA认证机构，请求给予一份数字证书</p><p>3、CA认证机构生成数字证书，并颁发给服务器</p><p>4、服务器将带有公钥信息的数字证书发给客户端</p><p>5、进入客户端生成对称密钥再进行对接的过程……</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20190426152200712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2,size_16,color_FFFFFF,t_70" class="lozad post-image"src="https://img-blog.csdnimg.cn/20190426152200712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2,size_16,color_FFFFFF,t_70"></p><h1 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h1><p> 　　<strong>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</strong></p><p>　　（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p><p>　　（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p><p>　　（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p><p>　    （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p><p>　　（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p><p><strong><em>实践中建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将<a href="http://www.baidu.com改为//www.baidu.com%E3%80%82%E7%84%B6%E5%90%8E%E5%BD%93%E7%94%A8%E6%88%B7%E4%BB%8Ehttp%E7%9A%84%E5%85%A5%E5%8F%A3%E8%BF%9B%E5%85%A5%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%E6%97%B6%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%B0%B1%E6%98%AFhttp%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%94%A8%E6%88%B7%E6%98%AF%E4%BB%8Ehttps%E7%9A%84%E5%85%A5%E5%8F%A3%E8%BF%9B%E5%85%A5%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%8D%B3%E4%BD%BFhttps%E7%9A%84">http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的</a></em></strong></p><h1 id="SSL与TLS的区别"><a href="#SSL与TLS的区别" class="headerlink" title="SSL与TLS的区别"></a>SSL与TLS的区别</h1><p><strong>SSL</strong>：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。</p><p><strong>TLS</strong>：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。</p><h1 id="如何优化HTTPS的速度"><a href="#如何优化HTTPS的速度" class="headerlink" title="如何优化HTTPS的速度"></a>如何优化HTTPS的速度</h1><p><strong>1、HSTS重定向技术</strong></p><p>HSTS（HTTP Strict Transport Security）技术，启用HSTS后，将保证浏览器始终连接到网站的 HTTPS 加密版本。</p><ol><li><p>用户在浏览器里输入 HTTP 协议进行访问时，浏览器会自动将 HTTP 转换为 HTTPS 进行访问，确保用户访问安全；</p></li><li><p>省去301跳转的出现，缩短访问时间；</p></li><li><p>能阻止基于 SSL Strip 的中间人攻击，万一证书有错误，则显示错误，用户不能回避警告，从而能够更加有效安全的保障用户的访问。</p></li></ol><p><strong>2、TLS握手优化</strong></p><p>  在应用数据之前，客户端必须与服务端协商密钥、加密算法等信息，服务端还要把自己的证书发给客户端表明其身份，这些环节构成 TLS 握手过程。</p><p>采用 False Start （抢先开始）技术，浏览器在与服务器完成 TLS 握手前，就开始发送请求数据，服务器在收到这些数据后，完成 TLS 握手的同时，开始发送响应数据。</p><p>开启 False Start 功能后，数据传输时间将进一步缩短。</p><p><strong>3、Session Identifier（会话标识符）复用</strong></p><p>如果用户的一个业务请求包含了多条的加密流，客户端与服务器将会反复握手，必定会导致更多的时间损耗。或者某些特殊情况导致了对话突然中断，双方就需要重新握手，增加了用户访问时间。<br>（1）服务器为每一次的会话都生成并记录一个 ID 号，然后发送给客户端；</p><p>（2）如果客户端发起重新连接，则只要向服务器发送该 ID 号；</p><p>（3）服务器收到客户端发来的 ID 号，然后查找自己的会话记录，匹配 ID 之后，双方就可以重新使用之前的对称加密秘钥进行数据加密传输，而不必重新生成，减少交互时间。</p><p><strong>4、开启OSCP Stapling，提高TLS握手效率</strong></p><p>采用OCSP Stapling ，提升 HTTPS 性能。服务端主动获取 OCSP 查询结果并随着证书一起发送给客户端，从而客户端可直接通过 Web Server 验证证书，提高 TLS 握手效率。</p><p>服务器模拟浏览器向 CA 发起请求，并将带有 CA 机构签名的 OCSP 响应保存到本地，然后在与客户端握手阶段，将 OCSP 响应下发给浏览器，省去浏览器的在线验证过程。由于浏览器不需要直接向 CA 站点查询证书状态，这个功能对访问速度的提升非常明显。</p><p><strong>5、完全前向加密PFS，保护用户数据，预防私钥泄漏</strong></p><p>非对称加密算法 RSA，包含了公钥、私钥，其中私钥是保密不对外公开的，由于此算法既可以用于加密也可以用于签名，所以用途甚广，但是还是会遇到一些问题：</p><p>（1） 假如我是一名黑客，虽然现在我不知道私钥，但是我可以先把客户端与服务器之前的传输数据（已加密）全部保存下来</p><p>（2）如果某一天，服务器维护人员不小心把私钥泄露了，或者服务器被我攻破获取到了私钥</p><p>（3）那我就可以利用这个私钥，破解掉之前已被我保存的数据，从中获取有用的信息</p><p>所以为了防止上述现象发生，我们必须保护好自己的私钥。</p><p><strong><em>如果私钥确实被泄漏了，那我们改如何补救呢？那就需要PFS（perfect forward secrecy）完全前向保密功能，此功能用于客户端与服务器交换对称密钥，起到前向保密的作用，也即就算私钥被泄漏，黑客也无法破解先前已加密的数据。维基解释是：长期使用的主密钥泄漏不会导致过去的会话密钥泄漏</em></strong></p><p> <strong><em>实现此功能需要服务器支持以下算法和签名组合：</em></strong></p><p>（1）ECDHE 密钥交换、RSA 签名；<br>（2）ECDHE 密钥交换、ECDSA 签名；</p><hr><hr><h1 id="面试常见问题，HTTPS优化总结易记版："><a href="#面试常见问题，HTTPS优化总结易记版：" class="headerlink" title="面试常见问题，HTTPS优化总结易记版："></a>面试常见问题，HTTPS优化总结易记版：</h1><p><strong>1、HSTS重定向技术：将http自动转换为https，减少301重定向<br>2、TLS握手优化：在TLS握手完成前客户端就提前向服务器发送数据<br>3、会话标识符：服务器记录下与某客户端的会话ID，下次连接客户端发ID过来就可以直接用之前的私钥交流了<br>4、OSCP Stapling：服务器将带有 CA 机构签名的 OCSP 响应在握手时发给客户端，省的客户端再去CA查询<br>5、完全前向加密PFS：使用更牛逼复杂的秘钥算法</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django中间件</title>
      <link href="/2018/12/04/Django%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2018/12/04/Django%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h2><h6 id="中间件就是在目标和结果之间进行的额外处理过程，在Django中就是request和response之间进行的处理，相对来说实现起来比较简单，但是要注意它是对全局有效的，可以在全局范围内改变输入和输出结果，因此需要谨慎使用，否则不仅会造成难以定位的错误，而且可能会影响整体性能。"><a href="#中间件就是在目标和结果之间进行的额外处理过程，在Django中就是request和response之间进行的处理，相对来说实现起来比较简单，但是要注意它是对全局有效的，可以在全局范围内改变输入和输出结果，因此需要谨慎使用，否则不仅会造成难以定位的错误，而且可能会影响整体性能。" class="headerlink" title="中间件就是在目标和结果之间进行的额外处理过程，在Django中就是request和response之间进行的处理，相对来说实现起来比较简单，但是要注意它是对全局有效的，可以在全局范围内改变输入和输出结果，因此需要谨慎使用，否则不仅会造成难以定位的错误，而且可能会影响整体性能。"></a>中间件就是在目标和结果之间进行的额外处理过程，在Django中就是request和response之间进行的处理，相对来说实现起来比较简单，但是要注意它是对全局有效的，可以在全局范围内改变输入和输出结果，因此需要谨慎使用，否则不仅会造成难以定位的错误，而且可能会影响整体性能。</h6><hr><h2 id="中间件有什么用？"><a href="#中间件有什么用？" class="headerlink" title="中间件有什么用？"></a>中间件有什么用？</h2><h6 id="如果想要修改HttpRequest或者HttpResponse，就可以通过中间件来实现。"><a href="#如果想要修改HttpRequest或者HttpResponse，就可以通过中间件来实现。" class="headerlink" title="如果想要修改HttpRequest或者HttpResponse，就可以通过中间件来实现。"></a>如果想要修改HttpRequest或者HttpResponse，就可以通过中间件来实现。</h6><ul><li><p>登陆认证：在中间件中加入登陆认证，所有请求就自动拥有登陆认证，如果需要放开部分路由，只需要特殊处理就可以了。</p></li><li><p>流量统计：可以针对一些渲染页面统计访问流量。</p></li><li><p>恶意请求拦截：统计IP请求次数，可以进行频次限制或者封禁IP。</p></li></ul><h6 id="在Django中自定义中间件-在settings-py中找到MIDDLEWARE项，把添加的中间件配置到这里就行了。"><a href="#在Django中自定义中间件-在settings-py中找到MIDDLEWARE项，把添加的中间件配置到这里就行了。" class="headerlink" title="在Django中自定义中间件:在settings.py中找到MIDDLEWARE项，把添加的中间件配置到这里就行了。"></a>在Django中自定义中间件:在settings.py中找到MIDDLEWARE项，把添加的中间件配置到这里就行了。</h6><h6 id="例如我在myapp文件夹下-该文件夹与Django文件夹同级-有一个views-py文件，在views-py中有一个叫做MyMiddleware的中间件，那么配置的时候只要在MIDDLEWARE列表中添加一条"><a href="#例如我在myapp文件夹下-该文件夹与Django文件夹同级-有一个views-py文件，在views-py中有一个叫做MyMiddleware的中间件，那么配置的时候只要在MIDDLEWARE列表中添加一条" class="headerlink" title="例如我在myapp文件夹下(该文件夹与Django文件夹同级)有一个views.py文件，在views.py中有一个叫做MyMiddleware的中间件，那么配置的时候只要在MIDDLEWARE列表中添加一条:"></a>例如我在myapp文件夹下(该文件夹与Django文件夹同级)有一个views.py文件，在views.py中有一个叫做MyMiddleware的中间件，那么配置的时候只要在MIDDLEWARE列表中添加一条:</h6><pre class="highlight"><span class="line"><span class="string">&#x27;myapp.views.MyMiddleware&#x27;</span></span><br></pre><hr><h4 id="每个中间件可以包含五个方法"><a href="#每个中间件可以包含五个方法" class="headerlink" title="每个中间件可以包含五个方法:"></a>每个中间件可以包含五个方法:</h4><pre class="highlight"><span class="line">process_request(self,request)</span><br><span class="line">process_view(self, request, callback, callback_args, callback_kwargs)</span><br><span class="line">process_template_response(self,request,response)</span><br><span class="line">process_exception(self, request, exception)</span><br><span class="line">process_response(self, request, response)</span><br></pre><hr><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程:"></a>执行流程:</h2><ol><li>请求到达中间件后先依次执行每个中间件的process_request函数</li><li>然后再依次执行每个中间件的process_view函数，找到我们的视图函数</li><li>执行视图函数处理请求数据</li><li>如果在上面的过程中出现异常，则依次反方向执行每个中间件的process_exception函数</li><li>如果请求包含模板渲染，则依次反方向执行每个中间件的process_template_response函数</li><li>最后依次反方向执行每个中间件的process_response函数</li></ol><hr><h6 id="以上这些执行函数将返回None或者HttpResponse对象，如果返回None，则交给下一个中间件的对应函数处理；如果返回HttpResponse对象，则将其返回给用户。"><a href="#以上这些执行函数将返回None或者HttpResponse对象，如果返回None，则交给下一个中间件的对应函数处理；如果返回HttpResponse对象，则将其返回给用户。" class="headerlink" title="以上这些执行函数将返回None或者HttpResponse对象，如果返回None，则交给下一个中间件的对应函数处理；如果返回HttpResponse对象，则将其返回给用户。"></a>以上这些执行函数将返回None或者HttpResponse对象，如果返回None，则交给下一个中间件的对应函数处理；如果返回HttpResponse对象，则将其返回给用户。</h6><h3 id="应用"><a href="#应用" class="headerlink" title="应用:"></a>应用:</h3><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMiddleware</span>(<span class="params">MiddlewareMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;过滤中间件&#x27;</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span>(<span class="params">self, request, view_func, view_args, view_kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span>(<span class="params">self, request, exception</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span>(<span class="params">self, request, response</span>):</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br></pre><hr><h2 id="每次请求时，都会打印一行”过滤中间件”"><a href="#每次请求时，都会打印一行”过滤中间件”" class="headerlink" title="每次请求时，都会打印一行”过滤中间件”"></a>每次请求时，都会打印一行”过滤中间件”</h2>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django实现文件上传操作</title>
      <link href="/2018/11/30/django%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/11/30/django%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h5 id="思路：先从前端接受到图片-后台进行重命名-压缩-入库-之后将图片名返回前端-用于展示图片"><a href="#思路：先从前端接受到图片-后台进行重命名-压缩-入库-之后将图片名返回前端-用于展示图片" class="headerlink" title="思路：先从前端接受到图片 后台进行重命名/压缩/入库 之后将图片名返回前端 用于展示图片"></a>思路：先从前端接受到图片 后台进行重命名/压缩/入库 之后将图片名返回前端 用于展示图片</h5><p><img src="/hugoblog/%E9%80%BB%E8%BE%91%E5%9B%BE.png" alt="~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E9%80%BB%E8%BE%91%E5%9B%BE.png" class="lozad post-image"></p><hr><h5 id="修改配置settings"><a href="#修改配置settings" class="headerlink" title="修改配置settings"></a>修改配置settings</h5><pre class="highlight"><span class="line">STATIC_URL = <span class="string">&#x27;/static/&#x27;</span></span><br><span class="line"></span><br><span class="line">STATICFILES_DIRS=[</span><br><span class="line">     os.path.join(BASE_DIR,<span class="string">&#x27;static&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义上传文件夹的路径</span></span><br><span class="line">UPLOAD_ROOT = os.path.join(BASE_DIR,<span class="string">&#x27;static/upload&#x27;</span>)</span><br></pre><hr><h5 id="前端发送post请求"><a href="#前端发送post请求" class="headerlink" title="前端发送post请求"></a>前端发送post请求</h5><pre class="highlight"><span class="line">upload(e) &#123;  //@change=<span class="string">&quot;upload&quot;</span> 侦听操作 e是变化的数据</span><br><span class="line">      // 获取文件</span><br><span class="line">      let file = e.target.files[<span class="number">0</span>];</span><br><span class="line">      // 生名表单参数</span><br><span class="line">      let formdata = new FormData();</span><br><span class="line">      var uid = localStorage.getItem(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line">      formdata.append(<span class="string">&quot;file&quot;</span>, file, file.name);</span><br><span class="line">      formdata.append(<span class="string">&quot;uid&quot;</span>, uid);</span><br><span class="line">      // 请求头</span><br><span class="line">      let config = &#123; headers: &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;multipart/form-data&quot;</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">      // 请求后台</span><br><span class="line">      this.axios</span><br><span class="line">        .post(<span class="string">&quot;http://127.0.0.1:8000/myapp/upload/&quot;</span>, formdata, config)</span><br><span class="line">        .then(result =&gt; &#123;</span><br><span class="line">          console.log(result.data);</span><br><span class="line">          <span class="keyword">if</span> (result.data.code == <span class="number">200</span>) &#123;</span><br><span class="line">            this.src =<span class="string">&quot;http://127.0.0.1:8000/static/upload/&quot;</span> + result.data.filename;</span><br><span class="line">            this.$Message(result.data.msg);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            this.$Message(result.data.msg);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre><hr><h5 id="后台获取数据"><a href="#后台获取数据" class="headerlink" title="后台获取数据"></a>后台获取数据</h5><pre class="highlight"><span class="line">为了防止文件名重复 使用了md5和时间模块 进行加密</span><br><span class="line"></span><br><span class="line">在更改图片之后 我们要删除之前的 防止垃圾过多</span><br><span class="line"></span><br><span class="line">造成资源浪费</span><br><span class="line"></span><br><span class="line">加水印函数：</span><br></pre><pre class="highlight"><span class="line"><span class="comment"># 压缩</span></span><br><span class="line"><span class="comment">#压缩 两种压缩模式，png不适合压缩，jpg适合</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment">#读图</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;./dingding.png&#x27;</span>)</span><br><span class="line"><span class="comment">#开始压缩 png压缩等级清晰0-9模糊</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./dingding1.png&#x27;</span>,img,[cv2.IMWRITE_PNG_COMPRESSION,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#jpg压缩等级清晰0-100模糊 </span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./dingding1.jpg&#x27;</span>,img,[cv2.IMWRITE_JPEG_QUALITY,<span class="number">50</span>])</span><br></pre><hr><pre class="highlight"><span class="line"><span class="comment"># 加水印</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cn_logo</span>(<span class="params">img_name</span>):</span></span><br><span class="line">    img = Image.open(<span class="string">&#x27;.//static/upload/&#x27;</span>+img_name)</span><br><span class="line">    <span class="comment"># 获取宽高</span></span><br><span class="line">    width, height = img.size</span><br><span class="line">    <span class="comment"># 根据图片大小定义logo大小</span></span><br><span class="line">    text = <span class="string">&#x27;美多商城&#x27;</span></span><br><span class="line">    font = ImageFont.truetype(<span class="string">&#x27;msyh.ttc&#x27;</span>, (width - height) // <span class="number">10</span>)</span><br><span class="line">    <span class="comment"># 获取字体宽高</span></span><br><span class="line">    font_width, font_height = font.getsize(text)</span><br><span class="line">    <span class="comment"># 使用画笔</span></span><br><span class="line">    draw = ImageDraw.Draw(img)</span><br><span class="line">    <span class="comment"># 写入文本</span></span><br><span class="line">    draw.text((width - font_width, height - font_height - <span class="number">10</span>), text, (<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>), font=font)</span><br><span class="line">    <span class="comment"># 加密下文件名防止重复</span></span><br><span class="line">    filename = make_password(img_name) + str((int(round(time.time() * <span class="number">1000</span>)))) + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">    <span class="comment"># 根据路径保存文件</span></span><br><span class="line">    img.save(os.path.join(UPLOAD_ROOT, <span class="string">&#x27;&#x27;</span>, filename))</span><br><span class="line">    os.remove(<span class="string">&#x27;.//static/upload/&#x27;</span> + img_name)  <span class="comment"># 删除原图片</span></span><br><span class="line">    <span class="keyword">return</span> filename</span><br></pre><hr><h5 id="文件接口"><a href="#文件接口" class="headerlink" title="文件接口"></a>文件接口</h5><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span></span><br><span class="line">    myfile=request.FILES.get(<span class="string">&#x27;file&#x27;</span>)</span><br><span class="line">    uid=request.POST.get(<span class="string">&#x27;uid&#x27;</span>)</span><br><span class="line">    <span class="comment"># 判断文件类型</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> re.match(<span class="string">&#x27;.*(jpg|png|jpeg)$&#x27;</span>, myfile.name):</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">403</span>,<span class="string">&#x27;msg&#x27;</span>:<span class="string">&#x27;请上传png或者jpg格式&#x27;</span>&#125;)</span><br><span class="line">    <span class="keyword">with</span> open(os.path.join(UPLOAD_ROOT,<span class="string">&#x27;&#x27;</span>,myfile.name),<span class="string">&#x27;wb&#x27;</span>)<span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> myfile.chunks():</span><br><span class="line">            f.write(chunk)</span><br><span class="line">            <span class="comment"># 调用水印函数</span></span><br><span class="line">    filename=cn_logo(myfile.name)</span><br><span class="line">            <span class="comment"># 更改数据库</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        user=User.objects.filter(pk=uid).first()</span><br><span class="line">        <span class="keyword">if</span> user.img:  <span class="comment"># 删除旧图片</span></span><br><span class="line">           os.remove(<span class="string">&#x27;.//static/upload/&#x27;</span>+user.img)</span><br><span class="line">           user.img=filename</span><br><span class="line">           user.save()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"> <span class="keyword">return</span> Response(&#123;<span class="string">&quot;code&quot;</span>:<span class="number">200</span>,<span class="string">&quot;msg&quot;</span>:<span class="string">&quot;更改成功&quot;</span>,<span class="string">&#x27;filename&#x27;</span>:filename&#125;)</span><br><span class="line"></span><br></pre><hr><pre class="highlight"><span class="line">上面进行了 更改数据库 删除文件 写入文件</span><br><span class="line"></span><br><span class="line">那么如何进行展示呢？</span><br><span class="line"></span><br><span class="line">写一个get方法 根据用户返回图片名</span><br></pre><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">    <span class="comment"># 获取参数</span></span><br><span class="line">    uid=request.GET.get(<span class="string">&#x27;uid&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">    user=User.objects.filter(pk=uid).first()</span><br><span class="line">    <span class="keyword">if</span> user.img:</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&quot;code&quot;</span>:<span class="number">200</span>,<span class="string">&#x27;filename&#x27;</span>:user.img&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&quot;code&quot;</span>:<span class="number">200</span>,<span class="string">&#x27;filename&#x27;</span>:<span class="string">&#x27;user.png&#x27;</span>&#125;)</span><br></pre><hr><h5 id="前端进行get请求"><a href="#前端进行get请求" class="headerlink" title="前端进行get请求"></a>前端进行get请求</h5><pre class="highlight"><span class="line">get_avatar() &#123;</span><br><span class="line">    var uid = localStorage.getItem(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line">    this.axios.get(<span class="string">&quot;http://127.0.0.1:8000/myapp/upload/&quot;</span>, &#123;</span><br><span class="line">        params: &#123; <span class="string">&#x27;uid&#x27;</span>: uid &#125;</span><br><span class="line">    &#125;).then(result =&gt; &#123;</span><br><span class="line">        this.src =<span class="string">&quot;http://127.0.0.1:8000/static/upload/&quot;</span> + result.data.filename;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre><pre class="highlight"><span class="line">这里将src 拼接为图片路径之后用img 标签就可以显示了</span><br></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django配置</title>
      <link href="/2018/11/27/django%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/11/27/django%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-django配置-settings-py"><a href="#1-django配置-settings-py" class="headerlink" title="1.django配置(settings.py)"></a>1.django配置(settings.py)</h2><pre class="highlight"><span class="line">DATABASES = &#123;</span><br><span class="line">   <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,   <span class="comment">#数据库引擎</span></span><br><span class="line">          <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;md&#x27;</span>,                          <span class="comment">#数据库名</span></span><br><span class="line">          <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,                         <span class="comment">#用户名</span></span><br><span class="line">          <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;&#x27;</span>,                         <span class="comment">#密码--根据自身数据库密码填写</span></span><br><span class="line">          <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;localhost&#x27;</span>,                    <span class="comment">#数据库主机，默认为localhost</span></span><br><span class="line">          <span class="string">&#x27;PORT&#x27;</span>: <span class="number">3306</span>,                           <span class="comment">#数据库端口，MySQL默认为3306</span></span><br><span class="line">          <span class="string">&#x27;OPTIONS&#x27;</span>: &#123;</span><br><span class="line">             <span class="string">&#x27;autocommit&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre><hr><h2 id="2-运行项目"><a href="#2-运行项目" class="headerlink" title="2.运行项目"></a>2.运行项目</h2><pre class="highlight"><span class="line">python manage.py runserver</span><br></pre><h2 id="3-django的数据库迁移"><a href="#3-django的数据库迁移" class="headerlink" title="3.django的数据库迁移"></a>3.django的数据库迁移</h2><h6 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h6><pre class="highlight"><span class="line">python manage.py makemigrations myapp</span><br></pre><h6 id="注意：首次迁移后面写myapp，以后不用写"><a href="#注意：首次迁移后面写myapp，以后不用写" class="headerlink" title="注意：首次迁移后面写myapp，以后不用写"></a>注意：首次迁移后面写myapp，以后不用写</h6><h6 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h6><pre class="highlight"><span class="line">python manage.py migrate</span><br></pre><hr><h2 id="3-配置跨域"><a href="#3-配置跨域" class="headerlink" title="3.配置跨域"></a>3.配置跨域</h2><pre class="highlight"><span class="line"></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;corsheaders.middleware.CorsMiddleware&#x27;</span>, <span class="comment">#这里是新增的中间件</span></span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    <span class="comment">#&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;,</span></span><br><span class="line">    <span class="string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br><span class="line">    <span class="comment">#加载自定义中间件   文件夹名.文件名.类名</span></span><br><span class="line">    <span class="comment">#&#x27;myapp.views.MyMiddleware&#x27;</span></span><br><span class="line">]</span><br></pre><h6 id="设置跨域"><a href="#设置跨域" class="headerlink" title="设置跨域"></a>设置跨域</h6><pre class="highlight"><span class="line">CORS_ALLOW_CREDENTIALS = <span class="literal">True</span></span><br><span class="line">CORS_ORIGIN_ALLOW_ALL = <span class="literal">True</span></span><br></pre><h6 id="定义上传文件夹的路径"><a href="#定义上传文件夹的路径" class="headerlink" title="定义上传文件夹的路径"></a>定义上传文件夹的路径</h6><pre class="highlight"><span class="line">UPLOAD_ROOT = os.path.join(BASE_DIR,<span class="string">&#x27;static/upload&#x27;</span>)</span><br></pre><hr>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django创建表</title>
      <link href="/2018/11/27/django%E5%88%9B%E5%BB%BA%E8%A1%A8/"/>
      <url>/2018/11/27/django%E5%88%9B%E5%BB%BA%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h6 id="在settings-py配置好的前提下，打开models-py"><a href="#在settings-py配置好的前提下，打开models-py" class="headerlink" title="在settings.py配置好的前提下，打开models.py"></a>在settings.py配置好的前提下，打开models.py</h6><h4 id="创建基类-增加代码的复用"><a href="#创建基类-增加代码的复用" class="headerlink" title="创建基类(增加代码的复用)"></a>创建基类(增加代码的复用)</h4><pre class="highlight"><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"></span><br><span class="line"><span class="comment">#基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment">#创建时间 </span></span><br><span class="line">    create_time = models.DateTimeField(default=timezone.now,null=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment">#能否被继承</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用户类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="comment">#  用户名</span></span><br><span class="line">    username = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    <span class="comment">#  密码</span></span><br><span class="line">    password = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    <span class="comment">#  头像</span></span><br><span class="line">    img = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    <span class="comment">#分类 0普通用户 1会员</span></span><br><span class="line">    type = models.IntegerField()</span><br><span class="line">    <span class="comment">#  主页</span></span><br><span class="line">    num = models.IntegerField()</span><br><span class="line">    <span class="comment">#  联系方式</span></span><br><span class="line">    phone = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  声明表名</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&#x27;user&#x27;</span></span><br><span class="line"></span><br></pre><hr><h6 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h6><pre class="highlight"><span class="line">python manage.py makemigrations myapp</span><br><span class="line">python manage.py migrate</span><br></pre><h4 id="如果迁移不成功"><a href="#如果迁移不成功" class="headerlink" title="如果迁移不成功"></a>如果迁移不成功</h4><ol><li>删除myapp下的migrations</li><li>通过可视化工具Navicat进行物理删除，及删除数据库中的所有表（有时候删一次删不彻底，记得多重复几次物理删除操作）</li><li>重新建立数据库关系映射，迁移数据库</li></ol><h6 id="Mysql-用Navicat手动建表格"><a href="#Mysql-用Navicat手动建表格" class="headerlink" title="Mysql 用Navicat手动建表格"></a>Mysql 用Navicat手动建表格</h6><p>手动建表格，输入反向数据库入库命令</p><pre class="highlight"><span class="line">python manage.py inspectdb &gt; mymodel.py</span><br></pre><hr>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>又拍云存储</title>
      <link href="/2018/11/27/%E5%8F%88%E6%8B%8D%E4%BA%91%E5%AD%98%E5%82%A8/"/>
      <url>/2018/11/27/%E5%8F%88%E6%8B%8D%E4%BA%91%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class="highlight"><span class="line">pip install upyun</span><br></pre><hr><h2 id="django接口"><a href="#django接口" class="headerlink" title="django接口"></a>django接口</h2><pre class="highlight"><span class="line"><span class="comment">#又拍云</span></span><br><span class="line"><span class="keyword">import</span> upyun</span><br><span class="line"><span class="comment">#定义文件上传类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YouPai</span>(<span class="params">View</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="comment">#接受参数</span></span><br><span class="line">        img = request.FILES.get(<span class="string">&#x27;file&#x27;</span>)</span><br><span class="line">        <span class="comment"># 生成独特的文件名</span></span><br><span class="line">        filename = make_password(img.name) + str((int(round(time.time() * <span class="number">1000</span>)))) + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">        <span class="comment"># 实例化对象</span></span><br><span class="line">        up = upyun.UpYun(<span class="string">&#x27;md-admin&#x27;</span>, username=<span class="string">&#x27;a2925087209&#x27;</span>, password=<span class="string">&#x27;by0sFyYQ62GfZSIqCPVRXJLHlierRJsT&#x27;</span>)</span><br><span class="line">        headers = &#123; <span class="string">&#x27;x-gmkerl-rotate&#x27;</span>: <span class="string">&#x27;50&#x27;</span> &#125;</span><br><span class="line">        <span class="comment"># 分块上传</span></span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> img.chunks():</span><br><span class="line">            res = up.put(<span class="string">&#x27;/%s&#x27;</span>%filename,chunk,checksum=<span class="literal">True</span>,headers=headers)</span><br><span class="line">        <span class="comment">#返回结果</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(&#123;<span class="string">&#x27;filename&#x27;</span>:filename&#125;),content_type=<span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line"></span><br></pre><hr><h2 id="vue接口"><a href="#vue接口" class="headerlink" title="vue接口"></a>vue接口</h2><pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;!-- &lt;/img :src=&quot;src&quot; /&gt; --&gt;</span><br><span class="line">        又拍云存储：&lt;Avatar :src=&quot;yp_url&quot; :width=&#x27;150&#x27; fil=&#x27;fill&#x27;&gt;&lt;/Avatar&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;file&quot;</span> @change=<span class="string">&quot;upload_upyun&quot;</span> /&gt;</span><br><span class="line">        &lt;div class=&quot;upload&quot;&gt;</span><br><span class="line">            拖拽上传</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            yp_url :<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mounted:function()&#123;</span><br><span class="line">    //又拍云</span><br><span class="line">    //注册推托拽容器</span><br><span class="line">    let upload = document.querySelector(<span class="string">&#x27;.upyun&#x27;</span>);</span><br><span class="line">    //声明监听事件</span><br><span class="line">    //点击</span><br><span class="line">    upload.addEventListener(<span class="string">&#x27;dragenter&#x27;</span>, this.onDrag, false);</span><br><span class="line">    //悬停</span><br><span class="line">    upload.addEventListener(<span class="string">&#x27;dragover&#x27;</span>, this.onDrag, false);</span><br><span class="line">    //释放</span><br><span class="line">    upload.addEventListener(<span class="string">&#x27;drop&#x27;</span>, this.onDrop, false);</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        //又拍云上传</span><br><span class="line">        //监听鼠标</span><br><span class="line">        onDrag (e) &#123;</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        &#125;,</span><br><span class="line">        onDrop (e) &#123;</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        this.upyun(e.dataTransfer.files);</span><br><span class="line">        &#125;,</span><br><span class="line">        //上传又拍云</span><br><span class="line">        upyun:function(files)&#123;</span><br><span class="line">            //获取文件对象</span><br><span class="line">        //   let file = e.target.files[<span class="number">0</span>];</span><br><span class="line">            let file = files[<span class="number">0</span>];</span><br><span class="line">            //声明参数</span><br><span class="line">            let param = new FormData();</span><br><span class="line">            param.append(<span class="string">&#x27;file&#x27;</span>,file);</span><br><span class="line"></span><br><span class="line">            const config = &#123;</span><br><span class="line">            headers: &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span> &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            var a = this</span><br><span class="line">            a.axios.post(<span class="string">&#x27;http://localhost:8000/youpai/&#x27;</span>, param, config)// 上传图片</span><br><span class="line">            .then(function(res) &#123;</span><br><span class="line">                console.log(res)</span><br><span class="line">                a.yp_url = <span class="string">&#x27;http://md-admin.test.upcdn.net/&#x27;</span>+res.data.filename</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.upload &#123;</span><br><span class="line">  margin: <span class="number">100</span>px auto;</span><br><span class="line">  width: <span class="number">300</span>px;</span><br><span class="line">  height: <span class="number">150</span>px;</span><br><span class="line">  border: <span class="number">2</span>px dashed <span class="comment">#f00;</span></span><br><span class="line">  padding-top: <span class="number">50</span>px;</span><br><span class="line">  padding-left: <span class="number">80</span>px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre><h2 id="又拍云文件操作"><a href="#又拍云文件操作" class="headerlink" title="又拍云文件操作"></a>又拍云文件操作</h2><pre class="highlight"><span class="line"></span><br><span class="line"><span class="keyword">import</span> upyun</span><br><span class="line"><span class="comment">#实例化</span></span><br><span class="line">up = upyun.UpYun(<span class="string">&quot;空间名&quot;</span>,<span class="string">&#x27;操作员&#x27;</span>,<span class="string">&#x27;密码&#x27;</span>)</span><br><span class="line"><span class="comment">#读内存上传</span></span><br><span class="line">up.put(<span class="string">&#x27;自定义文件名&#x27;</span>,<span class="string">&#x27;文件内容&#x27;</span>)</span><br><span class="line"><span class="comment">#文件流操作（节省内存）</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;文件路径/文件名&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)<span class="keyword">as</span> f:</span><br><span class="line">    res = up.put(<span class="string">&#x27;自定义文件名&#x27;</span>,f,checksum=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#目录操作</span></span><br><span class="line">up.mkdir(<span class="string">&#x27;/文件夹名/&#x27;</span>)</span><br><span class="line"><span class="comment">#移动文件</span></span><br><span class="line">up.move(<span class="string">&#x27;/文件路径/文件名&#x27;</span>,<span class="string">&#x27;/新文件路径/文件名&#x27;</span>)</span><br><span class="line"><span class="comment">#复制文件</span></span><br><span class="line">up.copy(<span class="string">&#x27;/文件路径/文件名&#x27;</span>,<span class="string">&#x27;/新文件路径/文件名&#x27;</span>)</span><br><span class="line"><span class="comment">#断点续传</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;文件路径/文件名&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)<span class="keyword">as</span> f:</span><br><span class="line">    res = up.put(<span class="string">&#x27;自定义文件名&#x27;</span>,f,checksum=<span class="literal">True</span>，need_resume=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#下载</span></span><br><span class="line">res = up.get(<span class="string">&#x27;/文件路径/文件名&#x27;</span>)</span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line">up.delete(<span class="string">&#x27;/文件路径/文件名&#x27;</span>)</span><br><span class="line"></span><br></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次完整的HTTP请求过程</title>
      <link href="/2018/11/20/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/11/20/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="问题：当我们在web浏览器的地址栏中输入：www-baidu-com，具体发生了什么？"><a href="#问题：当我们在web浏览器的地址栏中输入：www-baidu-com，具体发生了什么？" class="headerlink" title="问题：当我们在web浏览器的地址栏中输入：www.baidu.com，具体发生了什么？"></a>问题：当我们在web浏览器的地址栏中输入：<a href="www.baidu.com">www.baidu.com</a>，具体发生了什么？</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>对<a href="www.baidu.com">www.baidu.com</a>这个网址进行DNS域名解析，得到对应的IP地址</li><li>根据这个IP，找到对应的服务器，发起TCP的三次握手</li><li>建立TCP连接后发起HTTP请求</li><li>服务器响应HTTP请求，浏览器得到html代码</li><li>浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）（先得到html代码，才能去找这些资源）</li><li>浏览器对页面进行渲染呈现给用户</li><li>服务器关闭关闭TCP连接</li></ol><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><h5 id="1-DNS怎么找到域名的？"><a href="#1-DNS怎么找到域名的？" class="headerlink" title="1.DNS怎么找到域名的？"></a>1.DNS怎么找到域名的？</h5><pre class="highlight"><span class="line">DNS域名解析采用的是递归查询的方式，过程是，先去找DNS缓存-&gt;缓存找不到就去找根域名服务器-&gt;根域名又会去找下一级，这样递归查找之后，找到了，给我们的web浏览器</span><br></pre><h5 id="2-为什么HTTP协议要基于TCP来实现？"><a href="#2-为什么HTTP协议要基于TCP来实现？" class="headerlink" title="2.为什么HTTP协议要基于TCP来实现？"></a>2.为什么HTTP协议要基于TCP来实现？</h5><pre class="highlight"><span class="line">TCP是一个端到端的可靠的面相连接的协议，HTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，会重传）</span><br></pre><h5 id="3-最后一步浏览器是如何对页面进行渲染的？"><a href="#3-最后一步浏览器是如何对页面进行渲染的？" class="headerlink" title="3.最后一步浏览器是如何对页面进行渲染的？"></a>3.最后一步浏览器是如何对页面进行渲染的？</h5><pre class="highlight"><span class="line">a)  解析html文件构成 DOM树</span><br><span class="line">b）解析CSS文件构成渲染树</span><br><span class="line">c）边解析，边渲染</span><br><span class="line">d）JS 单线程运行，JS有可能修改DOM结构，意味着JS执行完成前，后续所有资源的下载是没有必要的，所以JS是单线程，会阻塞后续资源下载</span><br></pre><h2 id="各个步骤具体细节"><a href="#各个步骤具体细节" class="headerlink" title="各个步骤具体细节"></a>各个步骤具体细节</h2><h5 id="DNS解析（域名解析服务器）"><a href="#DNS解析（域名解析服务器）" class="headerlink" title="DNS解析（域名解析服务器）"></a>DNS解析（域名解析服务器）</h5><p>a）首先会搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存）</p><p>b）如果浏览器自身的缓存里面没有找到，那么浏览器会搜索系统自身的DNS缓存</p><p>c）如果还没有找到，那么尝试从 hosts文件里面去找</p><p>d）在前面三个过程都没获取到的情况下，就递归地去域名服务器去查找，具体过程如下<br><img src="https://img-blog.csdnimg.cn/20200707212544343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU4Nzg2NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200707212544343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU4Nzg2NA==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><h6 id="DNS优化两个方面：DNS缓存、DNS负载均衡"><a href="#DNS优化两个方面：DNS缓存、DNS负载均衡" class="headerlink" title="DNS优化两个方面：DNS缓存、DNS负载均衡"></a>DNS优化两个方面：DNS缓存、DNS负载均衡</h6><h2 id="TCP连接建立（三次握手）"><a href="#TCP连接建立（三次握手）" class="headerlink" title="TCP连接建立（三次握手）"></a>TCP连接建立（三次握手）</h2><p>　　拿到域名对应的IP地址之后，User-Agent（一般指浏览器）会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd，nginx）等的80端口。这个连接请求（原始的http请求经过TCP/IP4层模型的层层封包）到达服务器端后（这中间有各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终达到WEB程序，最终建立了TCP/IP的连接</p><h2 id="发起HTTP请求-建立连接后"><a href="#发起HTTP请求-建立连接后" class="headerlink" title="发起HTTP请求(建立连接后)"></a>发起HTTP请求(建立连接后)</h2><p>HTTP请求报文由三部分组成：请求行，请求头、空格、请求正文</p><p>请求行：用于描述客户端的请求方式（GET/POST等），请求的资源名称(URL)以及使用的HTTP协议的版本号</p><p>请求头：用于描述客户端请求哪台主机及其端口，以及客户端的一些环境信息等</p><p>空行：空行就是\r\n (POST请求时候有)</p><p>请求正文：当使用POST等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中（GET方式是保存在url地址后面，不会放到这里）</p><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><p>下面是浏览器对 <a href="http://localhost:8081/test?name=XXG&amp;age=23%E7%9A%84GET">http://localhost:8081/test?name=XXG&amp;age=23的GET</a> 请求时发送给服务器的数据：<br><img src="https://img-blog.csdnimg.cn/2020070721290553.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/2020070721290553.png" class="lozad post-image"></p><p>可以看出请求包含请求行和请求头两部分。其中请求行中包含 method（例如 GET、POST）、URI（通一资源标志符）和协议版本三部分，三个部分之间以空格分开。请求行和每个请求头各占一行，以换行符 CRLF（即 \r\n）分割。</p><h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><p>下面是浏览器对 <a href="http://localhost:8081/test">http://localhost:8081/test</a> 的 POST 请求时发送给服务器的数据，消息体中带上参数 name=XXG&amp;age=23<br><img src="https://img-blog.csdnimg.cn/20200707213226601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU4Nzg2NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200707213226601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU4Nzg2NA==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>可以看出，上面的请求包含三个部分：请求行、请求头、空格、消息体，比之前的 GET 请求多了一个请求消息，其中 请求头和消息体之间用一个空行分割。POST 请求的参数不在 URL 中，而是在消息体中，请求头中多了一项 Content-Length 用于表示消息体的字节数，这样服务器才能知道请求是否发送结束。这也就是 GET 请求和 POST 请求的主要区别。</p><p>那么<strong>起始行中的请求方法</strong>有哪些种呢？</p><pre class="highlight"><span class="line">GET: 完整请求一个资源 （常用）</span><br><span class="line">  HEAD: 仅请求响应首部</span><br><span class="line">  POST：提交表单  （常用）</span><br><span class="line">  PUT: (webdav) 上传文件（但是浏览器不支持该方法）</span><br><span class="line">  DELETE：(webdav) 删除</span><br><span class="line">  OPTIONS：返回请求的资源所支持的方法的方法</span><br><span class="line">  TRACE: 追求一个资源请求中间所经过的代理（该方法不能由浏览器发出）</span><br></pre><p>那什么是URL、URI、URN？</p><pre class="highlight"><span class="line">URI  Uniform Resource Identifier 统一资源标识符</span><br><span class="line">URL  Uniform Resource Locator 统一资源定位符</span><br><span class="line">URN  Uniform Resource Name 统一资源名称</span><br></pre><p>URL和URN 都属于 URI，为了方便就把URL和URI暂时都通指一个东西</p><h3 id="服务器响应http请求，浏览器得到html代码"><a href="#服务器响应http请求，浏览器得到html代码" class="headerlink" title="服务器响应http请求，浏览器得到html代码"></a>服务器响应http请求，浏览器得到html代码</h3><p>HTTP响应也由三部分组成：状态行，响应头，空格，消息体</p><p>状态行包括：协议版本、状态码、状态码描述</p><p><strong>状态码</strong>：状态码用于表示服务器对请求的处理结果</p><pre class="highlight"><span class="line">1xx：指示信息——表示请求已经接受，继续处理</span><br><span class="line">2xx：成功——表示请求已经被成功接收、理解、接受。</span><br><span class="line">3xx：重定向——要完成请求必须进行更进一步的操作</span><br><span class="line">4xx：客户端错误——请求有语法错误或请求无法实现</span><br><span class="line">5xx：服务器端错误——服务器未能实现合法的请求。</span><br></pre><p>列举几种常见的：</p><pre class="highlight"><span class="line">200（没有问题） </span><br><span class="line">302（要你去找别人） </span><br><span class="line">304（要你去拿缓存） </span><br><span class="line">307（要你去拿缓存） </span><br><span class="line">403（有这个资源，但是没有访问权限） </span><br><span class="line">404（服务器没有这个资源） </span><br><span class="line">500（服务器这边有问题）</span><br></pre><p><strong>响应头</strong>：响应头用于描述服务器的基本信息，以及客户端如何处理数据</p><p><strong>空格</strong>：CRLF（即 \r\n）分割</p><p><strong>消息体</strong>：服务器返回给客户端的数据</p><p>响应格式如下图<br><img src="https://img-blog.csdnimg.cn/20200707213625670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU4Nzg2NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200707213625670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU4Nzg2NA==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>上面的 HTTP 响应中，响应头中的 Content-Length 同样用于表示消息体的字节数。Content-Type 表示消息体的类型，通常浏览网页其类型是HTML，当然还会有其他类型，比如图片、视频等。</p><h3 id="浏览器解析html代码，并请求html代码中的资源"><a href="#浏览器解析html代码，并请求html代码中的资源" class="headerlink" title="浏览器解析html代码，并请求html代码中的资源"></a>浏览器解析html代码，并请求html代码中的资源</h3><p>浏览器拿到html文件后，就开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这是时候就用上 keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里面的顺序，但是由于每个资源大小不一样，而浏览器又是多线程请求请求资源，所以这里显示的顺序并不一定是代码里面的顺序。</p><h3 id="浏览器对页面进行渲染呈现给用户"><a href="#浏览器对页面进行渲染呈现给用户" class="headerlink" title="浏览器对页面进行渲染呈现给用户"></a>浏览器对页面进行渲染呈现给用户</h3><p>最后，浏览器利用自己内部的工作机制，把请求的静态资源和html代码进行渲染，渲染之后呈现给用户，浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，JS有可能修改DOM结构，意味着JS执行完成前，后续所有资源的下载是没有必要的，所以JS是单线程，会阻塞后续资源下载。</p><h3 id="服务器关闭关闭TCP连接"><a href="#服务器关闭关闭TCP连接" class="headerlink" title="服务器关闭关闭TCP连接"></a>服务器关闭关闭TCP连接</h3><p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：</p><pre class="highlight"><span class="line">Connection:keep-alive </span><br></pre><p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p><h2 id="自此一次完整的HTTP事务宣告完成"><a href="#自此一次完整的HTTP事务宣告完成" class="headerlink" title="自此一次完整的HTTP事务宣告完成."></a>自此一次完整的HTTP事务宣告完成.</h2><h6 id="转载于：https-www-cnblogs-com-WindSun-p-11489356-html"><a href="#转载于：https-www-cnblogs-com-WindSun-p-11489356-html" class="headerlink" title="转载于：https://www.cnblogs.com/WindSun/p/11489356.html"></a>转载于：<a href="https://www.cnblogs.com/WindSun/p/11489356.html">https://www.cnblogs.com/WindSun/p/11489356.html</a></h6>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>验证码设置&amp;检测</title>
      <link href="/2018/10/26/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AE%BE%E7%BD%AE&amp;%E6%A3%80%E6%B5%8B/"/>
      <url>/2018/10/26/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AE%BE%E7%BD%AE&amp;%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="django设置验证码"><a href="#django设置验证码" class="headerlink" title="django设置验证码"></a>django设置验证码</h3><pre class="highlight"><span class="line"><span class="comment">#导入图片库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#绘画库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageDraw</span><br><span class="line"><span class="comment">#字体库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFont</span><br><span class="line"><span class="comment">#图片库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="comment">#随机库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#文件流</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#导包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="comment">#定义ip和端口号</span></span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">port = <span class="number">6379</span></span><br><span class="line"><span class="comment">#建立连接</span></span><br><span class="line"></span><br><span class="line">r = redis.Redis(host=host,port=port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#自定义图片验证码</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCode</span>(<span class="params">View</span>):</span></span><br><span class="line">    <span class="comment">#定义rgb随机颜色获取</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_random_color</span>(<span class="params">self</span>):</span></span><br><span class="line">        R = random.randrange(<span class="number">255</span>)</span><br><span class="line">        G = random.randrange(<span class="number">255</span>)</span><br><span class="line">        B = random.randrange(<span class="number">255</span>)</span><br><span class="line">        <span class="keyword">return</span> (R,G,B)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="comment">#定义画布</span></span><br><span class="line"></span><br><span class="line">        img_size = (<span class="number">120</span>,<span class="number">50</span>)<span class="comment">#宽120px，高50px</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#定义图片对象</span></span><br><span class="line"></span><br><span class="line">        image = Image.new(<span class="string">&#x27;RGB&#x27;</span>,img_size,<span class="string">&#x27;white&#x27;</span>)<span class="comment">#RGB的颜色模式 #画布 #背景颜色为白色</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#定义画笔</span></span><br><span class="line"></span><br><span class="line">        draw = ImageDraw.Draw(image,<span class="string">&#x27;RGB&#x27;</span>)  <span class="comment">#图片对象  #参数mode：RGB颜色模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#画笔内容</span></span><br><span class="line"></span><br><span class="line">        source = <span class="string">&#x27;0123456789abcdefghijklmnopqrstuvwxyz&#x27;</span><span class="comment">#内容为数字，字母，特殊符号，增加安全性</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#接收容器</span></span><br><span class="line"></span><br><span class="line">        code_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="comment">#定义字体，在本地路径下,size字体大小</span></span><br><span class="line"></span><br><span class="line">        myfont = ImageFont.truetype(font=<span class="string">&#x27;C:\\Windows\\Fonts\\Arial.ttf&#x27;</span>,size=<span class="number">25</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="comment">#获取字母颜色</span></span><br><span class="line"></span><br><span class="line">            text_color = self.get_random_color()</span><br><span class="line">            <span class="comment">#获取随机下标</span></span><br><span class="line"></span><br><span class="line">            tmp_num = random.randrange(len(source))</span><br><span class="line">            <span class="comment">#随机验证码内容</span></span><br><span class="line"></span><br><span class="line">            random_str = source[tmp_num]</span><br><span class="line">            <span class="comment">#装入容器</span></span><br><span class="line"></span><br><span class="line">            code_str += random_str</span><br><span class="line">            <span class="comment">#绘制验证码</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 参数(横坐标，纵坐标20),#验证码内容#验证码颜色#字体</span></span><br><span class="line"></span><br><span class="line">            draw.text((<span class="number">10</span>+<span class="number">30</span>*i,<span class="number">10</span>),random_str,text_color,font=myfont)</span><br><span class="line">        <span class="comment">#获取缓冲区</span></span><br><span class="line"></span><br><span class="line">        buf = io.BytesIO()</span><br><span class="line">        <span class="comment">#将临时图片保存到缓冲区</span></span><br><span class="line"></span><br><span class="line">        image.save(buf,<span class="string">&#x27;png&#x27;</span>)</span><br><span class="line">        <span class="comment">#保存随机验证码</span></span><br><span class="line"></span><br><span class="line">        r.set(<span class="string">&#x27;code&#x27;</span>,code_str)</span><br><span class="line">        <span class="comment">#保存session到数据库中的django_session</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">&#x27;222&#x27;</span>,r.get(<span class="string">&#x27;code&#x27;</span>))</span><br><span class="line">        <span class="comment"># request.session[&#x27;code&#x27;] = code_str</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#返回获取缓冲区的图片</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(buf.getvalue(),<span class="string">&#x27;image/png&#x27;</span>)</span><br><span class="line"></span><br></pre><hr><h3 id="vue展示验证码"><a href="#vue展示验证码" class="headerlink" title="vue展示验证码"></a>vue展示验证码</h3><pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 图片验证码 --&gt;</span><br><span class="line">    &lt;img :src=&quot;src&quot; alt=&quot;点击刷新&quot; @click=&quot;img_code&quot; class=&quot;imgcode&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">  src:<span class="string">&#x27;http://127.0.0.1:8000/code/&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    //刷新验证码</span><br><span class="line">img_code()&#123;</span><br><span class="line">//给图片网址加一个随机参数，可以点击刷新验证码</span><br><span class="line">var lsrc = <span class="string">&#x27;http://127.0.0.1:8000/code/&#x27;</span>+<span class="string">&#x27;?&#x27;</span>+Math.random()</span><br><span class="line">this.src = lsrc</span><br><span class="line"></span><br><span class="line">//var num = Math.ceil(Math.random()*<span class="number">10</span>)</span><br><span class="line">// this.src = this.src + <span class="string">&#x27;?num=&#x27;</span>+num</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.imgcode &#123;</span><br><span class="line">    /* 给图片点击鼠标更换小手样式 */</span><br><span class="line">cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre><h4 id="Api检测验证码-百度AI"><a href="#Api检测验证码-百度AI" class="headerlink" title="Api检测验证码(百度AI)"></a>Api检测验证码(百度AI)</h4><pre class="highlight"><span class="line"></span><br><span class="line">1.创建百度账号或者登陆百度账号</span><br><span class="line">2.选择总览--&gt;人工智能--&gt;文字识别--&gt;创建一个应用</span><br><span class="line">3.输入应用名,选择不需要文字识别包名--&gt;输入描述--&gt;点击创建(会有API Key和Secret Key)</span><br><span class="line">4.在左边目录中点击技术文档--&gt;点击API文档，立即使用</span><br><span class="line">5.选择通用文字识别--&gt;通用文字识别(高精度版)--&gt;点击Access token获取</span><br><span class="line">6.获取Access token：</span><br><span class="line">    1.向授权服务地址https:&#x2F;&#x2F;aip.baidubce.com&#x2F;oauth&#x2F;2.0&#x2F;token发送请求（推荐使用POST),并在URL中带上以下参数</span><br><span class="line">        grant_type： 必须参数，固定为client_credentials；</span><br><span class="line">        client_id： 必须参数，应用的API Key；</span><br><span class="line">        client_secret： 必须参数，应用的Secret Key；</span><br><span class="line">    2.url &#x3D; https:&#x2F;&#x2F;aip.baidubce.com&#x2F;oauth&#x2F;2.0&#x2F;token?</span><br><span class="line">      grant_type&#x3D;client_credentials&amp;client_id&#x3D;百度云应用的API Key&amp;client_secret&#x3D;百度云应用的Secret Key</span><br><span class="line">    3.使用json()获取：</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;refresh_token&quot;: &quot;25.b55fe1d287227ca97aab219bb249b8ab.315360000.1798284651.282335-8574074&quot;,</span><br><span class="line">        &quot;expires_in&quot;: 2592000,  # Access Token的有效期(秒为单位，一般为1个月)</span><br><span class="line">        &quot;scope&quot;: &quot;public wise_adapt&quot;,</span><br><span class="line">        &quot;session_key&quot;: &quot;9mzdDZXu3dENdFZQurfg0Vz8slgSgvvOAUebNFzyzcpQ5EnbxbF+hfG9DQkpUVQdh4p6HbQcAiz5RmuBAja1JJGgIdJI&quot;,</span><br><span class="line">        &quot;access_token&quot;: &quot;24.6c5e1ff107f0e8bcef8c46d3424a0e78.2592000.1485516651.282335-8574074&quot;,  #要获取的Access Token</span><br><span class="line">        &quot;session_secret&quot;: &quot;dfac94a3489fe9fca7c3221cbf7525ff&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    4.关于报错信息：</span><br><span class="line">      &#123;</span><br><span class="line">        error： 错误码；关于错误码的详细信息请参考下方鉴权认证错误码。</span><br><span class="line">        error_description： 错误描述信息，帮助理解和解决发生的错误。</span><br><span class="line">      &#125;</span><br><span class="line">      &#123;</span><br><span class="line">        error(错误码)     error_description(错误描述信息)  解释</span><br><span class="line">        invalid_client unknown client id              API Key不正确</span><br><span class="line">        invalid_client Client authentication failed    Secret Key不正确</span><br><span class="line">      &#125;</span><br><span class="line">7.访问url：&#39;https:&#x2F;&#x2F;aip.baidubce.com&#x2F;rest&#x2F;2.0&#x2F;ocr&#x2F;v1&#x2F;accurate_basic?access_token&#x3D;&#39; + access_token</span><br><span class="line">8.HTTP方法：POST</span><br><span class="line">9.Header参数：&#123;&#39;Content-Type&#39;:&#39;application&#x2F;x-www-form-urlencoded&#39;&#125;</span><br><span class="line">10.body必要参数：image   说明：ase64编码后进行urlencode</span><br><span class="line">11.返回结果：&#123;</span><br><span class="line">              log_id：唯一的log id，用于问题定位,</span><br><span class="line">              words_result:识别结果数组,</span><br><span class="line">              words_result_num:识别结果数，表示words_result的元素个数,</span><br><span class="line">              words：识别结果字符串,</span><br><span class="line">            &#125;</span><br></pre><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><pre class="highlight"><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"><span class="comment">#访问url</span></span><br><span class="line"></span><br><span class="line">res = requests.post(<span class="string">&#x27;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=jHUoq7NLRtijZz4RaVUHxnZC&amp;client_secret=jqBWDRAkrWlB3mKzjkGYRoTxW8fgpW5m&#x27;</span>)</span><br><span class="line"><span class="comment">#获取access_token</span></span><br><span class="line"></span><br><span class="line">access_token = res.json()[<span class="string">&#x27;access_token&#x27;</span>]</span><br><span class="line">print(access_token)</span><br><span class="line"><span class="comment">#开始智能识图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#接口地址，访问ulr</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://aip.baidubce.com/rest/2.0/ocr/v1/accurate_basic?access_token=&#x27;</span>+access_token</span><br><span class="line"><span class="comment">#定义请求头</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>:<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#操作图片</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#读取图片</span></span><br><span class="line"></span><br><span class="line">myimg = open(<span class="string">&#x27;../code.png&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">img_temp = myimg.read()</span><br><span class="line">myimg.close()</span><br><span class="line"><span class="comment">#对图片进行base64编码</span></span><br><span class="line"></span><br><span class="line">temp_data = &#123;</span><br><span class="line">    <span class="string">&#x27;image&#x27;</span>:base64.b64encode(img_temp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#对图片地址进行urlencode操作</span></span><br><span class="line"></span><br><span class="line">temp_data = urllib.parse.urlencode(temp_data)</span><br><span class="line"><span class="comment">#发起post请求</span></span><br><span class="line"></span><br><span class="line">res = requests.post(url=url,headers=headers,data=temp_data)</span><br><span class="line">res_list = res.json()</span><br><span class="line">print(res_list)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res_list[<span class="string">&#x27;words_result&#x27;</span>]:</span><br><span class="line">    code = i[<span class="string">&#x27;words&#x27;</span>].replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    print(code)</span><br><span class="line"></span><br></pre><hr>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化底层</title>
      <link href="/2018/10/23/%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82/"/>
      <url>/2018/10/23/%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h3 id="DRF的核心-就是-前后端分离的核心"><a href="#DRF的核心-就是-前后端分离的核心" class="headerlink" title="DRF的核心 就是 前后端分离的核心"></a>DRF的核心 就是 前后端分离的核心</h3><h4 id="前后端分离开发的核心：-将模型转换为json-称之为-序列化-将json转换为模型-称之为-反序列化"><a href="#前后端分离开发的核心：-将模型转换为json-称之为-序列化-将json转换为模型-称之为-反序列化" class="headerlink" title="前后端分离开发的核心： 将模型转换为json 称之为 序列化 将json转换为模型 称之为 反序列化"></a>前后端分离开发的核心： 将模型转换为json 称之为 序列化 将json转换为模型 称之为 反序列化</h4><h4 id="制作序列化类"><a href="#制作序列化类" class="headerlink" title="制作序列化类"></a>制作序列化类</h4><pre class="highlight"><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> myapp.models <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">userlSer</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model=User</span><br><span class="line">        fields = <span class="string">&#x27;__all__&#x27;</span></span><br><span class="line"></span><br></pre><hr><h6 id="序列化底层是根据-sql语句查出的结果集在进行json格式化"><a href="#序列化底层是根据-sql语句查出的结果集在进行json格式化" class="headerlink" title="序列化底层是根据 sql语句查出的结果集在进行json格式化"></a>序列化底层是根据 sql语句查出的结果集在进行json格式化</h6><p>我们就来实现一下原理</p><pre class="highlight"><span class="line"><span class="comment"># 导入原生sql模块</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Search</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="comment"># 检索字段</span></span><br><span class="line">        text = eval(request.GET.get(<span class="string">&#x27;text&#x27;</span>,<span class="literal">None</span>))</span><br><span class="line">        <span class="comment"># 建立游标对象</span></span><br><span class="line">        cursor=connection.cursor()</span><br><span class="line">        <span class="comment"># 执行sql语句</span></span><br><span class="line">        cursor.execute(<span class="string">&quot;select * from goods where name like &#x27;%%%s%%&#x27;&quot;</span> %text)</span><br><span class="line">        <span class="comment"># 查询</span></span><br><span class="line">        res=dictfetch(cursor)</span><br><span class="line">        <span class="comment"># 判断长度</span></span><br><span class="line">        count=len(res)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;msg&#x27;</span>:text,<span class="string">&quot;data&quot;</span>:res,<span class="string">&#x27;total&#x27;</span>:count&#125;)</span><br><span class="line"></span><br></pre><h6 id="在执行查询的部分-我们调用了dictfetch-函数-因为游标查询出的数据是元祖形式-但是与前端类型不符合-函数内的逻辑就是-将查询出的数据-进行列表嵌套键值对的二次重组"><a href="#在执行查询的部分-我们调用了dictfetch-函数-因为游标查询出的数据是元祖形式-但是与前端类型不符合-函数内的逻辑就是-将查询出的数据-进行列表嵌套键值对的二次重组" class="headerlink" title="在执行查询的部分 我们调用了dictfetch 函数   因为游标查询出的数据是元祖形式 但是与前端类型不符合   函数内的逻辑就是 将查询出的数据 进行列表嵌套键值对的二次重组"></a>在执行查询的部分 我们调用了dictfetch 函数   因为游标查询出的数据是元祖形式 但是与前端类型不符合   函数内的逻辑就是 将查询出的数据 进行列表嵌套键值对的二次重组</h6><pre class="highlight"><span class="line"><span class="comment">#  格式化结果集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dictfetch</span>(<span class="params">cursor</span>):</span></span><br><span class="line">    <span class="comment"># 声明描述符 description获取字段名</span></span><br><span class="line">    desc= cursor.description</span><br><span class="line">    <span class="comment"># 重组结果</span></span><br><span class="line">    <span class="keyword">return</span> [dict(zip([col[<span class="number">0</span>] <span class="keyword">for</span> col <span class="keyword">in</span> desc],row))</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> cursor.fetchall()</span><br><span class="line">    ]</span><br></pre><h3 id="zip-函数将可迭代对象作为参数，并打包成元组-之后在使用dict将tuple-转换为键值对"><a href="#zip-函数将可迭代对象作为参数，并打包成元组-之后在使用dict将tuple-转换为键值对" class="headerlink" title="zip()函数将可迭代对象作为参数，并打包成元组    之后在使用dict将tuple 转换为键值对"></a>zip()函数将可迭代对象作为参数，并打包成元组    之后在使用dict将tuple 转换为键值对</h3><pre class="highlight"><span class="line">[(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)]</span><br><span class="line"></span><br></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化的使用</title>
      <link href="/2018/10/13/%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/10/13/%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="rest-framework的下载"><a href="#rest-framework的下载" class="headerlink" title="rest_framework的下载"></a>rest_framework的下载</h2><pre class="highlight"><span class="line">pip install djangorestframework</span><br></pre><hr><h3 id="在settings中注册rest-framework"><a href="#在settings中注册rest-framework" class="headerlink" title="在settings中注册rest_framework"></a>在settings中注册rest_framework</h3><pre class="highlight"><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;corsheaders&#x27;</span>,    <span class="comment">#后端跨域</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;rest_framework&#x27;</span>,   <span class="comment">#rest_framework框架</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;myapp&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;dwebsocket&#x27;</span></span><br><span class="line">]</span><br></pre><hr><h3 id="在django的app中创建一个serializers-py文件"><a href="#在django的app中创建一个serializers-py文件" class="headerlink" title="在django的app中创建一个serializers.py文件"></a>在django的app中创建一个serializers.py文件</h3><pre class="highlight"><span class="line"><span class="comment">#导包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入需要序列化的表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> myapp.models <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#建立序列化类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarouselSer</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    <span class="comment">#针对表进行序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Carousel <span class="comment">#表名</span></span><br><span class="line"></span><br><span class="line">        fields = <span class="string">&#x27;__all__&#x27;</span>    <span class="comment">#所有字段</span></span><br></pre><hr><h3 id="在views视图中"><a href="#在views视图中" class="headerlink" title="在views视图中"></a>在views视图中</h3><pre class="highlight"><span class="line"><span class="keyword">from</span> myapp.myser <span class="keyword">import</span> *  <span class="comment">#导入序列器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetCarousel</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="comment">#读库</span></span><br><span class="line"></span><br><span class="line">        carousels = Carousel.objects.all()</span><br><span class="line">        <span class="comment">#序列化操作</span></span><br><span class="line"></span><br><span class="line">        carousels_ser = CarouselSer(carousels,many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(carousels_ser.data)</span><br></pre><hr><h3 id="使用序列化的增删改查操作"><a href="#使用序列化的增删改查操作" class="headerlink" title="使用序列化的增删改查操作"></a>使用序列化的增删改查操作</h3><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetCarousel</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="comment">#查询操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="comment">#读库</span></span><br><span class="line"></span><br><span class="line">        carousels = Carousel.objects.all()</span><br><span class="line">        <span class="comment">#序列化操作</span></span><br><span class="line"></span><br><span class="line">        carousels_ser = CarouselSer(carousels,many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;data&#x27;</span>:carousels_ser.data&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#添加操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        name = request.data.get(<span class="string">&#x27;name&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">        src = request.data.get(<span class="string">&#x27;link&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">        img = request.data.get(<span class="string">&#x27;imgs&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">        ser = Carousel.objects.filter(name=name).first()</span><br><span class="line">        <span class="keyword">if</span> ser:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;msg&#x27;</span>:<span class="string">&#x27;幻灯片已存在&#x27;</span>&#125;)</span><br><span class="line">        carousel = Carousel(name=name,src=src,img=img)</span><br><span class="line">        carousel.save() <span class="comment">#保存入库</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;添加成功&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#删除操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        id = request.GET.get(<span class="string">&#x27;id&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">        Carousel.objects.filter(id=id).delete()</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;删除成功&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#修改操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        id = request.data.get(<span class="string">&#x27;id&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">        name = request.data.get(<span class="string">&#x27;name&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">        src = request.data.get(<span class="string">&#x27;link&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">        img = request.data.get(<span class="string">&#x27;imgs&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">        car = Carousel.objects.filter(id=id).first()</span><br><span class="line">        car.name = name</span><br><span class="line">        car.src = src</span><br><span class="line">        car.img = img</span><br><span class="line">        car.save()</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;code&#x27;</span>:<span class="number">200</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;修改成功&#x27;</span>&#125;)</span><br></pre><h2 id="rest-framework自带增删改查四种方法"><a href="#rest-framework自带增删改查四种方法" class="headerlink" title="rest_framework自带增删改查四种方法"></a>rest_framework自带增删改查四种方法</h2><pre class="highlight"><span class="line">查询：get：Carousel.objects.all() ---&gt;method:&#39;GET&#39;</span><br><span class="line">增加：post：carousel.save()       ---&gt;method:&#39;POST(data)&#39;,request.data.get()</span><br><span class="line">删除：delete：Carousel.objects.filter(id&#x3D;id).delete() ---&gt;method:&#39;DELETE(params)&#39;,request.GET.get()</span><br><span class="line">修改：put：carousel.save()        ---&gt;method:&#39;PUT(data)&#39;,request.data.get()</span><br></pre><hr><h3 id="vue代码"><a href="#vue代码" class="headerlink" title="vue代码"></a>vue代码</h3><pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;center&gt;</span><br><span class="line">            &lt;table border=<span class="string">&quot;1&quot;</span> style=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        名称</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        链接</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        图片</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        添加</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        修改</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        删除</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">                &lt;tr v-<span class="keyword">for</span>=<span class="string">&quot;(item,index) in lunbo_list&quot;</span> :key=<span class="string">&quot;index&quot;</span>&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        &amp;emsp;&amp;emsp;            &#123;&#123;item.name&#125;&#125;           &amp;emsp;&amp;emsp;</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        &amp;emsp;&amp;emsp;        &lt;a :href=&quot;item.src&quot; target=&quot;_black&quot;&gt;&#123;&#123;item.src&#125;&#125;&lt;/a&gt;        &amp;emsp;&amp;emsp;</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        &amp;emsp;&amp;emsp;        &lt;img :src=<span class="string">&quot;item.img&quot;</span> alt=<span class="string">&quot;&quot;</span>&gt;        &amp;emsp;&amp;emsp;</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        &amp;emsp;&amp;emsp;        &lt;Button color=&quot;green&quot; @click=&quot;put_lunbo(item.id)&quot;&gt;修改&lt;/Button&gt;     &amp;emsp;&amp;emsp;</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        &amp;emsp;&amp;emsp;        &lt;Button color=&quot;red&quot; @click=&quot;del_lunbo(item.id)&quot;&gt;删除&lt;/Button&gt;       &amp;emsp;&amp;emsp;</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;table&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    name：&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;name&quot;</span>&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    img：&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;imgs&quot;</span>&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    src：&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;link&quot;</span>&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;br&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                    &amp;emsp;&amp;emsp;        &lt;Button color=&quot;blue&quot; @click=&quot;add_lunbo&quot;&gt;添加&lt;/Button&gt;      &amp;emsp;&amp;emsp;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                name：&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;name&quot;</span>&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                img：&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;imgs&quot;</span>&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                src：&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;link&quot;</span>&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">                &amp;emsp;&amp;emsp;        &lt;Button color=&quot;blue&quot; @click=&quot;put_lunbo1&quot;&gt;修改&lt;/Button&gt;      &amp;emsp;&amp;emsp;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">    &lt;/center&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            lunbo_list:[],</span><br><span class="line">            name:<span class="string">&quot;&quot;</span>,</span><br><span class="line">            link:<span class="string">&quot;&quot;</span>,</span><br><span class="line">            imgs:<span class="string">&quot;&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        this.lunbo();</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        lunbo()&#123;</span><br><span class="line">            this.axios(&#123;</span><br><span class="line">                url:<span class="string">&#x27;http://localhost:8000/getcarousel/&#x27;</span>,</span><br><span class="line">                method:<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">            &#125;).then(resp=&gt;&#123;</span><br><span class="line">                console.log(resp)</span><br><span class="line">                this.lunbo_list = resp.data.data</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        //增加</span><br><span class="line">        add_lunbo()&#123; </span><br><span class="line">            this.axios(&#123;</span><br><span class="line">                url:<span class="string">&#x27;http://127.0.0.1:8000/getcarousel/&#x27;</span>,</span><br><span class="line">                method:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">                data:&#123;</span><br><span class="line">                    name:this.name,</span><br><span class="line">                    link:this.link,</span><br><span class="line">                    imgs:this.imgs,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).then(resp=&gt;&#123;</span><br><span class="line">                console.log(resp)              </span><br><span class="line">                this.$router.go(<span class="number">0</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        //删除</span><br><span class="line">        del_lunbo(id)&#123;</span><br><span class="line">            this.axios(&#123;</span><br><span class="line">                url:<span class="string">&#x27;http://127.0.0.1:8000/getcarousel/&#x27;</span>,</span><br><span class="line">                method:<span class="string">&#x27;DELETE&#x27;</span>,</span><br><span class="line">                params:&#123;</span><br><span class="line">                    id:id</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).then(resp=&gt;&#123;</span><br><span class="line">                console.log(resp)</span><br><span class="line">                alert(resp.data.msg)</span><br><span class="line">                this.$router.go(<span class="number">0</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        //修改跳转</span><br><span class="line">        put_lunbo(id)&#123;</span><br><span class="line">            //网页跳转传递id</span><br><span class="line">            this.$router.push(&#123;<span class="string">&#x27;path&#x27;</span>:<span class="string">&#x27;/my_lunbo&#x27;</span>,query:&#123;<span class="string">&#x27;aid&#x27;</span>:id&#125;&#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        //修改</span><br><span class="line">        put_lunbo1()&#123;</span><br><span class="line">            this.axios(&#123;</span><br><span class="line">                url:<span class="string">&#x27;http://127.0.0.1:8000/getcarousel/&#x27;</span>,</span><br><span class="line">                method:<span class="string">&#x27;PUT&#x27;</span>,//指定修改方法</span><br><span class="line">                data:&#123;</span><br><span class="line">                    id:this.$route.query.aid,</span><br><span class="line">                    name:this.name,</span><br><span class="line">                    link:this.link,</span><br><span class="line">                    imgs:this.imgs,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).then(resp=&gt;&#123;</span><br><span class="line">                console.log(resp)</span><br><span class="line">                alert(resp.data.msg)</span><br><span class="line">                this.$router.go(<span class="number">0</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">img&#123;</span><br><span class="line">    width: <span class="number">100</span>px;</span><br><span class="line">    height: <span class="number">100</span>px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用python发送QQ邮件</title>
      <link href="/2018/10/10/%E4%BD%BF%E7%94%A8python%E5%8F%91%E9%80%81QQ%E9%82%AE%E4%BB%B6/"/>
      <url>/2018/10/10/%E4%BD%BF%E7%94%A8python%E5%8F%91%E9%80%81QQ%E9%82%AE%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="这里用到了Python的两个包来发送邮件：-smtplib-和-email-。"><a href="#这里用到了Python的两个包来发送邮件：-smtplib-和-email-。" class="headerlink" title="这里用到了Python的两个包来发送邮件： smtplib 和 email 。"></a>这里用到了Python的两个包来发送邮件： smtplib 和 email 。</h3><p>Python 的 <strong>email</strong> 模块里包含了许多实用的邮件格式设置函数，可以用来创建邮件“包裹”。使用的 MIMEText 对象，为底层的 MIME（Multipurpose Internet MailExtensions，多用途互联网邮件扩展类型）协议传输创建了一封空邮件，最后通过高层的SMTP 协议发送出去。 MIMEText 对象 <strong>msg</strong> 包括收发邮箱地址、邮件正文和主题，Python 通过它就可以创建一封格式正确的邮件。smtplib 模块用来设置服务器连接的相关信息。<br>　　要想通过QQ邮箱来发送邮件，需要开启QQ邮箱的设置-账户里<strong>SMTP服务</strong>，接下来会通过发送短信验证来获得<strong>授权码</strong>，有了授权码后就可以在代码里添加了。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTAwMTc1My8yMDE3MDQvMTAwMTc1My0yMDE3MDQxMjIxNTAyODExMS0xMDg1MjI3NTc1LnBuZw?x-oss-process=image/format,png" alt="alt" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTAwMTc1My8yMDE3MDQvMTAwMTc1My0yMDE3MDQxMjIxNTAyODExMS0xMDg1MjI3NTc1LnBuZw?x-oss-process=image/format,png" class="lozad post-image">        接下来看看QQ的邮件服务器配置：</p><h6 id="使用SSL的通用配置：pop-qq-com，使用SSL，端口号995"><a href="#使用SSL的通用配置：pop-qq-com，使用SSL，端口号995" class="headerlink" title="使用SSL的通用配置：pop.qq.com，使用SSL，端口号995"></a>使用SSL的通用配置：pop.qq.com，使用SSL，端口号995</h6><h6 id="发送邮件服务器：smtp-qq-com，使用SSL，端口号465或587"><a href="#发送邮件服务器：smtp-qq-com，使用SSL，端口号465或587" class="headerlink" title="发送邮件服务器：smtp.qq.com，使用SSL，端口号465或587"></a>发送邮件服务器：smtp.qq.com，使用SSL，端口号465或587</h6><p>根据此配置来设置smtplib.SMTP_SSL()函数的参数。<br>具体代码如下：</p><pre class="highlight"><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"></span><br><span class="line"><span class="comment"># come_from 是自己的邮箱，password是邮箱的授权码</span></span><br><span class="line">come_from = <span class="string">&#x27;3426628229@qq.com&#x27;</span>  <span class="comment">#  用户是谁  用户名</span></span><br><span class="line">password = <span class="string">&#x27;qtyohkdcrbozdbcf&#x27;</span>   <span class="comment">#  秘钥串  相当于密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  to_email 是接收的邮箱</span></span><br><span class="line">to_email = <span class="string">&#x27;1052117505@qq.com&#x27;</span>  <span class="comment">#  要发送给谁</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 邮箱服务器</span></span><br><span class="line">smtp_server = <span class="string">&#x27;smtp.qq.com&#x27;</span></span><br><span class="line"></span><br><span class="line">infos = <span class="string">&#x27;董老师好，我是海日汉，有机会来我们大内蒙骑马丫~~&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  邮箱正文，第一个参数为内容，第二个参数为格式，默认为纯文本，第三个参数是编码</span></span><br><span class="line"><span class="comment">#  这里我用把发送内容赋值给变量infos</span></span><br><span class="line">msg = MIMEText(infos,<span class="string">&#x27;plain&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#  邮件头部信息</span></span><br><span class="line">msg[<span class="string">&#x27;From&#x27;</span>] = Header(come_from)</span><br><span class="line"><span class="comment">#  发送给谁</span></span><br><span class="line">msg[<span class="string">&#x27;To&#x27;</span>] = Header(to_email)</span><br><span class="line"><span class="comment">#  邮件主题</span></span><br><span class="line">msg[<span class="string">&#x27;Subject&#x27;</span>] = Header(<span class="string">&#x27;1908大实训&#x27;</span>)</span><br><span class="line"><span class="comment">#  创建实例</span></span><br><span class="line">server = smtplib.SMTP_SSL(smtp_server)</span><br><span class="line"><span class="comment">#  QQ邮箱SMTP的端口号时465或者587</span></span><br><span class="line">server.connect(smtp_server,<span class="number">465</span>)</span><br><span class="line"><span class="comment">#  登录邮件</span></span><br><span class="line">server.login(come_from,password)</span><br><span class="line"><span class="comment">#  发送邮件</span></span><br><span class="line">server.sendmail(come_from,to_email,msg.as_string())</span><br><span class="line">print(<span class="string">&#x27;邮件已发送&#x27;</span>)</span><br><span class="line"><span class="comment">#  退出邮件</span></span><br><span class="line">server.quit()</span><br><span class="line"></span><br><span class="line"></span><br></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现微博第三方登录</title>
      <link href="/2018/10/02/%E5%AE%9E%E7%8E%B0%E5%BE%AE%E5%8D%9A%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/"/>
      <url>/2018/10/02/%E5%AE%9E%E7%8E%B0%E5%BE%AE%E5%8D%9A%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h6 id="在微博网站-注册使用apphttps-open-weibo-com"><a href="#在微博网站-注册使用apphttps-open-weibo-com" class="headerlink" title="在微博网站 注册使用apphttps://open.weibo.com/"></a>在微博网站 注册使用app<a href="https://open.weibo.com/">https://open.weibo.com/</a></h6><h5 id="登录账号选择网站接入"><a href="#登录账号选择网站接入" class="headerlink" title="登录账号选择网站接入"></a>登录账号选择网站接入</h5><p><img src="/myimg/%E7%BD%91%E7%AB%99%E6%8E%A5%E5%85%A5.png" alt="~````" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/myimg/%E7%BD%91%E7%AB%99%E6%8E%A5%E5%85%A5.png" class="lozad post-image"></p><hr><h5 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h5><p><img src="/myimg/%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8.png" alt="~````" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/myimg/%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8.png" class="lozad post-image"></p><hr><h5 id="应用创建成功后，会立即跳转审核页面，需要填写一些资质，用来进行审核，其实这些审核字段都不用搭理，应用压根就不需要通过审核"><a href="#应用创建成功后，会立即跳转审核页面，需要填写一些资质，用来进行审核，其实这些审核字段都不用搭理，应用压根就不需要通过审核" class="headerlink" title="应用创建成功后，会立即跳转审核页面，需要填写一些资质，用来进行审核，其实这些审核字段都不用搭理，应用压根就不需要通过审核"></a>应用创建成功后，会立即跳转审核页面，需要填写一些资质，用来进行审核，其实这些审核字段都不用搭理，应用压根就不需要通过审核</h5><p><img src="/myimg/3.png" alt="~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/myimg/3.png" class="lozad post-image"></p><hr><h5 id="之后填写指定的回调路径"><a href="#之后填写指定的回调路径" class="headerlink" title="之后填写指定的回调路径"></a>之后填写指定的回调路径</h5><p><img src="/myimg/%E5%9B%9E%E8%B0%83%E4%BF%A1%E6%81%AF.png" alt="~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/myimg/%E5%9B%9E%E8%B0%83%E4%BF%A1%E6%81%AF.png" class="lozad post-image"></p><hr><h5 id="此时我们有了-App-Key-App-Secret-回调页-需要构思编码的流程"><a href="#此时我们有了-App-Key-App-Secret-回调页-需要构思编码的流程" class="headerlink" title="此时我们有了 App Key App Secret 回调页 需要构思编码的流程"></a>此时我们有了 App Key App Secret 回调页 需要构思编码的流程</h5><p><img src="/myimg/%E6%80%9D%E8%B7%AF.png" alt="~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/myimg/%E6%80%9D%E8%B7%AF.png" class="lozad post-image"></p><hr><h5 id="首先根据-app-key-来访问请求API接口"><a href="#首先根据-app-key-来访问请求API接口" class="headerlink" title="首先根据 app key 来访问请求API接口"></a>首先根据 app key 来访问请求API接口</h5><pre class="highlight"><span class="line">//新浪微博第三方登录</span><br><span class="line">sina()&#123;</span><br><span class="line">    let client_id=<span class="number">2464168997</span></span><br><span class="line">    let url=<span class="string">&quot;https://api.weibo.com/oauth2/authorize?client_id=&quot;</span>+client_id+<span class="string">&quot;&amp;redirect_uri=回调路由&quot;</span></span><br><span class="line">    window.location.href=url</span><br><span class="line">&#125;</span><br></pre><hr><h5 id="在指定回调路由下-接受参数"><a href="#在指定回调路由下-接受参数" class="headerlink" title="在指定回调路由下 接受参数"></a>在指定回调路由下 接受参数</h5><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wb_back</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 初始返回一个code</span></span><br><span class="line">    code=request.GET.get(<span class="string">&#x27;code&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># 微博接口地址</span></span><br><span class="line">    access_token_url = <span class="string">&quot;https://api.weibo.com/oauth2/access_token&quot;</span></span><br><span class="line">    <span class="comment"># 定义参数</span></span><br><span class="line">    re = requests.post(access_token_url, data=&#123;</span><br><span class="line">        <span class="string">&quot;client_id&quot;</span>: <span class="string">&#x27;app key&#x27;</span>,</span><br><span class="line">        <span class="string">&quot;client_secret&quot;</span>: <span class="string">&quot;secert key&quot;</span>,</span><br><span class="line">        <span class="string">&quot;grant_type&quot;</span>: <span class="string">&quot;authorization_code&quot;</span>,</span><br><span class="line">        <span class="string">&quot;code&quot;</span>: code,</span><br><span class="line">        <span class="string">&quot;redirect_uri&quot;</span>: <span class="string">&quot;回调路由&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment"># 获取用户信息</span></span><br><span class="line">    res=requests.get(<span class="string">&#x27;https://api.weibo.com/2/users/show.json&#x27;</span>,params=&#123;<span class="string">&quot;access_token&quot;</span>:re.json()[<span class="string">&quot;access_token&quot;</span>],<span class="string">&quot;uid&quot;</span>:re.json()[<span class="string">&quot;uid&quot;</span>]&#125;)</span><br><span class="line">    <span class="comment"># res.json（）就是用户登录的信息</span></span><br><span class="line">    print(res.json())</span><br><span class="line">上面代码实现了接受用户的参数</span><br><span class="line"></span><br><span class="line">下面根据用户参数实现一些判断逻辑</span><br><span class="line"></span><br><span class="line">    username=str(res.json()[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line">    <span class="comment"># 判断是否用新浪微博登录过</span></span><br><span class="line">    user=User.objects.filter(username=username).first()</span><br><span class="line">    sina_id=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    user_id=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> user:</span><br><span class="line">        <span class="comment"># 代表曾经登录过</span></span><br><span class="line">        sina_id=user.username</span><br><span class="line">        user_id=user.id</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 首次登陆</span></span><br><span class="line">        User(username=username,password=res.json()[<span class="string">&#x27;id&#x27;</span>]).save()</span><br><span class="line">        user=User.objects.filter(username=username).first()</span><br><span class="line">        sina_id=user.username</span><br><span class="line">        user_id=user.id</span><br><span class="line"></span><br><span class="line">    print(sina_id,user_id)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 重定向到主页 并传递参数</span></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&quot;http://localhost:8080?sina_id=&quot;</span>+str(sina_id)+<span class="string">&quot;&amp;uid=&quot;</span>+str(user_id))</span><br><span class="line">前端解析后端传递的参数</span><br><span class="line"></span><br><span class="line">var sina_id = this.$route.query.sina_id;</span><br><span class="line">var user_id = this.$route.query.uid;</span><br><span class="line"><span class="keyword">if</span> (sina_id)&#123;</span><br><span class="line">    // 自动帮用户登录</span><br><span class="line">    localStorage.setItem(<span class="string">&#x27;username&#x27;</span>,sina_id)</span><br><span class="line">    localStorage.setItem(<span class="string">&#x27;uid&#x27;</span>,user_id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre><hr>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切换主题模式</title>
      <link href="/2018/09/27/%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/09/27/%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设置主题按钮，点击即从白天模式切换为暗黑模式：背景色由白转黑，字体颜色由黑转白。"><a href="#设置主题按钮，点击即从白天模式切换为暗黑模式：背景色由白转黑，字体颜色由黑转白。" class="headerlink" title="设置主题按钮，点击即从白天模式切换为暗黑模式：背景色由白转黑，字体颜色由黑转白。"></a>设置主题按钮，点击即从白天模式切换为暗黑模式：背景色由白转黑，字体颜色由黑转白。</h3><ol><li>首先在前端查找控制背景色的style样式是由哪个属性控制的。<br><img src="/hugoblog/ppp.png" alt="~~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/ppp.png" class="lozad post-image"></li></ol><h6 id="找到是-header中的background控制的。"><a href="#找到是-header中的background控制的。" class="headerlink" title="找到是.header中的background控制的。"></a>找到是.header中的background控制的。</h6><h6 id="从main-js发现样式是从-src-assets-bootstrap-style-css引入的。"><a href="#从main-js发现样式是从-src-assets-bootstrap-style-css引入的。" class="headerlink" title="从main.js发现样式是从/src/assets/bootstrap/style.css引入的。"></a>从main.js发现样式是从/src/assets/bootstrap/style.css引入的。</h6><hr><h3 id="定义背景颜色变量，然后将定义的变量替换为写死的背景变量；然后前端设置按钮，封装改变背景变量的方法。"><a href="#定义背景颜色变量，然后将定义的变量替换为写死的背景变量；然后前端设置按钮，封装改变背景变量的方法。" class="headerlink" title="定义背景颜色变量，然后将定义的变量替换为写死的背景变量；然后前端设置按钮，封装改变背景变量的方法。"></a>定义背景颜色变量，然后将定义的变量替换为写死的背景变量；然后前端设置按钮，封装改变背景变量的方法。</h3><pre class="highlight"><span class="line">/* 定义变量 */</span><br><span class="line"> :root&#123;</span><br><span class="line">  --bg-color:<span class="comment">#fff;</span></span><br><span class="line">  --a-color:black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.navbar-brand, a.logo &#123;</span><br><span class="line">  font-family: <span class="string">&quot;Lato&quot;</span>, <span class="string">&quot;Helvetica Neue&quot;</span>, Helvetica, Arial, sans-serif;</span><br><span class="line">  color: var(--a-color);</span><br><span class="line">  font-size: <span class="number">2</span>rem;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  margin-top: <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">.header &#123;</span><br><span class="line">  /* 使用变量 */</span><br><span class="line">  background:var(--bg-color);</span><br><span class="line">  min-height: <span class="number">7</span>em;</span><br></pre><hr><ol start="2"><li>定义变量<pre class="highlight"><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">  //夜间模式切换开关信息</span><br><span class="line">  style_night:<span class="string">&#x27;夜间模式&#x27;</span>,</span><br><span class="line">  style:<span class="number">0</span>,</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></li></ol><hr><h3 id="在前端vue页面methods里定义开关切换主题方法。"><a href="#在前端vue页面methods里定义开关切换主题方法。" class="headerlink" title="在前端vue页面methods里定义开关切换主题方法。"></a>在前端vue页面methods里定义开关切换主题方法。</h3><pre class="highlight"><span class="line"> methods:&#123;</span><br><span class="line">      //按钮切换主题颜色方法</span><br><span class="line">      change_back:function()&#123;</span><br><span class="line">        console.log(this.style)</span><br><span class="line">          <span class="keyword">if</span>(this.style==true)&#123;</span><br><span class="line">                //获取样式表 所有节点</span><br><span class="line">                var styles = getComputedStyle(document.documentElement)</span><br><span class="line">                //动态更改 背景颜色</span><br><span class="line">                document.documentElement.style.setProperty(<span class="string">&quot;--bg-color&quot;</span>,<span class="string">&quot;#292a2d&quot;</span>);</span><br><span class="line">                //字体颜色</span><br><span class="line">                document.documentElement.style.setProperty(<span class="string">&quot;--a-color&quot;</span>,<span class="string">&quot;white&quot;</span>)</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              //获取样式表 所有节点</span><br><span class="line">                var styles = getComputedStyle(document.documentElement)</span><br><span class="line">                //动态更改 背景颜色</span><br><span class="line">                document.documentElement.style.setProperty(<span class="string">&quot;--bg-color&quot;</span>,<span class="string">&quot;white&quot;</span>);</span><br><span class="line">                //字体颜色</span><br><span class="line">                document.documentElement.style.setProperty(<span class="string">&quot;--a-color&quot;</span>,<span class="string">&quot;black&quot;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">      &#125;,</span><br><span class="line">&#125;</span><br></pre><hr><h3 id="最后设置一个开关，绑定切换主题方法和变量。"><a href="#最后设置一个开关，绑定切换主题方法和变量。" class="headerlink" title="最后设置一个开关，绑定切换主题方法和变量。"></a>最后设置一个开关，绑定切换主题方法和变量。</h3><pre class="highlight"><span class="line">&lt;h-switch v-model=&quot;style&quot; @change=&quot;change_back&quot; &gt;&#123;&#123;style_night&#125;&#125;&lt;/h-switch&gt;</span><br></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七牛云存储</title>
      <link href="/2018/09/22/%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8/"/>
      <url>/2018/09/22/%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h6 id="当今有很多云服务-比如什么百度云-阿里云-可以自己的文件存储到云端服务器进行保存-好处是-防止占用空间-防止数据丢失-一劳永逸-而我们结合云端存储-将数据存储到云端服务器中-而就防止我们自己的服务器的空间占用大-当用户使用数据时-服务器就像中间桥一样进行链接-用户-服务器-云端数据-而我们思路就是在用户上传文件的时候就上传到云端，而本地数据库只是更改一下文件名-这样在访问的时候根据域名-文件名就可以展示出文件"><a href="#当今有很多云服务-比如什么百度云-阿里云-可以自己的文件存储到云端服务器进行保存-好处是-防止占用空间-防止数据丢失-一劳永逸-而我们结合云端存储-将数据存储到云端服务器中-而就防止我们自己的服务器的空间占用大-当用户使用数据时-服务器就像中间桥一样进行链接-用户-服务器-云端数据-而我们思路就是在用户上传文件的时候就上传到云端，而本地数据库只是更改一下文件名-这样在访问的时候根据域名-文件名就可以展示出文件" class="headerlink" title="当今有很多云服务 比如什么百度云 阿里云 可以自己的文件存储到云端服务器进行保存,好处是 防止占用空间 防止数据丢失 一劳永逸,而我们结合云端存储 将数据存储到云端服务器中 而就防止我们自己的服务器的空间占用大,当用户使用数据时 服务器就像中间桥一样进行链接 用户-服务器-云端数据,而我们思路就是在用户上传文件的时候就上传到云端，而本地数据库只是更改一下文件名,这样在访问的时候根据域名+文件名就可以展示出文件"></a>当今有很多云服务 比如什么百度云 阿里云 可以自己的文件存储到云端服务器进行保存,好处是 防止占用空间 防止数据丢失 一劳永逸,而我们结合云端存储 将数据存储到云端服务器中 而就防止我们自己的服务器的空间占用大,当用户使用数据时 服务器就像中间桥一样进行链接 用户-服务器-云端数据,而我们思路就是在用户上传文件的时候就上传到云端，而本地数据库只是更改一下文件名,这样在访问的时候根据域名+文件名就可以展示出文件</h6><h5 id="七牛云流程图"><a href="#七牛云流程图" class="headerlink" title="七牛云流程图"></a>七牛云流程图</h5><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E6%80%9D%E8%B7%AF%E5%9B%BE.png" class="lozad post-image"src="/hugoblog/%E6%80%9D%E8%B7%AF%E5%9B%BE.png"></p><h6 id="先到七牛云注册账号七牛云-之后选择-产品-对象存储-选择使用对象存储并创建空间"><a href="#先到七牛云注册账号七牛云-之后选择-产品-对象存储-选择使用对象存储并创建空间" class="headerlink" title="先到七牛云注册账号七牛云,之后选择 产品-对象存储,选择使用对象存储并创建空间"></a>先到七牛云注册账号七牛云,之后选择 产品-对象存储,选择使用对象存储并创建空间</h6><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E5%88%9B%E5%BB%BA%E7%A9%BA%E9%97%B4.png" class="lozad post-image"src="/hugoblog/%E5%88%9B%E5%BB%BA%E7%A9%BA%E9%97%B4.png"></p><h6 id="之后点击秘钥"><a href="#之后点击秘钥" class="headerlink" title="之后点击秘钥"></a>之后点击秘钥</h6><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E5%AF%86%E9%92%A5.png" class="lozad post-image"src="/hugoblog/%E5%AF%86%E9%92%A5.png"></p><h6 id="python根据秘钥来请求token"><a href="#python根据秘钥来请求token" class="headerlink" title="python根据秘钥来请求token"></a>python根据秘钥来请求token</h6><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E6%9F%A5%E7%9C%8B%E5%AF%86%E9%92%A5.png" class="lozad post-image"src="/hugoblog/%E6%9F%A5%E7%9C%8B%E5%AF%86%E9%92%A5.png"></p><pre class="highlight"><span class="line">python中有一个qiniu的模块</span><br><span class="line"></span><br><span class="line">可以使用该模块 直接请求到token</span><br></pre><pre class="highlight"><span class="line"><span class="comment"># 七牛token</span></span><br><span class="line"><span class="keyword">from</span> qiniu <span class="keyword">import</span>  Auth</span><br><span class="line"><span class="comment"># qiniu 对象会自动请求token</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">    <span class="comment"># 声明认证对象</span></span><br><span class="line">    q = Auth(access_key=<span class="string">&#x27;4CmF2Dy-Xi7PQwHm7Ovpk7YlOiw2pqzUqyf7ybhA&#x27;</span>,</span><br><span class="line">             secret_key=<span class="string">&#x27;y3tlCWWdvmgsm2a9j6Plu_WWM4b0jFRTD-f3bHZ7&#x27;</span>)</span><br><span class="line">    <span class="comment"># 获取token</span></span><br><span class="line">    token=q.upload_token(<span class="string">&#x27;md1907rgzn&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;token&#x27;</span>:token&#125;)</span><br></pre><hr><pre class="highlight"><span class="line">然后前端vue 接受到对应的token 并存入全局变量</span><br></pre><pre class="highlight"><span class="line">get_token()&#123;</span><br><span class="line">    this.axios.get(&quot;http://127.0.0.1:8000/myapp/qiniu/&quot;).then(result =&gt; &#123;</span><br><span class="line">        console.log(result.data.token)</span><br><span class="line">        this.token = result.data.token</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre><hr><h6 id="对表单设置提交按钮的函数"><a href="#对表单设置提交按钮的函数" class="headerlink" title="对表单设置提交按钮的函数"></a>对表单设置提交按钮的函数</h6><pre class="highlight"><span class="line"></span><br><span class="line">// 存入七牛云</span><br><span class="line">upload_qiniu:function()&#123;</span><br><span class="line">    //获取文件</span><br><span class="line">    var img=document.getElementById(<span class="string">&quot;img&quot;</span>)</span><br><span class="line">    //声明表单参数</span><br><span class="line">    let param = new FormData();</span><br><span class="line">    param.append(<span class="string">&quot;img&quot;</span>,img.files[<span class="number">0</span>])</span><br><span class="line">    param.append(<span class="string">&#x27;token&#x27;</span>,this.token);</span><br><span class="line">    //自定义axios 不允许传输cookie</span><br><span class="line">    const axios_qiniu = this.axios.create(&#123;withCredentials:false&#125;);</span><br><span class="line">    //发送请求</span><br><span class="line">    axios_qiniu(&#123;</span><br><span class="line">        method:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        url:<span class="string">&#x27;http://up-z1.qiniup.com/&#x27;</span>,  // 七牛域名</span><br><span class="line">        data:param,</span><br><span class="line">        timeout:<span class="number">30000</span>  //超时设置</span><br><span class="line">    &#125;).then(result =&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(result.status==<span class="number">200</span>)&#123;</span><br><span class="line">            // 拼接七牛空间的域名 进行展示</span><br><span class="line">            this.src = <span class="string">&quot;http://q9ksotoly.bkt.clouddn.com/&quot;</span>+result.data.key;</span><br><span class="line">            // this.videosrc = config[<span class="string">&#x27;baseurl&#x27;</span>]+result.data.key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊查询及关键字高亮</title>
      <link href="/2018/09/17/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B3%E9%94%AE%E5%AD%97%E9%AB%98%E4%BA%AE/"/>
      <url>/2018/09/17/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B3%E9%94%AE%E5%AD%97%E9%AB%98%E4%BA%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="如何实现多条件模糊查询"><a href="#如何实现多条件模糊查询" class="headerlink" title="如何实现多条件模糊查询"></a>如何实现多条件模糊查询</h2><pre class="highlight"><span class="line">在我们一般使用淘宝网站的时候</span><br><span class="line">经常使用一些连词 来精准查询的结果</span><br><span class="line"></span><br><span class="line">例：使用 夏季 鞋子 男 休闲 等词语来指定查找</span><br><span class="line"></span><br><span class="line">那么如何实现该功能呢</span><br></pre><pre class="highlight"><span class="line">&lt;!--实现搜索框--&gt;</span><br><span class="line">&lt;input @change=<span class="string">&#x27;search&#x27;</span> v-model=<span class="string">&quot;text&quot;</span> &gt;</span><br></pre><hr><h3 id="text-变量就是绑定的搜索的参数-我们只需要判断该变量就可以了"><a href="#text-变量就是绑定的搜索的参数-我们只需要判断该变量就可以了" class="headerlink" title="text 变量就是绑定的搜索的参数  我们只需要判断该变量就可以了"></a>text 变量就是绑定的搜索的参数  我们只需要判断该变量就可以了</h3><pre class="highlight"><span class="line">// 查询字符串中是否有空格</span><br><span class="line"><span class="keyword">if</span> (this.text.indexOf(<span class="string">&#x27; &#x27;</span>))&#123;</span><br><span class="line">    //由空格为间隔切片为list</span><br><span class="line">    var text = this.text.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    // 生成list形式的字符串</span><br><span class="line">    text = JSON.stringify(text)</span><br><span class="line">&#125;</span><br></pre><hr><h3 id="对查询参数进行操作-生成字符串：-“value1”-”value2”-在后台接受的参数时将该字符串转换为列表"><a href="#对查询参数进行操作-生成字符串：-“value1”-”value2”-在后台接受的参数时将该字符串转换为列表" class="headerlink" title="对查询参数进行操作 生成字符串：[“value1”,”value2”]   在后台接受的参数时将该字符串转换为列表"></a>对查询参数进行操作 生成字符串：[“value1”,”value2”]   在后台接受的参数时将该字符串转换为列表</h3><pre class="highlight"><span class="line"><span class="comment"># 检索字段</span></span><br><span class="line">text = eval(request.GET.get(<span class="string">&#x27;text&#x27;</span>,<span class="literal">None</span>))</span><br></pre><hr><h3 id="模糊查询操作"><a href="#模糊查询操作" class="headerlink" title="模糊查询操作"></a>模糊查询操作</h3><h5 id="操作思路：循环查询参数-每次查询之后添加进列表"><a href="#操作思路：循环查询参数-每次查询之后添加进列表" class="headerlink" title="操作思路：循环查询参数 每次查询之后添加进列表"></a>操作思路：循环查询参数 每次查询之后添加进列表</h5><pre class="highlight"><span class="line"><span class="comment"># 是否进行模糊查询</span></span><br><span class="line"><span class="keyword">if</span> text:</span><br><span class="line">    goods=[]</span><br><span class="line">    <span class="comment"># 循环条件列表</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> text:</span><br><span class="line">        <span class="comment"># 每次循环 查询数据</span></span><br><span class="line">        good_obj=Goods.objects.filter(Q(name__contains=key)|Q(desc__contains=key)).all()</span><br><span class="line">        <span class="comment"># 向列表尾部拼接</span></span><br><span class="line">        goods.extend(good_obj)</span><br><span class="line">        <span class="comment"># 去重 防止重复 有时重复查询同一个 会出现多数据 就需要去重</span></span><br><span class="line">        goods=list(set(goods))</span><br><span class="line">        count = len(goods)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 查询所有商品个数</span></span><br><span class="line">     count = Goods.objects.count()</span><br></pre><hr><h3 id="关键字高亮Permalink"><a href="#关键字高亮Permalink" class="headerlink" title="关键字高亮Permalink"></a>关键字高亮Permalink</h3><pre class="highlight"><span class="line">在我们访问百度的时候 经常看见自己查询的关键字是红色的</span><br><span class="line"></span><br><span class="line">这是怎么做到的呢</span><br><span class="line"></span><br><span class="line">可以用过滤器来操作</span><br></pre><pre class="highlight"><span class="line">//过滤器</span><br><span class="line"> filters:&#123;</span><br><span class="line"> make_text(str)&#123;</span><br><span class="line">var mytext=str.toString()</span><br><span class="line">var text=<span class="string">&#x27;关键字&#x27;</span></span><br><span class="line">        // new RegExp(text,<span class="string">&#x27;g&#x27;</span>) 正则模式全文检索 </span><br><span class="line"><span class="keyword">return</span> mytext.replace(new RegExp(text,<span class="string">&#x27;g&#x27;</span>),<span class="string">&#x27;&lt;span class=&quot;highlight&quot;&gt;&#x27;</span>+text+<span class="string">&#x27;&lt;/span&gt;&#x27;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br></pre><hr><h6 id="可以实现为-关键字-词语-这样我们就可以设置指定样式来输出了-使用-v-html-来输出"><a href="#可以实现为-关键字-词语-这样我们就可以设置指定样式来输出了-使用-v-html-来输出" class="headerlink" title="可以实现为 关键字 词语   这样我们就可以设置指定样式来输出了   使用 v-html 来输出"></a>可以实现为 <span class="mystyle">关键字<span> 词语   这样我们就可以设置指定样式来输出了   使用 v-html 来输出</h6><pre class="highlight"><span class="line">&lt;!--因为v-html与其他不同 需要以调用方式来使用过滤器--&gt;</span><br><span class="line">&lt;!--如果全局声明了装饰器就不需要 否则就要以$options.filters.装饰器 来使用--&gt;</span><br><span class="line">&lt;span v-html=&#x27;$options.filters.make_text(item.name)&#x27;&gt;&lt;/span&gt;</span><br></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2018/09/10/%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF%E4%BA%94%E6%AC%A1%E4%BB%A5%E4%B8%8A%E8%B4%A6%E5%8F%B7%E9%94%81%E5%AE%9A%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/09/10/%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF%E4%BA%94%E6%AC%A1%E4%BB%A5%E4%B8%8A%E8%B4%A6%E5%8F%B7%E9%94%81%E5%AE%9A%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="利用Redis数据进行密码输入错误锁号的功能限制操作"><a href="#利用Redis数据进行密码输入错误锁号的功能限制操作" class="headerlink" title="利用Redis数据进行密码输入错误锁号的功能限制操作"></a>利用Redis数据进行密码输入错误锁号的功能限制操作</h3><h6 id="1-构造一个计数器"><a href="#1-构造一个计数器" class="headerlink" title="1.构造一个计数器"></a>1.构造一个计数器</h6><pre class="highlight"><span class="line"></span><br><span class="line"><span class="comment"># 导包</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="comment"># 定义ip 和端口号</span></span><br><span class="line">host = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">port = <span class="number">6379</span></span><br><span class="line"><span class="comment"># 建立链接</span></span><br><span class="line">r = redis.Redis(host=host,port=port)</span><br><span class="line"><span class="comment"># 记录插入放入次数</span></span><br><span class="line"><span class="comment"># a = r.incr(‘keys’0)</span></span><br><span class="line"><span class="comment"># print(a)</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">5</span>：</span><br><span class="line">print(<span class="string">&quot;你的账号被锁定了&quot;</span>)</span><br></pre><hr><h6 id="2-通过列表类型的数组"><a href="#2-通过列表类型的数组" class="headerlink" title="2.通过列表类型的数组"></a>2.通过列表类型的数组</h6><pre class="highlight"><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义ip和端口号</span></span><br><span class="line">host = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">port = <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#建立连接</span></span><br><span class="line">r = redis.Redis(host=host,port=port)</span><br><span class="line"><span class="comment">#用户名</span></span><br><span class="line">username = <span class="string">&#x27;laowang&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#账号密码输入错误5次后锁住账号逻辑</span></span><br><span class="line"><span class="comment">#列表操作</span></span><br><span class="line">r.lpush(username,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置过期时间,单位是秒</span></span><br><span class="line">r.expire(username,<span class="number">30</span>)</span><br><span class="line"><span class="comment">#打印过期时间</span></span><br><span class="line">print(r.ttl(username))</span><br><span class="line"><span class="comment">#打印列表长度</span></span><br><span class="line">print(r.llen(username))</span><br><span class="line"><span class="keyword">if</span> r.llen(username) &gt; <span class="number">5</span>:</span><br><span class="line">    print(<span class="string">&#x27;你的账号被锁定&#x27;</span>)</span><br><span class="line"></span><br></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>拦截器</title>
      <link href="/2018/09/04/%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
      <url>/2018/09/04/%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="前端vue-index-js-代码示例："><a href="#前端vue-index-js-代码示例：" class="headerlink" title="前端vue(index.js)代码示例："></a>前端vue(index.js)代码示例：</h4><pre class="highlight"><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  path:<span class="string">&#x27;/myprofile&#x27;</span>,</span><br><span class="line">  name:<span class="string">&#x27;myprofile&#x27;</span>,</span><br><span class="line">  component:myprofile,</span><br><span class="line">  &lt;!-- to去哪，from来自哪，next下一步 --&gt;</span><br><span class="line">  beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(localStorage.getItem(<span class="string">&#x27;username&#x27;</span>))&#123;</span><br><span class="line">      console.log(<span class="string">&#x27;已经登录&#x27;</span>);</span><br><span class="line">      &lt;!-- 注意必须有下一步 --&gt;</span><br><span class="line">      next();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      console.log(<span class="string">&#x27;没有登录&#x27;</span>);</span><br><span class="line">      next(<span class="string">&#x27;/login&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程，线程和协程的区别</title>
      <link href="/2018/09/01/%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/09/01/%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><strong>现在多进程多线程已经是老生常谈了，协程也在最近几年流行起来。python中有协程库gevent，py web框架tornado中也用了gevent封装好的协程。本文主要介绍进程、线程和协程三者之间的区别。</strong></p><h1 id="一-概念"><a href="#一-概念" class="headerlink" title="一.  概念"></a>一.  概念</h1><p><strong>1. 进程</strong></p><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</p><p><strong>2.  线程</strong></p><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</p><p><strong>3. 协程</strong></p><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p><h1 id="二-区别"><a href="#二-区别" class="headerlink" title="二.  区别"></a>二.  区别</h1><p><strong>1， 进程多与线程比较</strong></p><p>线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:</p><ol><li><p>地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间</p></li><li><p>资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源</p></li><li><p>线程是处理器调度的基本单位,但进程不是</p></li><li><p>二者均可并发执行</p></li><li><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</p></li></ol><p><strong>2，协程多与线程进行比较</strong></p><ol><li><p>一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。</p></li><li><p>线程进程都是同步机制，而协程则是异步</p></li><li><p>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</p><h1 id="三-进程和线程、协程在python中的使用"><a href="#三-进程和线程、协程在python中的使用" class="headerlink" title="三.  进程和线程、协程在python中的使用"></a>三.  进程和线程、协程在python中的使用</h1></li><li><p>多进程一般使用multiprocessing库，来利用多核CPU，主要是用在CPU密集型的程序上，当然生产者消费者这种也可以使用。多进程的优势就是一个子进程崩溃并不会影响其他子进程和主进程的运行，但缺点就是不能一次性启动太多进程，会严重影响系统的资源调度，特别是CPU使用率和负载。使用多进程可以查看文章《python 多进程使用总结》。注：python2的进程池在类中的使用会有问题，需要把类函数定义成全局函数。具体可参考 <a href="http://bbs.chinaunix.net/thread-4111379-1-1.html">http://bbs.chinaunix.net/thread-4111379-1-1.html</a></p></li><li><p>多线程一般是使用threading库，完成一些IO密集型并发操作。多线程的优势是切换快，资源消耗低，但一个线程挂掉则会影响到所有线程，所以不够稳定。现实中使用线程池的场景会比较多，具体可参考《python线程池实现》。</p></li><li><p>协程一般是使用gevent库，当然这个库用起来比较麻烦，所以使用的并不是很多。相反，协程在tornado的运用就多得多了，使用协程让tornado做到单线程异步，据说还能解决C10K的问题。所以协程使用的地方最多的是在web应用上。</p><h1 id="四-一个形象的例子解释进程和线程的区别"><a href="#四-一个形象的例子解释进程和线程的区别" class="headerlink" title="四.  一个形象的例子解释进程和线程的区别"></a>四.  一个形象的例子解释进程和线程的区别</h1><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC9hdHRhY2htZW50LzIwMTMxMC8yMy8yOTI3MDYyOF8xMzgyNTQxOTUxbkplNy5qcGc?x-oss-process=image/format,png" class="lozad post-image"src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC9hdHRhY2htZW50LzIwMTMxMC8yMy8yOTI3MDYyOF8xMzgyNTQxOTUxbkplNy5qcGc?x-oss-process=image/format,png"><br>这副图是一个双向多车道的道路图，假如我们<strong>把整条道路看成是一个“进程</strong>”<strong>的话</strong>，那么图中由白色虚线分隔开来的<strong>各个车道就是进程中的各个“线程”</strong>了。</p></li></ol><ul><li><p>这些线程(车道)共享了进程(道路)的公共资源(土地资源)。</p></li><li><p>这些线程(车道)必须依赖于进程(道路)，也就是说，线程不能脱离于进程而存在(就像离开了道路，车道也就没有意义了)。</p></li><li><p>这些线程(车道)之间可以并发执行(各个车道你走你的，我走我的)，也可以互相同步(某些车道在交通灯亮时禁止继续前行或转弯，必须等待其它车道的车辆通行完毕)。</p></li><li><p>这些线程(车道)之间依靠代码逻辑(交通灯)来控制运行，一旦代码逻辑控制有误(死锁，多个线程同时竞争唯一资源)，那么线程将陷入混乱，无序之中。</p></li><li><p>这些线程(车道)之间谁先运行是未知的，只有在线程刚好被分配到CPU时间片(交通灯变化)的那一刻才能知道。</p></li></ul><hr><p><strong>总结一下就是IO密集型一般使用多线程或者多进程，CPU密集型一般使用多进程，强调非阻塞异步并发的一般都是使用协程，当然有时候也是需要多进程线程池结合的，或者是其他组合方式。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>画中画</title>
      <link href="/2018/08/28/%E7%94%BB%E4%B8%AD%E7%94%BB/"/>
      <url>/2018/08/28/%E7%94%BB%E4%B8%AD%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        视频：&lt;video id=&#x27;video&#x27; :src=&quot;img_url&quot; width=&quot;350&quot; height=&quot;240&quot;&gt;&lt;/video&gt;</span><br><span class="line">        &lt;Button @click=&quot;into&quot;&gt;&#123;&#123; this.hzh&#125;&#125;&lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            //画中画</span><br><span class="line">            hzh : <span class="string">&#x27;进入画中画&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        //画中画</span><br><span class="line">        into:function()&#123;</span><br><span class="line">            <span class="keyword">if</span>(video != document.pictureInPictureElement)&#123;</span><br><span class="line">                //尝试进入画中画</span><br><span class="line">                video.requestPictureInPicture();</span><br><span class="line">                this.hzh = <span class="string">&#x27;退出画中画&#x27;</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                //退出画中画</span><br><span class="line">                document.exitPictureInPicture();</span><br><span class="line">                this.hzh = <span class="string">&#x27;进入画中画&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;，</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre><hr>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分页器的使用</title>
      <link href="/2018/08/23/%E5%88%86%E9%A1%B5%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/08/23/%E5%88%86%E9%A1%B5%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="根据商品列表展示分页"><a href="#根据商品列表展示分页" class="headerlink" title="根据商品列表展示分页"></a>根据商品列表展示分页</h3><h6 id="django代码"><a href="#django代码" class="headerlink" title="django代码"></a>django代码</h6><pre class="highlight"><span class="line">url:    path(<span class="string">&#x27;goodslist/&#x27;</span>,GoodsList.as_view()),</span><br><span class="line"><span class="comment">#商品列表分页页</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodsList</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="comment">#当前页</span></span><br><span class="line"></span><br><span class="line">        page = int(request.GET.get(<span class="string">&#x27;page&#x27;</span>,<span class="number">1</span>))</span><br><span class="line">        <span class="comment">#一页显示个数</span></span><br><span class="line"></span><br><span class="line">        size = int(request.GET.get(<span class="string">&#x27;size&#x27;</span>,<span class="number">4</span>))</span><br><span class="line">        <span class="comment">#计算从哪开始切</span></span><br><span class="line"></span><br><span class="line">        data_start = (page<span class="number">-1</span>)*size</span><br><span class="line">        <span class="comment">#计算切到哪</span></span><br><span class="line"></span><br><span class="line">        data_end = page*size</span><br><span class="line">        <span class="comment">#查询 切片操作</span></span><br><span class="line"></span><br><span class="line">        goods = Goods.objects.all()[data_start:data_end]</span><br><span class="line">        <span class="comment">#查询所有个数</span></span><br><span class="line"></span><br><span class="line">        count = Goods.objects.count()</span><br><span class="line">        <span class="comment">#序列化操作</span></span><br><span class="line"></span><br><span class="line">        ser = GoodsSer(goods,many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;data&#x27;</span>:ser.data,<span class="string">&quot;total&quot;</span>:count&#125;)</span><br></pre><hr><h6 id="前端：根据heyui自带的分页器实现"><a href="#前端：根据heyui自带的分页器实现" class="headerlink" title="前端：根据heyui自带的分页器实现"></a>前端：根据heyui自带的分页器实现</h6><pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-<span class="keyword">for</span>=<span class="string">&quot;(item,index) in goodslist&quot;</span> :key=<span class="string">&quot;index&quot;</span>&gt;</span><br><span class="line">      &lt;a :href=&quot;&#x27;http://localhost:8080/item?id=&#x27;+item.id&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/a&gt;</span><br><span class="line">      &lt;p&gt;&lt;span class=&quot;emphasis&quot;&gt;$&#123;&#123;item.price&#125;&#125;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">      &lt;Pagination v-model=&quot;pagination&quot; align=&quot;center&quot; small @change=&quot;get_goods&quot;&gt;&lt;/Pagination&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      //分页器变量</span><br><span class="line">      pagination:&#123;</span><br><span class="line">          //当前页</span><br><span class="line">          page: <span class="number">1</span>,</span><br><span class="line">          //每页多少个</span><br><span class="line">          size: <span class="number">2</span>,</span><br><span class="line">          //总数</span><br><span class="line">          total: <span class="number">4</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted:&#123;</span><br><span class="line">    //调用商品列表分页</span><br><span class="line">    this.get_goods();</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    //获取商品列表</span><br><span class="line">      get_goods()&#123;</span><br><span class="line">        this.axios(&#123;</span><br><span class="line">          url:<span class="string">&#x27;http://localhost:8000/goodslist/&#x27;</span>,</span><br><span class="line">          method:<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">          params:&#123;</span><br><span class="line">            //分页传参</span><br><span class="line">            page:this.pagination.page,</span><br><span class="line">            size:this.pagination.size,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).then(resp=&gt;&#123;</span><br><span class="line">          console.log(resp)</span><br><span class="line">          //获取商品列表和总页码</span><br><span class="line">          this.goodslist = resp.data.data;</span><br><span class="line">          this.pagination.total =resp.data.total;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre><hr><h6 id="前端：自主分页和分页偏移"><a href="#前端：自主分页和分页偏移" class="headerlink" title="前端：自主分页和分页偏移"></a>前端：自主分页和分页偏移</h6><pre class="highlight"><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">&lt;span&gt;&lt;a @click=&quot;get_goods_self(1)&quot;&gt;首页&lt;/a&gt;&lt;/span&gt;</span><br><span class="line">&amp;emsp;&amp;emsp;</span><br><span class="line">&lt;Button v-show=&quot;lastpage&quot; @click=&quot;get_goods_self(lastpage)&quot;&gt;上一页&lt;/Button&gt;</span><br><span class="line">&lt;!-- &lt;span v-for=&quot;index in allpage&quot;&gt;&lt;a @click=&quot;get_goods_self(index)&quot;&gt;&#123;&#123;index&#125;&#125;&lt;/a&gt;&amp;emsp;&amp;emsp;&lt;/span&gt; --&gt;</span><br><span class="line">&lt;!-- 左侧分页偏移 --&gt;</span><br><span class="line">&lt;span v-for=&quot;item in last_page&quot;&gt;&lt;a @click=&quot;get_goods_self(item)&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/a&gt;&amp;emsp;&amp;emsp;&lt;/span&gt;</span><br><span class="line">&lt;!-- 当前页 --&gt;</span><br><span class="line">&lt;a @click=&quot;get_goods_self(page)&quot;&gt;&#123;&#123;page&#125;&#125;&amp;emsp;&amp;emsp;&lt;/a&gt;</span><br><span class="line">&lt;!-- 右侧分页品偏移 --&gt;</span><br><span class="line">&lt;span v-for=&quot;item in next_page&quot;&gt;&lt;a @click=&quot;get_goods_self(item)&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/a&gt;&amp;emsp;&amp;emsp;&lt;/span&gt;</span><br><span class="line">&lt;Button v-show=&quot;nextpage&quot; @click=&quot;get_goods_self(nextpage)&quot;&gt;下一页&lt;/Button&gt;</span><br><span class="line">&lt;!-- 跳转分页  --&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> style=<span class="string">&quot;width:40px;&quot;</span> @input=<span class="string">&quot;jump_page($event)&quot;</span>&gt;</span><br><span class="line">&amp;emsp;&amp;emsp;</span><br><span class="line">&lt;span&gt;&lt;a @click=&quot;get_goods_self(allpage)&quot;&gt;尾页&lt;/a&gt;&lt;/span&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      //上一页</span><br><span class="line">      lastpage:<span class="number">0</span>,</span><br><span class="line">      //下一页</span><br><span class="line">      nextpage:<span class="number">0</span>,</span><br><span class="line">      //当前页</span><br><span class="line">      page:<span class="number">1</span>,</span><br><span class="line">      //每页展示个数</span><br><span class="line">      size:<span class="number">1</span>,</span><br><span class="line">      //总页数</span><br><span class="line">      allpage:<span class="number">0</span>,</span><br><span class="line">      //自主分页总个数</span><br><span class="line">      total_self:<span class="number">0</span>,</span><br><span class="line">      //商品列表</span><br><span class="line">      goodslist_self:[],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted()&#123;</span><br><span class="line">    //因为打开页面是从第一页开始的，所以参数是<span class="number">1</span></span><br><span class="line">    this.get_goods_self(<span class="number">1</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    //input输入页面跳转</span><br><span class="line">  jump_page(e)&#123;</span><br><span class="line">      this.page = e.target.value</span><br><span class="line">      var val = e.target.value</span><br><span class="line">      console.log(val)</span><br><span class="line">      <span class="keyword">if</span>(val!=<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(val&gt;this.allpage)&#123;</span><br><span class="line">          this.$Message(<span class="string">&#x27;您输入的页码有误&#x27;</span>)</span><br><span class="line">          <span class="keyword">return</span> false;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(val&lt;this.page)&#123;</span><br><span class="line">          this.$Message(<span class="string">&#x27;您输入的页码有误&#x27;</span>)</span><br><span class="line">          <span class="keyword">return</span> false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">      &#125;</span><br><span class="line">      this.get_goods_self(val);</span><br><span class="line">    &#125;,</span><br><span class="line">    //自定义分页</span><br><span class="line">  get_goods_self(page)&#123;</span><br><span class="line">      //确定当前页</span><br><span class="line">      this.page = page</span><br><span class="line">      this.axios(&#123;</span><br><span class="line">        url:<span class="string">&#x27;http://localhost:8000/goodslist/&#x27;</span>,</span><br><span class="line">        method:<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        params:&#123;</span><br><span class="line">          page:page,</span><br><span class="line">          size:this.size,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).then(resp=&gt;&#123;</span><br><span class="line">        console.log(resp)</span><br><span class="line">        //获取列表内容</span><br><span class="line">        this.goodslist_self = resp.data.data;</span><br><span class="line">        //商品总数</span><br><span class="line">        this.total_self =resp.data.total;</span><br><span class="line">        //判断上一页</span><br><span class="line">        <span class="keyword">if</span>(page==<span class="number">1</span>)&#123;</span><br><span class="line">          //如果当前页为<span class="number">1</span>，就是第一页，没有上一页</span><br><span class="line">          this.lastpage = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          //如果当前页不是第一个，上一页就是当前页<span class="number">-1</span></span><br><span class="line">          this.lastpage = page<span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        //计算总页数</span><br><span class="line">        //Meth.ceil向上取整，只要有余数，就为整数</span><br><span class="line">        this.allpage = Math.ceil(this.total_self / this.size);</span><br><span class="line">        //判断下一页</span><br><span class="line">        <span class="keyword">if</span>(page == this.allpage)&#123;</span><br><span class="line">          //如果最后一页和总页数相同，该页数就是最后一页</span><br><span class="line">          this.nextpage = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          //如果最后一页和总页数不同，下一页就是当前页+<span class="number">1</span></span><br><span class="line">          this.nextpage = page+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        //设置偏移量</span><br><span class="line">        var move_page = <span class="number">2</span>;</span><br><span class="line">        var my_last = [];</span><br><span class="line">        </span><br><span class="line">        //计算左侧偏移量</span><br><span class="line">        <span class="keyword">for</span>(let i=page-move_page;i&lt;page;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            my_last.push(i)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //计算右侧偏移量</span><br><span class="line">        var my_next = [];</span><br><span class="line">        //计算左侧偏移量</span><br><span class="line">        <span class="keyword">for</span>(let i=page+<span class="number">1</span>;i&lt;=page+move_page;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(i&lt;=this.allpage)&#123;</span><br><span class="line">            my_next.push(i)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.last_page = my_last;</span><br><span class="line">        this.next_page = my_next;</span><br><span class="line">        </span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反序列化</title>
      <link href="/2018/08/15/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2018/08/15/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="反序列化是将所有参数打包为一个dict-之后将dict提交给序列化类-通过save就可以直接入库保存了"><a href="#反序列化是将所有参数打包为一个dict-之后将dict提交给序列化类-通过save就可以直接入库保存了" class="headerlink" title="反序列化是将所有参数打包为一个dict   之后将dict提交给序列化类 通过save就可以直接入库保存了"></a>反序列化是将所有参数打包为一个dict   之后将dict提交给序列化类 通过save就可以直接入库保存了</h3><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInsert</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="comment"># 初始化参数</span></span><br><span class="line">        name = request.GET.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        password = request.GET.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        <span class="comment"># 反序列化添加</span></span><br><span class="line">        data=&#123;</span><br><span class="line">            <span class="string">&#x27;name&#x27;</span>:name,</span><br><span class="line">            <span class="string">&#x27;password&#x27;</span>:password</span><br><span class="line">        &#125;</span><br><span class="line">        user = User_Ser(data=data)</span><br><span class="line">        <span class="comment"># 验证字段是否错误</span></span><br><span class="line">        <span class="keyword">if</span> user.is_valid():</span><br><span class="line">            <span class="comment"># 进行入库操作</span></span><br><span class="line">            user.save()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;code&#x27;</span>:<span class="number">200</span>,<span class="string">&#x27;msg&#x27;</span>:<span class="string">&#x27;ok&#x27;</span>&#125;)</span><br><span class="line"></span><br></pre><h3 id="在反序列化时候一定要注意字段的类型-要与字段个数一致"><a href="#在反序列化时候一定要注意字段的类型-要与字段个数一致" class="headerlink" title="在反序列化时候一定要注意字段的类型(要与字段个数一致)"></a>在反序列化时候一定要注意字段的类型(要与字段个数一致)</h3>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>增量式与分布式</title>
      <link href="/2018/08/09/%E5%A2%9E%E9%87%8F%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/"/>
      <url>/2018/08/09/%E5%A2%9E%E9%87%8F%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="基于crawlSpider的全站数据爬取"><a href="#基于crawlSpider的全站数据爬取" class="headerlink" title="基于crawlSpider的全站数据爬取"></a>基于crawlSpider的全站数据爬取</h3><pre class="highlight"><span class="line"># 项目的创建</span><br><span class="line">scrapy startproject projectname</span><br><span class="line">scrapy genspider -t crawl spidername www.baidu.com</span><br></pre><pre class="highlight"><span class="line"># crawlspider全站数据爬取:</span><br><span class="line">- CrawlSpider是一个爬虫类, 是scrapy.spider的子类, 功能比spider更强大.</span><br><span class="line">- CrawlSpider的机制:</span><br><span class="line">    - 连接提取器: 可以根据指定的规则进行连接的提取</span><br><span class="line">    - 规则解析器: 更具指定的规则对响应数据进行解析</span><br></pre><h4 id="案例-基于CrawlSpider对笑话网进行全站深度数据爬取-抓取笑话标题与内容-并存储于MongoDB中"><a href="#案例-基于CrawlSpider对笑话网进行全站深度数据爬取-抓取笑话标题与内容-并存储于MongoDB中" class="headerlink" title="案例: 基于CrawlSpider对笑话网进行全站深度数据爬取, 抓取笑话标题与内容, 并存储于MongoDB中"></a>案例: 基于CrawlSpider对笑话网进行全站深度数据爬取, 抓取笑话标题与内容, 并存储于MongoDB中</h4><pre class="highlight"><span class="line"># item编码:</span><br><span class="line">import scrapy</span><br><span class="line">class JokeItem(scrapy.Item):</span><br><span class="line">    title &#x3D; scrapy.Field()</span><br><span class="line">    content &#x3D; scrapy.Field()</span><br></pre><pre class="highlight"><span class="line"># spider编码:</span><br><span class="line">import scrapy</span><br><span class="line">from scrapy.linkextractors import LinkExtractor</span><br><span class="line">from scrapy.spiders import CrawlSpider, Rule</span><br><span class="line">from..items import JokeItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ZSpider(CrawlSpider):</span><br><span class="line">    name &#x3D; &#39;z&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;http:&#x2F;&#x2F;xiaohua.zol.com.cn&#x2F;lengxiaohua&#x2F;&#39;]</span><br><span class="line">    link &#x3D; LinkExtractor(allow&#x3D;r&#39;&#x2F;lengxiaohua&#x2F;\d+.html&#39;)</span><br><span class="line">    link_detail &#x3D; LinkExtractor(allow&#x3D;r&#39;.*?\d+\.html&#39;)</span><br><span class="line">    rules &#x3D; (</span><br><span class="line">        Rule(link, callback&#x3D;&#39;parse_item&#39;, follow&#x3D;True),</span><br><span class="line">        Rule(link_detail, callback&#x3D;&#39;parse_detail&#39;),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    def parse_item(self, response):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def parse_detail(self, response):</span><br><span class="line">        title &#x3D; response.xpath(&#39;&#x2F;&#x2F;h1[@class&#x3D;&quot;article-title&quot;]&#x2F;text()&#39;).extract_first()</span><br><span class="line">        content &#x3D; response.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;article-text&quot;]&#x2F;&#x2F;text()&#39;).extract()</span><br><span class="line">        content &#x3D; &#39;&#39;.join(content)</span><br><span class="line"></span><br><span class="line">        if title and content:</span><br><span class="line">            item &#x3D; JokeItem()</span><br><span class="line">            item[&quot;title&quot;] &#x3D; title</span><br><span class="line">            item[&quot;content&quot;] &#x3D; content</span><br><span class="line">            print(dict(item))</span><br><span class="line">            yield item</span><br></pre><pre class="highlight"><span class="line"># pipeline编码:</span><br><span class="line">class JokePipeline(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, mongo_uri, mongo_db):</span><br><span class="line">        self.mongo_uri &#x3D; mongo_uri</span><br><span class="line">        self.mongo_db &#x3D; mongo_db</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_crawler(cls, crawler):</span><br><span class="line">        return cls(</span><br><span class="line">            mongo_uri&#x3D;crawler.settings.get(&#39;MONGO_URI&#39;),</span><br><span class="line">            mongo_db&#x3D;crawler.settings.get(&#39;MONGO_DB&#39;)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def open_spider(self, spider):</span><br><span class="line">        self.client &#x3D; pymongo.MongoClient(self.mongo_uri)</span><br><span class="line">        self.db &#x3D; self.client[self.mongo_db]</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        self.db[&quot;joke&quot;].insert(dict(item))</span><br><span class="line">        return item</span><br><span class="line"></span><br><span class="line">    def close(self, spider):</span><br><span class="line">        self.client.close()</span><br></pre><h4 id="电影天堂-全站深度抓取电影名与下载链接"><a href="#电影天堂-全站深度抓取电影名与下载链接" class="headerlink" title="电影天堂: 全站深度抓取电影名与下载链接:"></a>电影天堂: 全站深度抓取电影名与下载链接:</h4><pre class="highlight"><span class="line"># item定义存储字段:</span><br><span class="line">import scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BossItem(scrapy.Item):</span><br><span class="line">    title &#x3D; scrapy.Field()</span><br><span class="line">    downloadlink &#x3D; scrapy.Field()</span><br></pre><pre class="highlight"><span class="line"># spider编码:</span><br><span class="line">import scrapy</span><br><span class="line">from scrapy.linkextractors import LinkExtractor</span><br><span class="line">from scrapy.spiders import CrawlSpider, Rule</span><br><span class="line">from ..items import MvItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BSpider(CrawlSpider):</span><br><span class="line">    name &#x3D; &#39;mv&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;https:&#x2F;&#x2F;www.ygdy8.net&#x2F;html&#x2F;gndy&#x2F;oumei&#x2F;index.html&#39;]</span><br><span class="line">    link &#x3D; LinkExtractor(allow&#x3D;r&#39;list.*?html&#39;)</span><br><span class="line">    link_detail &#x3D; LinkExtractor(allow&#x3D;r&#39;.*?&#x2F;\d+\.html&#39;)</span><br><span class="line">    rules &#x3D; (</span><br><span class="line">        Rule(link, callback&#x3D;&#39;parse_item&#39;, follow&#x3D;True,),</span><br><span class="line">        Rule(link_detail, callback&#x3D;&#39;parse_detail&#39;, follow&#x3D;True,),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    def parse_item(self, response):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def parse_detail(self, response):</span><br><span class="line">        title &#x3D; response.xpath(&#39;&#x2F;&#x2F;h1&#x2F;&#x2F;text()&#39;).extract_first()</span><br><span class="line">        downloadlink &#x3D; response.xpath(&#39;&#x2F;&#x2F;tbody&#x2F;tr&#x2F;td&#x2F;a&#x2F;text()&#39;).extract_first()</span><br><span class="line">        if title and downloadlink and &#39;ftp&#39; in downloadlink:</span><br><span class="line">            item &#x3D; BossItem()</span><br><span class="line">            item[&#39;title&#39;] &#x3D; title</span><br><span class="line">            item[&#39;downloadlink&#39;] &#x3D; downloadlink</span><br><span class="line">            yield item</span><br></pre><pre class="highlight"><span class="line"># piplines编码:</span><br><span class="line">class MvPipeline(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, mongo_uri, mongo_db):</span><br><span class="line">        self.mongo_uri &#x3D; mongo_uri</span><br><span class="line">        self.mongo_db &#x3D; mongo_db</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_crawler(cls, crawler):</span><br><span class="line">        return cls(</span><br><span class="line">            mongo_uri&#x3D;crawler.settings.get(&#39;MONGO_URI&#39;),</span><br><span class="line">            mongo_db&#x3D;crawler.settings.get(&#39;MONGO_DB&#39;)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def open_spider(self, spider):</span><br><span class="line">        self.client &#x3D; pymongo.MongoClient(self.mongo_uri)</span><br><span class="line">        self.db &#x3D; self.client[self.mongo_db]</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        self.db[&quot;mv&quot;].insert(dict(item))</span><br><span class="line">        return item</span><br><span class="line"></span><br><span class="line">    def close(self, spider):</span><br><span class="line">        self.client.close()</span><br></pre><hr><h2 id="1-分布式"><a href="#1-分布式" class="headerlink" title="1.分布式"></a>1.分布式</h2><pre class="highlight"><span class="line"># 分布式概念:</span><br><span class="line">使用多台机器组成一个分布式的机群，在机群中运行同一组程序，进行联合数据的爬取。</span><br><span class="line"></span><br><span class="line"># 原生scrapy无法实现分布式原因:</span><br><span class="line">- 原生的scrapy中的调度器不可以被共享</span><br><span class="line">- 原生的scrapy的管道不可以被共享</span><br><span class="line"></span><br><span class="line"># 使用scrapy实现分布式思路:</span><br><span class="line">- 为原生的scrapy框架提供共享的管道和调度器</span><br><span class="line">- pip install scrapy_redis</span><br></pre><hr><pre class="highlight"><span class="line">- 1. 创建工程: scrapy startproject projectname</span><br><span class="line">- 2. 爬虫文件: scrapy genspider -t crawl spidername www.baidu.com</span><br><span class="line">- 3. 修改爬虫文件：</span><br><span class="line">- 3.1 导包：from scrapy_redis.spiders import RedisCrawlSpider</span><br><span class="line">- 3.2 将当前爬虫类的父类进行修改RedisCrawlSpider</span><br><span class="line">- 3.3 allowed_domains，start_url注释掉，添加一个新属性redis_key&#x3D;&#39;qn&#39;(调度器队列的名称)</span><br><span class="line">- 3.4 指定redis_key &#x3D; &#39;xxx&#39; , 即共享调度器队列名字</span><br><span class="line">- 3.4 数据解析，将解析的数据封装到item中然后向管道提交</span><br><span class="line">- 4. 配置文件的编写：</span><br><span class="line">- 4.1 指定管道：</span><br><span class="line">ITEM_PIPELINES &#x3D; &#123;</span><br><span class="line">&#39;scrapy_redis.pipelines.RedisPipeline&#39;: 400</span><br><span class="line">&#125;</span><br><span class="line">- 4.2 指定调度器：</span><br><span class="line"># 增加了一个去重容器类的配置, 作用使用Redis的set集合来存储请求的指纹数据, 从而实现请求去重的持久化</span><br><span class="line">DUPEFILTER_CLASS &#x3D; &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span><br><span class="line"># 使用scrapy-redis组件自己的调度器</span><br><span class="line">SCHEDULER &#x3D; &quot;scrapy_redis.scheduler.Scheduler&quot;</span><br><span class="line"># 配置调度器是否要持久化, 也就是当爬虫结束了, 要不要清空Redis中请求队列和去重指纹的set。如果是True, 就表示要持久化存储, 就不清空数据, 否则清空数据</span><br><span class="line">SCHEDULER_PERSIST &#x3D; True</span><br><span class="line">- 4.3 指定具体的redis：</span><br><span class="line">REDIS_HOST &#x3D; &#39;redis服务的ip地址&#39;</span><br><span class="line">REDIS_PORT &#x3D; 6379</span><br><span class="line">- 5. 修改Redis配置并指定配置启动：</span><br><span class="line">- #bind 127.0.0.1</span><br><span class="line">- protected-mode no</span><br><span class="line">- 开启redis服务(携带redis的配置文件：redis-server .&#x2F;redis.windows.conf),和客户端(redis-cli)：</span><br><span class="line"></span><br><span class="line">- 6. 启动程序：scrapy runspider xxx.py(需要进入spider文件夹)</span><br><span class="line">- 7. 向调度器队列中扔入一个起始的url（redis的客户端）：lpush xxx www.xxx.com</span><br><span class="line">(xxx表示的就是redis_key的值)</span><br></pre><h4 id="案例-阳光热线问政平台投诉信息爬取–-gt-网址-http-wz-sun0769-com-index-php-question-questionType-type-4"><a href="#案例-阳光热线问政平台投诉信息爬取–-gt-网址-http-wz-sun0769-com-index-php-question-questionType-type-4" class="headerlink" title="案例: 阳光热线问政平台投诉信息爬取–&gt;网址: http://wz.sun0769.com/index.php/question/questionType?type=4"></a>案例: 阳光热线问政平台投诉信息爬取–&gt;网址: <a href="http://wz.sun0769.com/index.php/question/questionType?type=4">http://wz.sun0769.com/index.php/question/questionType?type=4</a></h4><pre class="highlight"><span class="line"># items编码:</span><br><span class="line">import scrapy</span><br><span class="line">class FbsproItem(scrapy.Item):</span><br><span class="line">    # define the fields for your item here like:</span><br><span class="line">    title &#x3D; scrapy.Field()</span><br></pre><pre class="highlight"><span class="line"># spider编码:</span><br><span class="line">import scrapy</span><br><span class="line">from scrapy.linkextractors import LinkExtractor</span><br><span class="line">from scrapy.spiders import CrawlSpider, Rule</span><br><span class="line">from scrapy_redis.spiders import RedisCrawlSpider</span><br><span class="line">from fbspro.items import FbsproItem  </span><br><span class="line">class TestSpider(RedisCrawlSpider):</span><br><span class="line">    name &#x3D; &#39;test&#39;  </span><br><span class="line">    # allowed_domains &#x3D; [&#39;ww.baidu.com&#39;]</span><br><span class="line">    # start_urls &#x3D; [&#39;http:&#x2F;&#x2F;ww.baidu.com&#x2F;&#39;]</span><br><span class="line">    redis_key &#x3D; &#39;urlscheduler&#39;</span><br><span class="line">    link &#x3D; LinkExtractor(allow&#x3D;r&#39;.*?&amp;page&#x3D;\d+&#39;)</span><br><span class="line">    rules &#x3D; (</span><br><span class="line">        Rule(link, callback&#x3D;&#39;parse_item&#39;, follow&#x3D;True),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    def parse_item(self, response):</span><br><span class="line">        a_lst &#x3D; response.xpath(&#39;&#x2F;&#x2F;a[@class&#x3D;&quot;news14&quot;]&#39;)</span><br><span class="line">        for a in a_lst:</span><br><span class="line">            title &#x3D; a.xpath(&#39;.&#x2F;text()&#39;).extract_first()</span><br><span class="line">            # print(title)</span><br><span class="line">            item &#x3D; FbsproItem()</span><br><span class="line">            item[&#39;title&#39;] &#x3D; title</span><br><span class="line">            yield item</span><br></pre><pre class="highlight"><span class="line"># settings配置编码:</span><br><span class="line">USER_AGENT &#x3D; &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;76.0.3809.100 Safari&#x2F;537.36&#39;</span><br><span class="line">ROBOTSTXT_OBEY &#x3D; False</span><br><span class="line">CONCURRENT_REQUESTS &#x3D; 3</span><br><span class="line">ITEM_PIPELINES &#x3D; &#123;</span><br><span class="line">   # &#39;fbspro.pipelines.FbsproPipeline&#39;: 300,</span><br><span class="line">    &#39;scrapy_redis.pipelines.RedisPipeline&#39;: 400</span><br><span class="line">&#125;</span><br><span class="line"># 增加了一个去重容器类的配置, 作用使用Redis的set集合来存储请求的指纹数据, 从而实现请求去重的持久化</span><br><span class="line">DUPEFILTER_CLASS &#x3D; &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span><br><span class="line"># 使用scrapy-redis组件自己的调度器</span><br><span class="line">SCHEDULER &#x3D; &quot;scrapy_redis.scheduler.Scheduler&quot;</span><br><span class="line"># 配置调度器是否要持久化, 也就是当爬虫结束了, 要不要清空Redis中请求队列和去重指纹的set。如果是True, 就表示要持久化存储, 就不清空数据, 否则清空数据</span><br><span class="line">SCHEDULER_PERSIST &#x3D; True</span><br><span class="line"></span><br><span class="line"># redis配置</span><br><span class="line">REDIS_HOST &#x3D; &#39;192.168.12.198&#39;</span><br><span class="line">REDIS_PORT &#x3D; 6379</span><br></pre><hr><h2 id="2-增量式"><a href="#2-增量式" class="headerlink" title="2.增量式"></a>2.增量式</h2><pre class="highlight"><span class="line"># 概念:</span><br><span class="line">- 检测网站数据更新, 只爬取更新的内容</span><br><span class="line">- 核心: 去重</span><br><span class="line">        - url</span><br><span class="line">        - 数据指纹</span><br></pre><h4 id="增量式爬虫-电影名称与电影类型的爬取–-gt-url-https-www-4567tv-co-list-index1-html"><a href="#增量式爬虫-电影名称与电影类型的爬取–-gt-url-https-www-4567tv-co-list-index1-html" class="headerlink" title="增量式爬虫: 电影名称与电影类型的爬取–&gt;url: https://www.4567tv.co/list/index1.html"></a>增量式爬虫: 电影名称与电影类型的爬取–&gt;url: <a href="https://www.4567tv.co/list/index1.html">https://www.4567tv.co/list/index1.html</a></h4><pre class="highlight"><span class="line"># items编码:</span><br><span class="line">import scrapy</span><br><span class="line">class MvproItem(scrapy.Item):</span><br><span class="line">    title &#x3D; scrapy.Field()</span><br><span class="line">    position &#x3D; scrapy.Field()</span><br></pre><pre class="highlight"><span class="line"># spider编码:</span><br><span class="line">import scrapy</span><br><span class="line">from scrapy.linkextractors import LinkExtractor</span><br><span class="line">from scrapy.spiders import CrawlSpider, Rule</span><br><span class="line">from redis import Redis</span><br><span class="line">from mvpro.items import MvproItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MoveSpider(CrawlSpider):</span><br><span class="line">    conn &#x3D; Redis(&#39;127.0.0.1&#39;, 6379)</span><br><span class="line">    name &#x3D; &#39;move&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;https:&#x2F;&#x2F;www.4567tv.co&#x2F;list&#x2F;index1.html&#39;]</span><br><span class="line">    link &#x3D; LinkExtractor(allow&#x3D;r&#39;&#x2F;list&#x2F;index1-\d+\.html&#39;)</span><br><span class="line">    rules &#x3D; (</span><br><span class="line">        Rule(link, callback&#x3D;&#39;parse_item&#39;, follow&#x3D;True),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    def parse_item(self, response):</span><br><span class="line">        li_list &#x3D; response.xpath(&#39;&#x2F;&#x2F;div[contains(@class, &quot;index-area&quot;)]&#x2F;ul&#x2F;li&#39;)</span><br><span class="line">        for li in li_list:</span><br><span class="line">            mv_link &#x3D; &#39;https:&#x2F;&#x2F;www.4567tv.co&#39; + li.xpath(&#39;.&#x2F;a&#x2F;@href&#39;).extract_first()</span><br><span class="line">            ex &#x3D; self.conn.sadd(&#39;mv_link&#39;, mv_link)</span><br><span class="line">            if ex:</span><br><span class="line">                print(&#39;有新数据可以爬取..........................&#39;)</span><br><span class="line">                yield scrapy.Request(url&#x3D;mv_link, callback&#x3D;self.parse_detail)</span><br><span class="line">            else:</span><br><span class="line">                print(&#39;没有新数据可以爬取!!!!!!!!!!!!!!!!!!!!!!!!!&#39;)</span><br><span class="line"></span><br><span class="line">    def parse_detail(self, response):</span><br><span class="line">        title &#x3D; response.xpath(&#39;&#x2F;&#x2F;dt[@class&#x3D;&quot;name&quot;]&#x2F;text()&#39;).extract_first()</span><br><span class="line">        pro &#x3D; response.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;ee&quot;]&#x2F;text()&#39;).extract_first()</span><br><span class="line">        item &#x3D; MvproItem()</span><br><span class="line">        item[&#39;title&#39;] &#x3D; title</span><br><span class="line">        item[&#39;position&#39;] &#x3D; pro</span><br><span class="line">        yield item</span><br></pre><hr><h4 id="需求-基于数据指纹的增量式爬虫-爬取糗百文字"><a href="#需求-基于数据指纹的增量式爬虫-爬取糗百文字" class="headerlink" title="需求: 基于数据指纹的增量式爬虫, 爬取糗百文字"></a>需求: 基于数据指纹的增量式爬虫, 爬取糗百文字</h4><pre class="highlight"><span class="line"># spider编码:</span><br><span class="line">import scrapy</span><br><span class="line">from qiubai.items import QiubaiItem</span><br><span class="line">import hashlib</span><br><span class="line">from redis import Redis</span><br><span class="line"></span><br><span class="line">class QbSpider(scrapy.Spider):</span><br><span class="line">    conn &#x3D; Redis(&#39;127.0.0.1&#39;, 6379)</span><br><span class="line">    name &#x3D; &#39;qb&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;https:&#x2F;&#x2F;www.qiushibaike.com&#x2F;text&#x2F;&#39;]</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        div_list &#x3D; response.xpath(&#39;&#x2F;&#x2F;div[@id&#x3D;&quot;content-left&quot;]&#x2F;div&#39;)</span><br><span class="line"></span><br><span class="line">        for div in div_list:</span><br><span class="line">            content &#x3D; div.xpath(&#39;.&#x2F;a[1]&#x2F;div[@class&#x3D;&quot;content&quot;]&#x2F;span[1]&#x2F;text()&#39;).extract_first()</span><br><span class="line">            fp &#x3D; hashlib.md5(content.encode(&#39;utf-8&#39;)).hexdigest()</span><br><span class="line">            ex &#x3D; self.conn.sadd(&#39;fp&#39;, fp)</span><br><span class="line">            if ex:</span><br><span class="line">                print(&#39;有更新数据需要爬取........................&#39;)</span><br><span class="line">                item &#x3D; QiubaiItem()</span><br><span class="line">                item[&#39;content&#39;] &#x3D; content</span><br><span class="line">                yield item</span><br><span class="line">            else:</span><br><span class="line">                print(&#39;没有数据更新~~~&#39;)</span><br></pre><h2 id="3-scrapy提高数据爬取效率"><a href="#3-scrapy提高数据爬取效率" class="headerlink" title="3.scrapy提高数据爬取效率"></a>3.scrapy提高数据爬取效率</h2><pre class="highlight"><span class="line">1.增加并发：</span><br><span class="line">默认scrapy开启的并发线程为32个，可以适当进行增加。在settings配置文件中修改CONCURRENT_REQUESTS &#x3D; 100值为100,并发设置成了为100。</span><br><span class="line"></span><br><span class="line">2.降低日志级别：</span><br><span class="line">    在运行scrapy时，会有大量日志信息的输出，为了减少CPU的使用率。可以设置log输出信息为INFO或者ERROR即可。在配置文件中编写：LOG_LEVEL &#x3D; ‘INFO’</span><br><span class="line"></span><br><span class="line">3.禁止cookie：</span><br><span class="line">    如果不是真的需要cookie，则在scrapy爬取数据时可以禁止cookie从而减少CPU的使用率，提升爬取效率。在配置文件中编写：COOKIES_ENABLED &#x3D; False</span><br><span class="line"></span><br><span class="line">4.禁止重试：</span><br><span class="line">    对失败的HTTP进行重新请求（重试）会减慢爬取速度，因此可以禁止重试。在配置文件中编写：RETRY_ENABLED &#x3D; False</span><br><span class="line"></span><br><span class="line">5.减少下载超时：</span><br><span class="line">    如果对一个非常慢的链接进行爬取，减少下载超时可以能让卡住的链接快速被放弃，从而提升效率。在配置文件中进行编写：DOWNLOAD_TIMEOUT &#x3D; 10 超时时间为10s</span><br></pre><hr><h2 id="4-虚拟环境"><a href="#4-虚拟环境" class="headerlink" title="4.虚拟环境"></a>4.虚拟环境</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h4><pre class="highlight"><span class="line">pip install virtualenvwrapper-win</span><br></pre><pre class="highlight"><span class="line"># 常用命令:mkvirtualenv envname  # 创建虚拟环境并自动切换到该环境下workon envname  # 切换到某虚拟环境下pip list rmvirtualenv envname  # 删除虚拟环境deactivate  # 退出虚拟环境lsvirtualenv  # 列出所有常见的虚拟环境mkvirtualenv --python&#x3D;&#x3D;C:\...\python.exe envname  # 指定Python解释器创建虚拟环境</span><br></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程爬虫</title>
      <link href="/2018/08/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB/"/>
      <url>/2018/08/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="1-整体思路"><a href="#1-整体思路" class="headerlink" title="1.整体思路"></a>1.整体思路</h2><pre class="highlight"><span class="line">&gt; 队列保存变化的参数，即之前构建的类似页码的东西。</span><br><span class="line"></span><br><span class="line">&gt; 一个类实现：三个线程进行数据采集，依次从队列中获取参数，拼接url，请求到的网页源码保存到新队列。</span><br><span class="line"></span><br><span class="line">&gt; 一个类实现 ：1.  三个线程进行数据处理，依次从队列中获取源码，xpath定位元素取出文本，构建字典。2. 定义函数数据入库，pymongon数据插入数据即可</span><br><span class="line"></span><br><span class="line">主程序 mian 分为 两 部分</span><br><span class="line"></span><br><span class="line">- 实例化队列，我们有两组线程在工作，初始队列一个，线程间通信需要一个，一共两个</span><br><span class="line"></span><br><span class="line">- 实例化线程，通过遍历实例化线程类，创建俩组三线程。</span><br><span class="line"></span><br><span class="line">调用主程序</span><br></pre><hr><h2 id="2-具体部署"><a href="#2-具体部署" class="headerlink" title="2.具体部署"></a>2.具体部署</h2><pre class="highlight"><span class="line">定义第一个类：</span><br><span class="line"></span><br><span class="line">  定义类：需要继承threading.Thread父类</span><br><span class="line"></span><br><span class="line">  类属性：想清楚传那些熟悉</span><br><span class="line"></span><br><span class="line">   1. 参数队列要传进来</span><br><span class="line"></span><br><span class="line">   2. 子类重写初始化属性</span><br><span class="line"></span><br><span class="line">      先继承父类属性----&gt;然后写自己要加的属性</span><br><span class="line"></span><br><span class="line">  定义方法：</span><br><span class="line"></span><br><span class="line">   重写run方法</span><br><span class="line"></span><br><span class="line">   ​通过无限循环获取队列中的参数，实现请求多页面，</span><br><span class="line"></span><br><span class="line">   ​这个队列是被三个线程去访问的。</span><br><span class="line"></span><br><span class="line">定义第二个类：</span><br><span class="line"></span><br><span class="line"> ​需要考虑的和第一个类思路是一样的，这里有一个互斥锁的加入</span><br><span class="line"></span><br><span class="line"> ​就是在处理数据的时候加入，因为写入数据库的字段都一样，避免数据量过大</span><br><span class="line"></span><br><span class="line"> ​出错，导致数据错乱。</span><br><span class="line"></span><br><span class="line">主程序代码</span><br><span class="line"></span><br><span class="line">  实例队列对象</span><br><span class="line"></span><br><span class="line">   page_Queue &#x3D; Queue() 构建参数</span><br><span class="line"></span><br><span class="line">   data_Queue &#x3D; Queue() 负责两个主线程间的通信</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  实例互斥锁对象</span><br><span class="line"></span><br><span class="line">   lock &#x3D; Lock()</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  构建两个主线程，一个线程负责采集数据，一个线程处理数据并入库</span><br><span class="line"></span><br><span class="line">  当然都是用for循环来构建的，记得线程类需要传入那些属性</span><br><span class="line"></span><br><span class="line">调用主程序</span><br></pre><hr><h4 id="重写父类同名方法需要注意"><a href="#重写父类同名方法需要注意" class="headerlink" title="重写父类同名方法需要注意:"></a>重写父类同名方法需要注意:</h4><pre class="highlight"><span class="line">class ParseTread(threading.Thread):</span><br><span class="line">    def __init__(self, threadName, dataQueue, lock):</span><br><span class="line">        # 先把父类的方法继承下来</span><br><span class="line">        super(ParseTread, self).__init__()</span><br><span class="line">        # 然后定义自己的方法</span><br><span class="line">        self.threadName &#x3D; threadName</span><br><span class="line">        self.dataQueue &#x3D; dataQueue</span><br><span class="line">        self.lock &#x3D; lock</span><br></pre><hr><h4 id="首先明白什么是进程什么是线程，线程和进程的区别？"><a href="#首先明白什么是进程什么是线程，线程和进程的区别？" class="headerlink" title="首先明白什么是进程什么是线程，线程和进程的区别？"></a>首先明白什么是进程什么是线程，线程和进程的区别？</h4><pre class="highlight"><span class="line"> 线程（有时候称为轻量级进程）与进程类似，不过它们是在同一个进程下执行的，并共享相同的上下文。可以将它们认为是在一个主进程或“主线程”中并行运行的一些“迷你进程”。 </span><br><span class="line"></span><br><span class="line"> 这里讲的很清楚&lt;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;chbo&#x2F;p&#x2F;7043660.html&gt; </span><br><span class="line"></span><br><span class="line">我们的子线程为什么要设置join()，其实设置了守护线程才是join()出现的时机</span><br><span class="line"></span><br><span class="line"> 如果是为了避免数据的恶性竞争的话，互斥锁是接这个的小能手。</span><br><span class="line"></span><br><span class="line">为什么要设置守护线程</span><br><span class="line"></span><br><span class="line"> 如果给线程设置守护线程，那么后台线程执行完毕就会杀死这些线程。大致的作用就是当你退出进程，后台线程关闭那么这些子线程也要同时关闭。</span><br><span class="line"></span><br><span class="line">join()的作用，和其存在的意义</span><br><span class="line"></span><br><span class="line"> join()的功能是设置阻塞，之所以要设置join()就是有选择的设置守护线程，因为我们有的线程需要同步主线程结束而结束，而有的线程需要执行完毕菜行。设置了守护线程的子线程都会随着主线的结束而结束。</span><br><span class="line"></span><br><span class="line"> 我们这里设置的join()是没有意义的，因为并没有设置守护线程，因此没必要设置阻塞。</span><br></pre><hr><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">from urllib import request</span><br><span class="line">from chaojiying import Chaojiying_Client</span><br><span class="line">from lxml import etree</span><br><span class="line">import re, threading</span><br><span class="line">from threading import Lock</span><br><span class="line">from queue import Queue</span><br><span class="line">import pymongo</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CrawlThread(threading.Thread):</span><br><span class="line">    def __init__(self, threadName, page_Queue, data_Queue):</span><br><span class="line">        super(CrawlThread, self).__init__()</span><br><span class="line">        self.threadName &#x3D; threadName</span><br><span class="line">        self.pageQueue &#x3D; page_Queue</span><br><span class="line">        self.dataQueue &#x3D; data_Queue</span><br><span class="line">        self.headers &#x3D; &#123;&quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;74.0.3729.169 Safari&#x2F;537.36&quot;,&#125;</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        url1 &#x3D; &#39;http:&#x2F;&#x2F;www.ziroom.com&#x2F;z&#x2F;nl&#x2F;z3.html?p&#x3D;%s&#39;</span><br><span class="line">        while True:</span><br><span class="line">            try:</span><br><span class="line">                # 如果队列为空 block 为 True 那么进入阻塞状态</span><br><span class="line">                # 如果队列为控 block 为 false 那么会抛出异常</span><br><span class="line">                p &#x3D; self.pageQueue.get(block&#x3D;False)</span><br><span class="line">                print(&#39;%s开始工作...&#39; % self.threadName)</span><br><span class="line">                response &#x3D; requests.get(url&#x3D;url1 % p, headers&#x3D;self.headers)</span><br><span class="line">                content &#x3D; response.text</span><br><span class="line">                self.dataQueue.put(content)</span><br><span class="line">                # print(self.dataQueue.qsize())</span><br><span class="line">                print(&#39;%s工作结束...&#39; % self.threadName)</span><br><span class="line">            except:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">class ParseTread(threading.Thread):</span><br><span class="line">    def __init__(self, threadName, dataQueue, lock):</span><br><span class="line">        super(ParseTread, self).__init__()</span><br><span class="line">        self.threadName &#x3D; threadName</span><br><span class="line">        self.dataQueue &#x3D; dataQueue</span><br><span class="line">        self.lock &#x3D; lock</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            try:</span><br><span class="line">                html &#x3D; self.dataQueue.get(block&#x3D;False)</span><br><span class="line">                print(&#39;%s开始处理数据........&#39; % self.threadName)</span><br><span class="line">                self.get_price_list(html)</span><br><span class="line">                print(&#39;%s数据处理完毕........&#39; % self.threadName)</span><br><span class="line">            except Exception as e:</span><br><span class="line">                print(e)</span><br><span class="line">                # print(&#39;出错了&#39;)</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">    def get_price_list(self, html):</span><br><span class="line">        # 正则匹配图片地址，超级鹰打码，获取列表两个参数 code 下标列表</span><br><span class="line">        price_image &#x3D; re.findall(r&#39;&quot;image&quot;:&quot;(.*?)&quot;&#39;, html)[0]</span><br><span class="line">        index_list &#x3D; re.findall(r&#39;&quot;offset&quot;:(.*?)&#125;;&#39;, html)[0]</span><br><span class="line">        index_list &#x3D; eval(index_list)</span><br><span class="line">        # print(index_list)</span><br><span class="line">        price_image_link &#x3D; &#39;http:&#39; + price_image</span><br><span class="line">        # print(price_image_link)</span><br><span class="line">        request.urlretrieve(price_image_link, &#39;.&#x2F;im.jpg&#39;)</span><br><span class="line">        # 超级鹰打码，获取到图片中的数字</span><br><span class="line">        chaojiying &#x3D; Chaojiying_Client(&#39;ipython&#39;, &#39;123456789&#39;, &#39;96001&#39;)</span><br><span class="line">        im &#x3D; open(&#39;im.jpg&#39;, &#39;rb&#39;).read()</span><br><span class="line">        code &#x3D; chaojiying.PostPic(im, 4111)[&#39;pic_str&#39;]</span><br><span class="line">        price_list &#x3D; []</span><br><span class="line">        for j in index_list:</span><br><span class="line">            # print(j)</span><br><span class="line">            str1 &#x3D; &#39;&#39;</span><br><span class="line">            for i in j:</span><br><span class="line">                str1 +&#x3D; code[int(i)]</span><br><span class="line">            # print(code)</span><br><span class="line">            # print(str1)</span><br><span class="line">            price_list.append(int(str1))</span><br><span class="line">        self.get_detail_list(html, price_list)</span><br><span class="line"></span><br><span class="line">    def get_detail_list(self, html, price_list):</span><br><span class="line">        html &#x3D; etree.HTML(html)</span><br><span class="line">        data_list &#x3D; html.xpath(&#39;&#x2F;&#x2F;ul[@id&#x3D;&quot;houseList&quot;]&#x2F;li&#39;)</span><br><span class="line">        a &#x3D; 0</span><br><span class="line">        for i in data_list:</span><br><span class="line">            item &#x3D; &#123;&#125;</span><br><span class="line">            title &#x3D; i.xpath(&#39;.&#x2F;&#x2F;h3&#x2F;a[@class&#x3D;&quot;t1&quot;]&#x2F;text()&#39;)[0]</span><br><span class="line">            size_detail &#x3D; i.xpath(&#39;.&#x2F;&#x2F;div[@class&#x3D;&quot;detail&quot;]&#x2F;p&#39;)[0].xpath(&#39;.&#x2F;&#x2F;span&#x2F;text()&#39;)</span><br><span class="line">            position &#x3D; i.xpath(&#39;.&#x2F;&#x2F;div[@class&#x3D;&quot;detail&quot;]&#x2F;p&#39;)[1].xpath(&#39;.&#x2F;&#x2F;span&#x2F;text()&#39;)[0]</span><br><span class="line">            item &#x3D; &#123;&#39;标题&#39;: title, &#39;面积&#39;: size_detail, &#39;位置&#39;: position, &#39;价格&#39;: price_list[a]&#125;</span><br><span class="line">            a +&#x3D; 1</span><br><span class="line">            with self.lock:</span><br><span class="line">                self.save(item)</span><br><span class="line"></span><br><span class="line">    def save(self, item):</span><br><span class="line">        conn &#x3D; pymongo.MongoClient(&quot;localhost&quot;,27017)</span><br><span class="line">        db &#x3D; conn.qiubai</span><br><span class="line">        table &#x3D; db.qiubai</span><br><span class="line">        table.insert(item)</span><br><span class="line">       </span><br><span class="line">def main(n):</span><br><span class="line">    page_Queue &#x3D; Queue()</span><br><span class="line">    data_Queue &#x3D; Queue()</span><br><span class="line">    lock &#x3D; Lock()</span><br><span class="line">    for i in range(1,n+1):</span><br><span class="line">        page_Queue.put(i)</span><br><span class="line"></span><br><span class="line">    crawlList &#x3D; &#123;&#39;长征1号&#39;, &#39;长征2号&#39;, &#39;长征3号&#39;&#125;</span><br><span class="line">    TreadCrawl &#x3D; []</span><br><span class="line">    for var in crawlList:</span><br><span class="line">        c &#x3D; CrawlThread(var, page_Queue, data_Queue)</span><br><span class="line">        c.start()</span><br><span class="line">        TreadCrawl.append(c)</span><br><span class="line">    for var in TreadCrawl:</span><br><span class="line">        var.join()</span><br><span class="line">    parseList &#x3D; [&#39;嫦娥1号&#39;, &#39;嫦娥2号&#39;, &#39;嫦娥3号&#39;]</span><br><span class="line">    TreadParse &#x3D; []</span><br><span class="line">    for var in parseList:</span><br><span class="line">        p &#x3D; ParseTread(var, data_Queue, lock)</span><br><span class="line">        p.start()</span><br><span class="line">        TreadParse.append(p)</span><br><span class="line">    for var in TreadParse:</span><br><span class="line">        var.join()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main(10)</span><br></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据解析之正则&amp;BS4&amp;xpath</title>
      <link href="/2018/07/25/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%AD%A3%E5%88%99&amp;BS4&amp;xpath/"/>
      <url>/2018/07/25/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%AD%A3%E5%88%99&amp;BS4&amp;xpath/</url>
      
        <content type="html"><![CDATA[<h1 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h1><hr><h6 id="数据解析就是应用一定的技术手段在响应数据中获取目标数据"><a href="#数据解析就是应用一定的技术手段在响应数据中获取目标数据" class="headerlink" title="数据解析就是应用一定的技术手段在响应数据中获取目标数据"></a>数据解析就是应用一定的技术手段在响应数据中获取目标数据</h6><hr><h5 id="常用数据解析方式"><a href="#常用数据解析方式" class="headerlink" title="常用数据解析方式:"></a>常用数据解析方式:</h5><ul><li>正则: 匹配高效, 但正则表达式书写有难度</li><li>BS4: 解析数据速度慢, 但使用简单</li><li>xpath: 解析速度快, 使用简单</li></ul><hr><h5 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置:"></a>环境配置:</h5><ul><li><p>正则: </p><pre class="highlight"><span class="line">pip install re</span><br></pre></li><li><p>BS4:</p><pre class="highlight"><span class="line">pip install lxml</span><br><span class="line">pip install BeautifulSoup4</span><br></pre></li><li><p>xpath:</p><pre class="highlight"><span class="line">pip install lxml</span><br></pre></li></ul><hr><h2 id="1-正则"><a href="#1-正则" class="headerlink" title="1.正则"></a>1.正则</h2><h3 id="元字符匹配"><a href="#元字符匹配" class="headerlink" title="元字符匹配"></a>元字符匹配</h3><pre class="highlight"><span class="line"> .     匹配任意字符，除了换行符</span><br><span class="line"></span><br><span class="line">[]    用来表示一组字符,单独列出：[abc] 匹配 &#39;a&#39;，&#39;b&#39;或&#39;c&#39;</span><br><span class="line"></span><br><span class="line">[^...]匹配除了字符组中字符的所有字符</span><br><span class="line"></span><br><span class="line">\d    匹配任意数字，等价于 [0-9].</span><br><span class="line"></span><br><span class="line">\D    匹配任意非数字</span><br><span class="line"></span><br><span class="line">\w    匹配字母数字及下划线</span><br><span class="line"></span><br><span class="line">\W    匹配非字母数字及下划线</span><br><span class="line"></span><br><span class="line">\s    匹配任意空白字符，等价于 [\t\n\r\f].</span><br><span class="line"></span><br><span class="line">\S    匹配任意非空字符</span><br></pre><hr><h3 id="字符组：要求在一个位置匹配的字符可能出现很多种情况-各种情况组成一个组"><a href="#字符组：要求在一个位置匹配的字符可能出现很多种情况-各种情况组成一个组" class="headerlink" title="字符组：要求在一个位置匹配的字符可能出现很多种情况, 各种情况组成一个组"></a>字符组：要求在一个位置匹配的字符可能出现很多种情况, 各种情况组成一个组</h3><pre class="highlight"><span class="line">[0123456789]: 匹配0到9任意字符</span><br><span class="line">[0-9]: 同上</span><br><span class="line">[a-z]: 匹配a到z的任意小写字母</span><br><span class="line">[A-Z]: 匹配A到Z的任意大写字母</span><br><span class="line">[0-9a-fA-F]: 以上三种的组合, 匹配0-9任意数组或a到f之间任意字母, 不区分大小写</span><br><span class="line">自定义字符组:[a3h5]  ---&gt;  代表匹配a, 3, h, 5等字符</span><br></pre><hr><h3 id="量词"><a href="#量词" class="headerlink" title="量词:"></a>量词:</h3><pre class="highlight"><span class="line">*  重复零次或更多次</span><br><span class="line">+重复一次或更多次</span><br><span class="line">?重复零次或一次</span><br><span class="line">&#123;n&#125;重复n次</span><br><span class="line">&#123;n,&#125;重复n次或更多次</span><br><span class="line">&#123;n,m&#125;重复n到m次</span><br><span class="line"></span><br></pre><hr><h3 id="边界修饰符"><a href="#边界修饰符" class="headerlink" title="边界修饰符"></a>边界修饰符</h3><pre class="highlight"><span class="line">^匹配开始</span><br><span class="line">$匹配结尾</span><br></pre><hr><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><pre class="highlight"><span class="line">在正则表达式中添加(), 就形成了一个分组, 在re模块中优先匹配显示分组内容</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line">s &#x3D; &quot;&lt;a href&#x3D;&#39;www.baidu.com&#39;&gt;正则匹配实验&lt;&#x2F;a&gt;&quot;</span><br><span class="line">res &#x3D; re.findall(&quot;href&#x3D;&#39;(.*)&#39;&gt;&quot;, s)</span><br><span class="line">print(res)</span><br></pre><hr><h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><pre class="highlight"><span class="line">re.S  单行模式</span><br><span class="line">re.M  多行模式</span><br><span class="line">re.I 忽略大小写</span><br></pre><hr><h3 id="贪婪匹配与非贪婪匹配"><a href="#贪婪匹配与非贪婪匹配" class="headerlink" title="贪婪匹配与非贪婪匹配"></a>贪婪匹配与非贪婪匹配</h3><pre class="highlight"><span class="line">贪婪匹配是指: 在使用量词:  * ,  +  等时, 尽可能的匹配内容</span><br><span class="line"></span><br><span class="line">非贪婪匹配是指: 使用?对正则表达式进行修饰, 使量词的匹配尽可能少, 如+代表匹配1次或多次, 在?的修饰下, 只匹配1次.</span><br></pre><hr><h3 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h3><ul><li>re.findall(‘正则表达式’, ‘待匹配字符串’): 返回所有满足匹配条件的结果, 以列表形式返回</li><li>re.search(‘正则表达式’, ‘带匹配字符串’): 匹配到第一个就返回一个对象, 该对象使用group()进行取值, 如果为匹配到则返回None</li><li>re.match(‘正则表达式’, ‘待匹配字符串’): 只从字符串开始进行匹配, 如果匹配成功返回一个对象,同样使用group()进行取值, 匹配不成功返回None</li><li>re.compile(‘正则表达式’): 将正则表达式编译为对象, 但需要按该正则表达式匹配是可以在直接使用该对象调用以上方法即可.</li></ul><h4 id="re模块示例"><a href="#re模块示例" class="headerlink" title="re模块示例:"></a>re模块示例:</h4><pre class="highlight"><span class="line">s &#x3D; &quot;abcabc你好&quot;</span><br><span class="line"></span><br><span class="line"># findall方法演示</span><br><span class="line">res_findall &#x3D; re.findall(&#39;a&#39;, s)</span><br><span class="line">print(&#39;findall匹配结果:&#39;, res_findall)</span><br><span class="line"></span><br><span class="line"># search方法演示, 不确定是否能匹配出结果, 不可直接使用group进行取值, 需要判断或进行异常处理</span><br><span class="line">res_search &#x3D; re.search(&quot;你&quot;, s)</span><br><span class="line">if res:</span><br><span class="line">    print(&#39;search匹配结果&#39;, res.group())</span><br><span class="line">else:</span><br><span class="line">    print(&#39;None&#39;)</span><br><span class="line">    </span><br><span class="line"># match方法演示:</span><br><span class="line">res_match_1 &#x3D; re.match(&#39;abc&#39;, s)</span><br><span class="line">res_match_2 &#x3D; re.match(&#39;bc&#39;, s)</span><br><span class="line">print(&#39;res_match_1结果:&#39;, res_match_1)</span><br><span class="line">print(&#39;res_match_2结果:&#39;, res_match_2)</span><br><span class="line"></span><br><span class="line"># compile方法演示:</span><br><span class="line">re_obj &#x3D; re.compile(&#39;ab&#39;)</span><br><span class="line">res &#x3D; re_obj.findall(s)</span><br><span class="line">print(res)</span><br></pre><hr><h3 id="利用正则表达式抓取校花网图片"><a href="#利用正则表达式抓取校花网图片" class="headerlink" title="利用正则表达式抓取校花网图片"></a>利用正则表达式抓取校花网图片</h3><pre class="highlight"><span class="line">import re</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># 请求url, 抓取页面</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.xiaohuar.com&#x2F;hua&#x2F;&#39;</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line">html &#x3D; res.text</span><br><span class="line"></span><br><span class="line"># 利用正则匹配页面中的img标签, 获取其src属性值</span><br><span class="line">all_src &#x3D; re.findall(&#39;&lt;img.*src&#x3D;&quot;(.*jpg)&quot;&#39;, html, re.M)</span><br><span class="line"></span><br><span class="line"># 遍历获取到的图片连接, 处理连接为完整的url, 再次请求抓取图片二进制流数据, 写入文件</span><br><span class="line">for num, url in enumerate(all_src):</span><br><span class="line">    url &#x3D; &#39;http:&#x2F;&#x2F;www.xiaohuar.com&#39; + url</span><br><span class="line">    image &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line">    with open(&#39;%s.jpg&#39; % num, &#39;wb&#39;) as f:</span><br><span class="line">        f.write(image.content)</span><br></pre><hr><h2 id="2-BS4"><a href="#2-BS4" class="headerlink" title="2.BS4"></a>2.BS4</h2><h3 id="BS4解析库解析数据原理"><a href="#BS4解析库解析数据原理" class="headerlink" title="BS4解析库解析数据原理:"></a>BS4解析库解析数据原理:</h3><p>定位标签节点  —&gt;  提取标签节点内容或属性值</p><hr><h3 id="BS4基本使用步骤"><a href="#BS4基本使用步骤" class="headerlink" title="BS4基本使用步骤:"></a>BS4基本使用步骤:</h3><pre class="highlight"><span class="line">from BS4 import BeautifulSoup</span><br><span class="line"># 网络文件实例化对象</span><br><span class="line">soup &#x3D; BeautifulSoup(text, &#39;lxml&#39;)  </span><br><span class="line">soup &#x3D; BeautifulSoup(open(&#39;filename&#39;, &#39;lxml&#39;)</span><br><span class="line">tag_element_or_attribute &#x3D; soup.选择器</span><br></pre><hr><h3 id="BS4可用选择器"><a href="#BS4可用选择器" class="headerlink" title="BS4可用选择器:"></a>BS4可用选择器:</h3><h4 id="节点选择器"><a href="#节点选择器" class="headerlink" title="节点选择器:"></a>节点选择器:</h4><pre class="highlight"><span class="line">- 节点名单选: soup.div</span><br><span class="line">- 嵌套选择: soup.div.span</span><br><span class="line">- 关联选择: </span><br><span class="line">    - 子节点:contents返回字节子节点, 包含换行符, 返回类型是一个列表</span><br><span class="line">            children效果相同, 但返回一个生成器</span><br><span class="line">    - 子孙节点:descendants, 返回生成器遍历取值</span><br><span class="line">        1).深度选择, 从第一个子节点开始, 直至第一个子节点内的所有孙节点全部选择到</span><br><span class="line">        2).如果两个标签在两行上, 匹配第一个节点的所有深度后选择换行符.</span><br><span class="line">        3).如果标签中的文本是换行的, 则不单独匹配换行符, 换行符包含在文本内</span><br><span class="line">    - 父节点:parent</span><br><span class="line">    - 祖先节点:parents</span><br><span class="line">    - 兄弟节点:</span><br><span class="line">            next_sibling: 当前节点的下一个兄弟节点</span><br><span class="line">            previous_sibling: 当前节点的上一个兄弟节点</span><br></pre><hr><h4 id="方法选择器"><a href="#方法选择器" class="headerlink" title="方法选择器:"></a>方法选择器:</h4><pre class="highlight"><span class="line">1).find_all(name, attrs, recursive, text, **kwargs)</span><br><span class="line">    </span><br><span class="line">    - 标签名选择:soup.find_all(name&#x3D;&#39;ul&#39;)   # 选择所有ul标签</span><br><span class="line">    </span><br><span class="line">    - 嵌套选择:</span><br><span class="line">        for ul in soup.find_all(name&#x3D;&#39;ul&#39;):   </span><br><span class="line">            ul.find_all(name&#x3D;&#39;li&#39;)  # 循环ul列表, 选择每个ul中的li标签</span><br><span class="line"></span><br><span class="line">    - 属性值选择:soup.find_all(attrs&#x3D;&#123;&#39;class&#39;: &#39;element&#39;&#125;), # 根据属性选择节点,等效:soup.find_all(class&#x3D;&#39;element&#39;)</span><br><span class="line">    </span><br><span class="line">    - 文本正则选择:soup.find_all(text&#x3D;re.compile(&#39;link&#39;))  # 返回所有标签中包含link字符的文字的对象</span><br><span class="line"></span><br><span class="line">2).find():返回一个对象</span><br><span class="line"></span><br></pre><hr><h4 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器:"></a>css选择器:</h4><pre class="highlight"><span class="line">css选择器需要调用select方法, 改方法返回一个列表</span><br><span class="line"></span><br><span class="line">1).选择:</span><br><span class="line">        soup.select(&#39;ul li&#39;)  # 选择ul下的li所有标签</span><br><span class="line">        soup.select(&#39;.panel&#39;)  # 选择class的值为panel的标签</span><br><span class="line">        soup.select(&#39;#item1&#39;)  # 选择id为item1的标签</span><br><span class="line">2).嵌套选择:</span><br><span class="line">    for ul in soup.select(&#39;ul&#39;):</span><br><span class="line">        ul.select(&#39;li&#39;)</span><br><span class="line">3).获取文本与属性:</span><br><span class="line">    获取属性:</span><br><span class="line">        for li in soup.select(&#39;ul li&#39;):</span><br><span class="line">            print(li.attrs[&#39;id&#39;])</span><br><span class="line">            print(li[&#39;id&#39;])   # 上下两种形式效果一致</span><br><span class="line">    获取文本:</span><br><span class="line">        for li in soup.select(&#39;ul li&#39;):</span><br><span class="line">            print(li.get_text())</span><br><span class="line">            print(li.string)</span><br><span class="line"></span><br></pre><hr><h4 id="节点文本或属性的获取"><a href="#节点文本或属性的获取" class="headerlink" title="节点文本或属性的获取"></a>节点文本或属性的获取</h4><pre class="highlight"><span class="line">tag_element.name  # 获取节点名称</span><br><span class="line">tag_element.attrs  # 获取节点所有属性, 结果为字典形式</span><br><span class="line">tag_element.attrs[&#39;name&#39;]  # 获取节点的单个属性值, 等效: tag_element[&#39;name&#39;], 属性多值是返回列表</span><br><span class="line">tag_element.string   # 获取节点的文本内容</span><br><span class="line">如果使用关联选择, 且结果为生成器可以先转为列表再索引定位元素后在调用上面的获取元素方法, 如:</span><br><span class="line">list(p.parents)[0].attrs[&#39;name&#39;]</span><br><span class="line"></span><br></pre><hr><h4 id="练习示例"><a href="#练习示例" class="headerlink" title="练习示例"></a>练习示例</h4><pre class="highlight"><span class="line">html &#x3D; &#39;&#39;&#39;</span><br><span class="line">    &lt;div class&#x3D;&quot;panel&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;panel-heading&quot;&gt;</span><br><span class="line">            &lt;h4&gt;BeautifulSoup练习&lt;&#x2F;h4&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;panel-body&quot;&gt;</span><br><span class="line">            &lt;ul class&#x3D;&quot;list&quot; id&#x3D;&quot;list-1&quot;&gt;</span><br><span class="line">                &lt;li class&#x3D;&quot;element&quot;&gt;第一个li标签&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li class&#x3D;&quot;element&quot;&gt;第二个li标签&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li class&#x3D;&quot;element&quot;&gt;第三个li标签&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">            &lt;ul class&#x3D;&quot;list list-small&quot;&gt;</span><br><span class="line">                &lt;li class&#x3D;&quot;element&quot;&gt;one&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li class&#x3D;&quot;element&quot;&gt;two&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">            &lt;li class&#x3D;&quot;element&quot;&gt;测试多层级选择器&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup &#x3D; BeautifulSoup(html, &#39;lxml&#39;)</span><br><span class="line"># 1.根据节点名定位节点, 获取其文本</span><br><span class="line">h4 &#x3D; soup.select(&#39;h4&#39;)   # 标签选择器</span><br><span class="line">print(h4[0].get_text())</span><br><span class="line"></span><br><span class="line"># 2.根据class属性定位节点</span><br><span class="line">panel &#x3D; soup.select(&#39;.panel-heading&#39;)</span><br><span class="line">print(panel)</span><br><span class="line"></span><br><span class="line"># 3.根据id属性定位节点</span><br><span class="line">ul &#x3D; soup.select(&#39;#list-1&#39;)</span><br><span class="line">print(ul)</span><br><span class="line"></span><br><span class="line"># 4.嵌套选择</span><br><span class="line">ul_list &#x3D; soup.select(&#39;ul&#39;)</span><br><span class="line">for ul in ul_list:</span><br><span class="line">    li &#x3D; ul.select(&#39;li&#39;)</span><br><span class="line">    print(li)</span><br><span class="line">    </span><br><span class="line"># 5.单层级选择器与多层级选择器</span><br><span class="line">li_list_single &#x3D; soup.select(&quot;.panel-body &gt; ul &gt; li&quot;)</span><br><span class="line">li_list_multi &#x3D; soup.select(&quot;.panel-body li&quot;)</span><br></pre><hr><h4 id="爬取整部三国演义销售-写入txt文件"><a href="#爬取整部三国演义销售-写入txt文件" class="headerlink" title="爬取整部三国演义销售, 写入txt文件:"></a>爬取整部三国演义销售, 写入txt文件:</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.shicimingju.com&#x2F;book&#x2F;sanguoyanyi.html&#39;</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line">soup &#x3D; BeautifulSoup(res.text, &#39;lxml&#39;)</span><br><span class="line">a_list &#x3D; soup.select(&quot;.book-mulu ul li a&quot;)</span><br><span class="line">for item in a_list:</span><br><span class="line">    name &#x3D; item.string</span><br><span class="line">    href &#x3D; item[&quot;href&quot;]</span><br><span class="line">    # print(href)</span><br><span class="line">    full_url &#x3D; &#39;http:&#x2F;&#x2F;www.shicimingju.com&#39; + href</span><br><span class="line">    detail_page &#x3D; requests.get(url&#x3D;full_url, headers&#x3D;headers).text</span><br><span class="line">    soup_detail &#x3D; BeautifulSoup(detail_page, &#39;lxml&#39;)</span><br><span class="line">    div &#x3D; soup_detail.select(&quot;.chapter_content&quot;)[0]</span><br><span class="line">    print(type(div.get_text()))</span><br><span class="line">    with open(&#39;%s.txt&#39; % name, &#39;w&#39;, encoding&#x3D;&quot;utf-8&quot;) as f:</span><br><span class="line">        f.write(div.get_text())</span><br></pre><hr><h2 id="3-xpath"><a href="#3-xpath" class="headerlink" title="3.xpath"></a>3.xpath</h2><h3 id="xpath解析库的介绍"><a href="#xpath解析库的介绍" class="headerlink" title="xpath解析库的介绍"></a>xpath解析库的介绍</h3><p>数据解析的过程中使用过正则表达式, 但正则表达式想要进准匹配难度较高, 一旦正则表达式书写错误, 匹配的数据也会出错.<br>网页由三部分组成: HTML, Css, JavaScript, HTML页面标签存在层级关系, 即DOM树, 在获取目标数据时可以根据网页层次关系定位标签, 在获取标签的文本或属性.</p><hr><h3 id="xpath解析库解析数据原理"><a href="#xpath解析库解析数据原理" class="headerlink" title="xpath解析库解析数据原理:"></a>xpath解析库解析数据原理:</h3><ol><li>根据网页DOM树定位节点标签</li><li>获取节点标签的正文文本或属性值</li></ol><hr><h3 id="xpath安装"><a href="#xpath安装" class="headerlink" title="xpath安装"></a>xpath安装</h3><pre class="highlight"><span class="line">pip install lxml</span><br></pre><hr><h3 id="requests模块爬取糗事百科热门的标题"><a href="#requests模块爬取糗事百科热门的标题" class="headerlink" title="requests模块爬取糗事百科热门的标题:"></a>requests模块爬取糗事百科热门的标题:</h3><pre class="highlight"><span class="line">import requests</span><br><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;www.qiushibaike.com&#x2F;&#39;</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line"></span><br><span class="line">tree &#x3D; etree.HTML(res.text)</span><br><span class="line">title_lst &#x3D; tree.xpath(&#39;&#x2F;&#x2F;ul&#x2F;li&#x2F;div&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">for item in title_lst:</span><br><span class="line">    print(item)</span><br></pre><hr><h3 id="xpath使用步骤"><a href="#xpath使用步骤" class="headerlink" title="xpath使用步骤"></a>xpath使用步骤</h3><pre class="highlight"><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">tree &#x3D; etree.HTML(res.text)</span><br><span class="line">tree &#x3D; etree.parse(res.html, etree.HTMLParse())  # 示例如下, 了解内容</span><br><span class="line"></span><br><span class="line">tag_or_attr &#x3D; tree.xpath(&#39;xpath表达式&#39;)</span><br></pre><hr><h3 id="xpath语法"><a href="#xpath语法" class="headerlink" title="xpath语法:"></a>xpath语法:</h3><pre class="highlight"><span class="line">1.常用规则:</span><br><span class="line">      1.  nodename:  节点名定位</span><br><span class="line">      2.  &#x2F;&#x2F;:  从当前节点选取子孙节点</span><br><span class="line">      3.  &#x2F;:  从当前节点选取直接子节点</span><br><span class="line">      4.  nodename[@attribute&#x3D;&quot;...&quot;]  根据属性定位标签</span><br><span class="line">      5.  @attributename:  获取属性 </span><br><span class="line">      6.  text():   获取文本</span><br><span class="line">   </span><br><span class="line">2.属性匹配两种情况: 多属性匹配 &amp;  单属性多值匹配  </span><br><span class="line">    2.1 单属性多值匹配</span><br><span class="line">    示例: tree.xpath(&#39;&#x2F;&#x2F;div[contains(@class, &quot;dc&quot;)]&#x2F;text()&#39;)</span><br><span class="line"></span><br><span class="line">    2.2 多属性匹配</span><br><span class="line">    示例: tree.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;item&quot; and @name&#x3D;&quot;test&quot;]&#x2F;text()&#39;) </span><br><span class="line">    </span><br><span class="line">3.按序选择:</span><br><span class="line">    3.1 索引定位: 从1开始</span><br><span class="line">    3.2 last()函数</span><br><span class="line">    3.3 position()函数</span><br><span class="line"></span><br></pre><hr><h3 id="获取响应数据内容"><a href="#获取响应数据内容" class="headerlink" title="获取响应数据内容:"></a>获取响应数据内容:</h3><pre><code>res.text        获取HTML文本res.content        获取二进制流res.json()        获取json数据</code></pre><hr><h3 id="解析示例-示例解析的是本地文件"><a href="#解析示例-示例解析的是本地文件" class="headerlink" title="解析示例: 示例解析的是本地文件"></a>解析示例: 示例解析的是本地文件</h3><h5 id="本地文件"><a href="#本地文件" class="headerlink" title="本地文件"></a>本地文件</h5><pre class="highlight"><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Xpath练习文件&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;007&quot;&gt;</span><br><span class="line">    &quot;我是div标签的文字内容, 和下面的p标签还有div标签是同级的哦&quot;</span><br><span class="line">    &lt;p&gt;这是p标签内的文字内容&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;div&gt;这是p标签同级的div标签&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;divtag&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;第1个li标签&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;第2个li标签&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;第3个li标签&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;第4个li标签&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;第5个li标签&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&quot;&gt;这是百度的跳转连接&lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;c1&quot; name&#x3D;&quot;laoda&quot;&gt;老大在此&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;c1 c3&quot; name&#x3D;&quot;laoer&quot;&gt;老二任性, class有两个值&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;c1&quot; name&#x3D;&quot;laosan&quot;&gt;我是老三&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre><h5 id="解析本地文件"><a href="#解析本地文件" class="headerlink" title="解析本地文件"></a>解析本地文件</h5><pre class="highlight"><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">tree &#x3D; etree.parse(&#39;.&#x2F;x.html&#39;, etree.HTMLParser())</span><br><span class="line"></span><br><span class="line"># 1.根据节点名, 即nodename定位title标签, 获取标签内文字</span><br><span class="line">title_text &#x3D; tree.xpath(&#39;&#x2F;&#x2F;title&#x2F;text()&#39;)</span><br><span class="line">print(title_text)</span><br><span class="line"></span><br><span class="line"># 2.根据节点属性定位: 定位id为007的div标签</span><br><span class="line">div_007 &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@id&#x3D;&quot;007&quot;]&#39;)</span><br><span class="line">print(div_007)</span><br><span class="line"></span><br><span class="line"># 3.示例直接子节点与子孙节点:&#x2F;, &#x2F;&#x2F;</span><br><span class="line">div_007_one &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@id&#x3D;&quot;007&quot;]&#x2F;text()&#39;)</span><br><span class="line">print(div_007_one)</span><br><span class="line">div_007_two &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@id&#x3D;&quot;007&quot;]&#x2F;&#x2F;text()&#39;)</span><br><span class="line">print(div_007_two)</span><br><span class="line"></span><br><span class="line"># 4.获取a标签的href属性</span><br><span class="line">a_href &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;divtag&quot;]&#x2F;a&#x2F;@href&#39;)</span><br><span class="line">print(a_href)</span><br><span class="line"></span><br><span class="line"># 4.多属性定位: 根据class属性和name属性定位div标签</span><br><span class="line">div_two_attr &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;c1&quot; and @name&#x3D;&quot;laoda&quot;]&#x2F;text()&#39;)</span><br><span class="line">print(div_two_attr)</span><br><span class="line"></span><br><span class="line"># 5.属性多值定位: 定位所有class中有c1的div标签</span><br><span class="line">div_c1 &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[contains(@class, &quot;c1&quot;)]&#39;)</span><br><span class="line"></span><br><span class="line"># 6.按序定位</span><br><span class="line">li_first &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;divtag&quot;]&#x2F;ul&#x2F;li[1]&#x2F;text()&#39;)  # 定位第一个li标签, 获取其文本</span><br><span class="line">print(li_first)</span><br><span class="line"></span><br><span class="line">li_last &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;divtag&quot;]&#x2F;ul&#x2F;li[last()]&#x2F;text()&#39;)  # 定位最后一个li标签</span><br><span class="line">print(li_last)</span><br><span class="line"></span><br><span class="line">li_daotwo &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;divtag&quot;]&#x2F;ul&#x2F;li[last()-1]&#x2F;text()&#39;)  # 定位倒数第二个li标签</span><br><span class="line">print(li_daotwo)</span><br><span class="line"></span><br><span class="line">li_qianthree &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;divtag&quot;]&#x2F;ul&#x2F;li[position()&lt;4]&#x2F;text()&#39;)  # 定位前三个li标签</span><br><span class="line">print(li_qianthree)</span><br></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>requests模块初级用法&amp;高级用法</title>
      <link href="/2018/07/17/requests%E6%A8%A1%E5%9D%97%E5%88%9D%E7%BA%A7%E7%94%A8%E6%B3%95&amp;%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
      <url>/2018/07/17/requests%E6%A8%A1%E5%9D%97%E5%88%9D%E7%BA%A7%E7%94%A8%E6%B3%95&amp;%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-requests模块初级用法"><a href="#1-requests模块初级用法" class="headerlink" title="1.requests模块初级用法"></a>1.requests模块初级用法</h2><h3 id="requests库的安装"><a href="#requests库的安装" class="headerlink" title="requests库的安装"></a>requests库的安装</h3><pre class="highlight"><span class="line">pip install requests</span><br></pre><hr><h3 id="get请求"><a href="#get请求" class="headerlink" title="get请求:"></a>get请求:</h3><ul><li>不携带参数的get请求</li><li>不携带参数的get请求 + headers</li><li>携带参数的get请求 + headers</li></ul><h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求:"></a>post请求:</h3><ul><li>构建参数的post请求</li></ul><h3 id="响应数据的获取与属性"><a href="#响应数据的获取与属性" class="headerlink" title="响应数据的获取与属性"></a>响应数据的获取与属性</h3><pre><code>(1).响应数据的获取:        res.text: 文本数据        res.json(): json数据        res.content: 流(2).响应的其他属性:        res.status_code: 获取响应状态码        res.headers: 响应头        res.cookie: cookie信息</code></pre><hr><h3 id="requests模块的get请求"><a href="#requests模块的get请求" class="headerlink" title="requests模块的get请求"></a>requests模块的get请求</h3><h4 id="1-不携带参数的get请求-爬取搜狗主页"><a href="#1-不携带参数的get请求-爬取搜狗主页" class="headerlink" title="1.不携带参数的get请求: 爬取搜狗主页"></a>1.不携带参数的get请求: 爬取搜狗主页</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;www.sogou.com&#x2F;&#39;</span><br><span class="line">res &#x3D; requests.get(url&#x3D;url)</span><br><span class="line">print(res)</span><br><span class="line">print(res.text)</span><br><span class="line"></span><br><span class="line">with open(&#39;sougou.html&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">    f.write(res.text)</span><br></pre><hr><h4 id="2-不携带参数的get请求-headers-爬取知乎的发现页"><a href="#2-不携带参数的get请求-headers-爬取知乎的发现页" class="headerlink" title="2.不携带参数的get请求  +  headers: 爬取知乎的发现页"></a>2.不携带参数的get请求  +  headers: 爬取知乎的发现页</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;www.zhihu.com&#x2F;explore&#39;</span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line">with open(&#39;zhihu.html&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">    f.write(res.text)</span><br></pre><hr><h4 id="3-携带参数的get请求-headers-知乎的发现栏中搜索Python"><a href="#3-携带参数的get请求-headers-知乎的发现栏中搜索Python" class="headerlink" title="3.携带参数的get请求  +  headers: 知乎的发现栏中搜索Python"></a>3.携带参数的get请求  +  headers: 知乎的发现栏中搜索Python</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">url&#x3D; &#39;https:&#x2F;&#x2F;www.zhihu.com&#x2F;search?&#39;</span><br><span class="line">params &#x3D; &#123;</span><br><span class="line">    &#39;type&#39;:&#39;content&#39;,</span><br><span class="line">    &#39;q&#39;:&#39;python&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers, params&#x3D;params)</span><br><span class="line">print(res)</span><br><span class="line">print(res.text)</span><br><span class="line">with open(&#39;python.html&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">    f.write(res.text)</span><br></pre><hr><h3 id="4-requests模块的post请求"><a href="#4-requests模块的post请求" class="headerlink" title="4.requests模块的post请求:"></a>4.requests模块的post请求:</h3><h4 id="以post方式请求httpbin-org-post时会返回提交的请求信息"><a href="#以post方式请求httpbin-org-post时会返回提交的请求信息" class="headerlink" title="以post方式请求httpbin.org/post时会返回提交的请求信息"></a>以post方式请求httpbin.org/post时会返回提交的请求信息</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">     &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;</span><br><span class="line">data &#x3D; &#123;</span><br><span class="line">    &#39;name&#39;: &#39;spiderman&#39;,</span><br><span class="line">    &#39;age&#39;: 8</span><br><span class="line">&#125;</span><br><span class="line">res &#x3D; requests.post(url&#x3D;url, headers&#x3D;headers, data&#x3D;data)</span><br><span class="line">print(res.text)</span><br></pre><h4 id="以post方式请求百度翻译返回请求信息"><a href="#以post方式请求百度翻译返回请求信息" class="headerlink" title="以post方式请求百度翻译返回请求信息"></a>以post方式请求百度翻译返回请求信息</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line"></span><br><span class="line">#  确定url,发送请求，响应数据</span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;fanyi.baidu.com&#x2F;sug&#39;</span><br><span class="line">while 1:</span><br><span class="line">    kw &#x3D; input(&#39;请输入需要查询的单词：&#39;)</span><br><span class="line">    if kw &#x3D;&#x3D; &#39;q&#39;:</span><br><span class="line">        break</span><br><span class="line">    params &#x3D; &#123;</span><br><span class="line">        &#39;kw&#39;:kw</span><br><span class="line">    &#125;</span><br><span class="line">    headers &#x3D; &#123;</span><br><span class="line">        &#39;User-agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;80.0.3987.106 Safari&#x2F;537.36&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    res &#x3D; requests.post(url &#x3D; url,headers &#x3D; headers,params &#x3D; params).json()</span><br><span class="line">    # print(res)</span><br><span class="line">    kdata &#x3D; res[&#39;data&#39;][0][&#39;v&#39;]</span><br><span class="line">    print(kdata)</span><br></pre><hr><h3 id="json形式与流形式的响应数据示例"><a href="#json形式与流形式的响应数据示例" class="headerlink" title="json形式与流形式的响应数据示例"></a>json形式与流形式的响应数据示例</h3><h4 id="1-json形式响应数据示例-bilibili的Python视频教程-目录列表"><a href="#1-json形式响应数据示例-bilibili的Python视频教程-目录列表" class="headerlink" title="1.json形式响应数据示例: bilibili的Python视频教程, 目录列表"></a>1.json形式响应数据示例: bilibili的Python视频教程, 目录列表</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">     &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;api.bilibili.com&#x2F;x&#x2F;web-interface&#x2F;view?aid&#x3D;14184325&amp;cid&#x3D;23153678&#39;</span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line">print(res)</span><br><span class="line">print(res.status_code)</span><br><span class="line">print(res.headers)</span><br><span class="line">print(&#39;~~~~~~&#39;)</span><br><span class="line">print(res.json())</span><br></pre><hr><h4 id="2-流形式响应数据示例-站长素材的简历模板"><a href="#2-流形式响应数据示例-站长素材的简历模板" class="headerlink" title="2.流形式响应数据示例: 站长素材的简历模板"></a>2.流形式响应数据示例: 站长素材的简历模板</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">     &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;fjdx.sc.chinaz.net&#x2F;Files&#x2F;DownLoad&#x2F;jianli&#x2F;201907&#x2F;jianli10810.rar&#39;</span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line">print(res.content)</span><br><span class="line">with open(&#39;janli.rar&#39;, &#39;wb&#39;) as f:</span><br><span class="line">    f.write(res.content)</span><br></pre><hr><h2 id="2-requests模块高级用法"><a href="#2-requests模块高级用法" class="headerlink" title="2.requests模块高级用法"></a>2.requests模块高级用法</h2><h3 id="文件上传功能"><a href="#文件上传功能" class="headerlink" title="文件上传功能"></a>文件上传功能</h3><pre class="highlight"><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># 定义上传文件数据, 键为file, 值为文件句柄</span><br><span class="line">files &#x3D; &#123;</span><br><span class="line">&#39;file&#39;: open(&#39;favicon.ico&#39;, &#39;rb&#39;)</span><br><span class="line">&#125;</span><br><span class="line">r &#x3D; requests.post(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;, files&#x3D;files)</span><br><span class="line">print(res.text)</span><br></pre><hr><h3 id="cookie处理方法"><a href="#cookie处理方法" class="headerlink" title="cookie处理方法"></a>cookie处理方法</h3><ol><li>headers添加cookie键值对</li><li>RequestsCookieJar对象</li></ol><hr><h4 id="headers内添加cookie键值对处理cookie"><a href="#headers内添加cookie键值对处理cookie" class="headerlink" title="headers内添加cookie键值对处理cookie"></a>headers内添加cookie键值对处理cookie</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;,</span><br><span class="line">    &#39;Cookies&#39;:&#39;BAIDUID&#x3D;79A570F8D90B2C45E42D40A3666ADC46:FG&#x3D;1; BIDUPSID&#x3D;79A570F8D90B2C45E42D40A3666ADC46; PSTM&#x3D;1551074009; BD_UPN&#x3D;12314753; sugstore&#x3D;0; BDORZ&#x3D;FFFB88E999055A3F8A630C64834BD6D0; yjs_js_security_passport&#x3D;10c9ca61409abe70ac5c03db796f78648e697d8f_1563711806_js; COOKIE_SESSION&#x3D;2860_2_2_7_3_5_0_0_2_4_106_0_3778_177561_116_109_1563714759_1563714752_1563714643%7C9%23177557_14_1563714643%7C7; delPer&#x3D;0; BD_HOME&#x3D;0; H_PS_PSSID&#x3D;1452_21117_29522_29521_28519_29099_28831_29221&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line">res.encoding &#x3D; &#39;utf-8&#39;</span><br><span class="line">with open(&#39;baidu_cookie.html&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">    f.write(res.text)</span><br></pre><hr><h4 id="RequestsCookieJar对象处理cookie-用cookie维持百度登陆"><a href="#RequestsCookieJar对象处理cookie-用cookie维持百度登陆" class="headerlink" title="RequestsCookieJar对象处理cookie: 用cookie维持百度登陆"></a>RequestsCookieJar对象处理cookie: 用cookie维持百度登陆</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">cookies &#x3D; &#39;BAIDUID&#x3D;79A570F8D90B2C45E42D40A3666ADC46:FG&#x3D;1; BIDUPSID&#x3D;79A570F8D90B2C45E42D40A3666ADC46; PSTM&#x3D;1551074009; BD_UPN&#x3D;12314753; sugstore&#x3D;0; BDORZ&#x3D;FFFB88E999055A3F8A630C64834BD6D0; yjs_js_security_passport&#x3D;10c9ca61409abe70ac5c03db796f78648e697d8f_1563711806_js; COOKIE_SESSION&#x3D;2860_2_2_7_3_5_0_0_2_4_106_0_3778_177561_116_109_1563714759_1563714752_1563714643%7C9%23177557_14_1563714643%7C7; delPer&#x3D;0; BD_HOME&#x3D;0; H_PS_PSSID&#x3D;1452_21117_29522_29521_28519_29099_28831_29221; BDUSS&#x3D;lSVnBVVkRVNFpNZ2ZJZ2ZpNFpjblFFSX5EaW9DNzBpcnNkaDZIQVdRd2Z1bHhkRVFBQUFBJCQAAAAAAAAAAAEAAABwfMtW09rQodPjMDgyMGZyZWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8tNV0fLTVdYX&#39;</span><br><span class="line">jar &#x3D; requests.cookies.RequestsCookieJar()</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &#39;User-Agetn&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">for cookie in cookies.split(&#39;;&#39;):</span><br><span class="line">    key, value &#x3D; cookie.split(&#39;&#x3D;&#39;, 1)</span><br><span class="line">    jar.set(key, value)</span><br><span class="line">    </span><br><span class="line">res &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.baidu.com&#39;, cookies&#x3D;jar, headers&#x3D;headers)</span><br><span class="line">print(res.text)  # 响应数据中包含用户名信息, 说明cookie生效</span><br></pre><hr><h3 id="会话维持"><a href="#会话维持" class="headerlink" title="会话维持"></a>会话维持</h3><h4 id="HTTP无状态"><a href="#HTTP无状态" class="headerlink" title="HTTP无状态:"></a>HTTP无状态:</h4><p>使用requests模块中的get()和post()方法请求网页时, 每一次请求都是独立的, 没有连续请求之间的状态保持. 假象, 如果你登陆了淘宝后向查看订单, 那么如果没有状态的维持就无法实现.</p><hr><h3 id="会话的维持-Session对象"><a href="#会话的维持-Session对象" class="headerlink" title="会话的维持: Session对象"></a>会话的维持: Session对象</h3><pre class="highlight"><span class="line">from requests import Session</span><br><span class="line">s &#x3D; Session()</span><br><span class="line">res &#x3D; s.get(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;)</span><br></pre><hr><h3 id="SSL证书验证"><a href="#SSL证书验证" class="headerlink" title="SSL证书验证"></a>SSL证书验证</h3><h4 id="1-SSL证书验证"><a href="#1-SSL证书验证" class="headerlink" title="1.SSL证书验证"></a>1.SSL证书验证</h4><p>requests提供了证书验证的功能. 当发起HTTP请求时, 模块会检查SSL证书. 但检查的行为可以用verify参数来控制.</p><pre class="highlight"><span class="line">verify &#x3D; False  # 不检查SSL证书</span><br><span class="line">verify &#x3D; True  # 检查SSL证书</span><br></pre><h4 id="2-异常"><a href="#2-异常" class="headerlink" title="2.异常"></a>2.异常</h4><p>如果使用requests模块的SSL验证, 验证不通过会抛出异常, 此时可以将verify参数设置为False</p><h4 id="3-www-12306-cn的证书验证"><a href="#3-www-12306-cn的证书验证" class="headerlink" title="3.www.12306.cn的证书验证:"></a>3.<a href="http://www.12306.cn的证书验证/">www.12306.cn的证书验证</a>:</h4><h5 id="会抛出异常"><a href="#会抛出异常" class="headerlink" title="会抛出异常"></a>会抛出异常</h5><pre class="highlight"><span class="line">import requests</span><br><span class="line">response &#x3D; requests.get(&#39;https:&#x2F;&#x2F;www.12306.cn&#39;)</span><br><span class="line">print(response.status_code)</span><br></pre><h5 id="不抛异常-但会出现警告"><a href="#不抛异常-但会出现警告" class="headerlink" title="不抛异常, 但会出现警告"></a>不抛异常, 但会出现警告</h5><pre class="highlight"><span class="line">import requests</span><br><span class="line">response &#x3D; requests.get(&#39;https:&#x2F;&#x2F;www.12306.cn&#39;, verify&#x3D;False)</span><br><span class="line">print(response.status_code)</span><br></pre><h5 id="禁止警告"><a href="#禁止警告" class="headerlink" title="禁止警告"></a>禁止警告</h5><pre class="highlight"><span class="line">import requests</span><br><span class="line">from requests.packages import urllib3</span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line">response &#x3D; requests.get(url&#x3D;&#39;https:&#x2F;&#x2F;www.12306.cn&#39;, verify&#x3D;False)</span><br><span class="line">print(response.status_code)</span><br></pre><hr><h3 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h3><h5 id="代理-代理即代理ip"><a href="#代理-代理即代理ip" class="headerlink" title="代理: 代理即代理ip"></a>代理: 代理即代理ip</h5><p>代理ip是指在请求的过程中使用非本机ip进行请求, 避免大数据量频繁请求的过程中出现ip封禁, 限制数据的爬取.</p><hr><h5 id="代理ip分类"><a href="#代理ip分类" class="headerlink" title="代理ip分类:"></a>代理ip分类:</h5><ol><li>透明代理ip: 请求时, 服务器知道请求的真实ip, 知道请求使用了代理</li><li>匿名代理ip: 请求时, 服务器知道请求使用了代理, 但不知道请求的真实ip</li><li>高匿代理ip: 请求时, 服务器不知道请求使用了代理, 也不知道请求的真实ip</li></ol><hr><h4 id="requests模块使用代理ip"><a href="#requests模块使用代理ip" class="headerlink" title="requests模块使用代理ip"></a>requests模块使用代理ip</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.httpbin.org&#39;</span><br><span class="line">proxies &#x3D; &#123;</span><br><span class="line">    &#39;http&#39;: &#39;http:&#x2F;&#x2F;61.183.176.122:57210&#39;</span><br><span class="line">&#125;</span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, proxies&#x3D;proxies)</span><br><span class="line">print(res.text)</span><br></pre><hr><h3 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h3><p>由于网络状况的不同, 服务器配置差异以及服务器处理并发的能力不同, 有时会出现服务器的响应时间过长, 甚至无法获取响应而抛出异常. requests模块发送请求可以设置超时时间, 在超时时间内未得到响应, 便会抛出异常.<br>一方面, 减少了请求的阻塞时间, 一方面, 可以进行异常处理, 执行相应的操作.</p><pre class="highlight"><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers, timeout&#x3D;0.001)  # 在0.001秒为得到响应, 抛出requests.exceptions.ConnectTimeout异常</span><br><span class="line">print(res.text)</span><br></pre><hr><h3 id="构建Request对象"><a href="#构建Request对象" class="headerlink" title="构建Request对象"></a>构建Request对象</h3><pre class="highlight"><span class="line"># 1.Prepared Request</span><br><span class="line">利用 Prepared Request 数据结构构件Request对象. 其构建及使用步骤如下:</span><br><span class="line">from requests import Request, Session</span><br><span class="line"></span><br><span class="line"># 构建Request对象</span><br><span class="line">url &#x3D; &#39;...&#39;</span><br><span class="line">data &#x3D; &#123;...&#125;</span><br><span class="line">params &#x3D; &#123;...&#125;</span><br><span class="line">headers &#x3D; &#123;...&#125;</span><br><span class="line">session &#x3D; Session()</span><br><span class="line"></span><br><span class="line"># 构建post请求:</span><br><span class="line">req_post &#x3D; Request(method&#x3D;&#39;POST&#39;, url&#x3D;url, headers&#x3D;headers, data&#x3D;data)</span><br><span class="line">req_obj_post &#x3D; session.prepare_request(req_post)</span><br><span class="line"></span><br><span class="line"># 构建get请求:</span><br><span class="line">req_get &#x3D; Request(method&#x3D;&#39;GET&#39;, url&#x3D;url, headers&#x3D;headers, params&#x3D;params)</span><br><span class="line">req_obj_get &#x3D; session.prepare_request(req_get)</span><br><span class="line"></span><br><span class="line"># 利用构建的请求对象, 向服务器发送请求</span><br><span class="line">res &#x3D; session.send(req_obj_post)</span><br><span class="line">res &#x3D; session.send(req_obj_get)</span><br><span class="line"></span><br><span class="line"># 应用:</span><br><span class="line">通过此方法, 我们可以构建一个独立的request对象, 当需要请求的url很多时, 我们可以为每一个url构建一个request对象, 将所有request对象置于队列中, 便于调度.</span><br></pre><hr><h5 id="构建Request对象-请求糗事百科获取页面"><a href="#构建Request对象-请求糗事百科获取页面" class="headerlink" title="构建Request对象, 请求糗事百科获取页面"></a>构建Request对象, 请求糗事百科获取页面</h5><pre class="highlight"><span class="line">from requests import Request, Session</span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;www.qiushibaike.com&#x2F;&#39;</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">session &#x3D; Session()</span><br><span class="line">req_get &#x3D; Request(url&#x3D;url, headers&#x3D;headers, method&#x3D;&#39;GET&#39;)</span><br><span class="line">req_get_obj &#x3D; session.prepare_request(req_get)</span><br><span class="line">res &#x3D; session.send(req_get_obj)</span><br><span class="line">res.encoding &#x3D; &#39;utf-8&#39;</span><br><span class="line">with open(&#39;qb_reqobj.html&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">    f.write(res.text)</span><br></pre><hr><h3 id="urllib简单介绍"><a href="#urllib简单介绍" class="headerlink" title="urllib简单介绍"></a>urllib简单介绍</h3><h5 id="urllib简介"><a href="#urllib简介" class="headerlink" title="urllib简介:"></a>urllib简介:</h5><ul><li>urllib模块是Python的一个请求模块</li><li>Python2中是urllib和urllib2相结合实现请求的发送. Python3中同一为urllib库</li><li>urllib是Python内置的请求库, 其包含4个模块:<ul><li>request模块: 模拟发送请求</li><li>error模块: 异常处理模块</li><li>parse模块: 工具模块, 提供关于URL的处理方法, 如拆分, 解析, 合并等</li><li>robotparser模块: 识别robots协议</li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫概述&amp;协议&amp;请求</title>
      <link href="/2018/07/11/%E7%88%AC%E8%99%AB%E6%A6%82%E8%BF%B0&amp;%E5%8D%8F%E8%AE%AE&amp;%E8%AF%B7%E6%B1%82/"/>
      <url>/2018/07/11/%E7%88%AC%E8%99%AB%E6%A6%82%E8%BF%B0&amp;%E5%8D%8F%E8%AE%AE&amp;%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="1-爬虫概念"><a href="#1-爬虫概念" class="headerlink" title="1.爬虫概念"></a>1.爬虫概念</h2><p>爬虫, 又称网页蜘蛛或网络机器人，爬虫是 模拟人操作客户端(浏览器, APP) 向服务器发起网络请求 抓取数据的自动化程序或脚本.</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><ul><li>模拟: 用爬虫程序伪装出人的行为, 避免被服务识别为爬虫程序</li><li>客户端: 浏览器, APP都可以实现人与服务器之间的交互行为, 应用客户端从服务器获取数据</li><li>自动化: 数据量较小时可以人工获取数据, 但往往在公司中爬取的数据量在百万条, 千万条级别的, 所以要程序自动化获取数据.</li></ul><hr><h2 id="2-爬虫语言"><a href="#2-爬虫语言" class="headerlink" title="2.爬虫语言"></a>2.爬虫语言</h2><h3 id="爬虫语言："><a href="#爬虫语言：" class="headerlink" title="爬虫语言："></a>爬虫语言：</h3><pre class="highlight"><span class="line">PHP, C&#x2F;C++, Java, Python</span><br></pre><h3 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h3><ol><li>PHP: 并发能力差, 对多进程和多线程支持不好, 数据量较大时爬虫效率较低</li><li>C/C++: 语言效率高, 但学习成本高, 对程序员的技术能力要求较高,  所以目前还停留在研究层面, 市场需求量很小</li><li>Java: Python爬虫的主要竞争对手, 由于Java语言的特点, 代码臃肿, 代码量大, 维护成本重构成本高, 开发效率低. 但目前市场上岗位需求比较旺盛.</li><li>Python:语法简单, 学习成本较低, 对新手比较友好. Python语言良好的生态, 大量库和框架的支持是的Python爬虫目前处于爬虫圈的主导地位.</li></ol><hr><h2 id="3-爬虫分类"><a href="#3-爬虫分类" class="headerlink" title="3.爬虫分类"></a>3.爬虫分类</h2><p> a. 通用爬虫</p><p> b. 聚焦爬虫</p><h3 id="通用爬虫"><a href="#通用爬虫" class="headerlink" title="通用爬虫"></a>通用爬虫</h3><ul><li><p>通用爬虫：约定哪些内容允许哪些爬虫抓取—&gt;搜索引擎</p></li><li><p>实例: 百度, 搜狗, Google的搜索引擎</p></li><li><p>功能: 访问网页 -&gt; 抓取数据 -&gt; 数据处理 -&gt; 提供检索服务</p></li><li><p>工作流:</p><ol><li>给定一个起始URL, 存于爬取队列中</li><li>爬虫程序从队列中取出url, 爬取数据</li><li>解析爬取数据, 获取网页内的所有url, 放入爬取队列</li><li>重复第二个步骤</li></ol></li><li><p>使搜索引擎获取网站链接:</p><ol><li>主动将url提交各搜索引擎</li><li>在其他热门网站设置友情了解</li><li>百度和DNS服务商合作, 收录新网站</li></ol></li><li><p>网站排名(SEO):</p><ol><li>根据PageRank值进行排名(流量, 点击率)</li><li>百度竞价排名, 钱多就靠前排</li></ol></li><li><p>缺点:</p><ol><li>抓取的内容多数无用</li><li>无法精确获取数据</li></ol></li></ul><p>协议: 无需遵守robots协议</p><ul><li>查看方法：网站url/robots.txt, 如<a href="https://www.baidu.com/robots.txt">https://www.baidu.com/robots.txt</a></li></ul><hr><h3 id="聚焦爬虫"><a href="#聚焦爬虫" class="headerlink" title="聚焦爬虫"></a>聚焦爬虫</h3><ul><li>概念：聚焦爬虫指针对某一领域根据特定要求实现的爬虫程序, 抓取需要的数据(垂直领域爬取)</li><li>设计思路：<ol><li>确定爬取的url, 模拟浏览器请服务器发送请求:requests,urllib,aiohttp</li><li>获取响应数据并进行数据解析:xpath,bs4,pyquery,正则</li><li>将目标数据持久化：文件，关系型数据库，非关系型数据库</li></ol></li></ul><pre class="highlight"><span class="line"># 需求: 爬取百度首页, 并写入文件中, 最后用浏览器打开文件查看效果</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># 1.确定url, 向服务器发送请求</span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line">res &#x3D; resquests.get(url&#x3D;url)</span><br><span class="line"></span><br><span class="line"># 2.操作响应数据, 获取目标数据</span><br><span class="line">res.encoding &#x3D; &#39;utf-8&#39;</span><br><span class="line"></span><br><span class="line"># 3.将目标数据持久化到本地: 写入文件</span><br><span class="line">with open(&#39;baidu.html&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">    f.write(res.text)</span><br></pre><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/hugoblog/jujiao.png" alt="集聚爬虫设计思路" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/jujiao.png" class="lozad post-image"></h2><hr><h2 id="4-爬虫反爬机制与反反爬策略"><a href="#4-爬虫反爬机制与反反爬策略" class="headerlink" title="4.爬虫反爬机制与反反爬策略"></a>4.爬虫反爬机制与反反爬策略</h2><ul><li>UA检测</li><li>robot协议</li><li>动态数据加载: JS动态数据加载, Ajax数据加载</li><li>IP封禁</li><li>账号封禁</li><li>验证码</li><li>数据加密</li><li>隐藏参数</li><li>图片懒加载</li></ul><hr><h2 id="5-协议"><a href="#5-协议" class="headerlink" title="5.协议"></a>5.协议</h2><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><ul><li>HTTP协议: 明文传输, 端口80</li><li>Http协议, 全称为Hyper Text Transfer Protocol, 即超文本传输协议.</li><li>HTTP协议是用于从网络传输超文本数据到本地浏览器的传送协议, 它能保证高效而准确地传送超文本文档.</li><li>目前广泛使用的是HTTP 1.1版本<h3 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h3></li><li>HTTPS协议: 加密传输, 端口443</li><li>HTTPS全称是Hyper Text Transfer Protocol over Secure Socket Layer, 是以安全为目标的HTTP通道. HTTPS协议实质是HTTP的安全版, 即HTTP下加入SSL层, 简称HTTPS.</li><li>HTTPS的安全体现在SSL的加密行为, 即通过HTTPS协议传输的数据都是经过SSL加密的</li><li>HTTPS的作用:<ol><li>建立一个信息安全的通道来保证数据传输的安全</li><li>确认网站的真实性, 凡是使用了HTTPS的网站, 都可以通过点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息, 也可以通过CA机构颁发的安全签章来查询</li></ol></li></ul><hr><h2 id="6-服务器常见端口"><a href="#6-服务器常见端口" class="headerlink" title="6.服务器常见端口"></a>6.服务器常见端口</h2><ol><li>ftp：File Transfer Protocol的缩写, 即文件传输协议. 端口：21</li><li>ssh：Secure Shell的缩写, 用于远程登录会话. 端口：22</li><li>MySQL：关系型数据库, 端口：3306</li><li>MongoDB：非关系型数据库, 端口：27017</li><li>Redis：非关系型数据库, 端口：6379</li></ol><hr><h2 id="7-开发准备"><a href="#7-开发准备" class="headerlink" title="7.开发准备"></a>7.开发准备</h2><h3 id="web端"><a href="#web端" class="headerlink" title="web端"></a>web端</h3><pre class="highlight"><span class="line">Python3.6</span><br><span class="line">Pycharm</span><br><span class="line">Google Chrome</span><br></pre><h3 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h3><pre class="highlight"><span class="line">fiddler抓包工具</span><br><span class="line">Charles抓包工具</span><br><span class="line">Appium自动化测试工具</span><br></pre><hr><h2 id="8-请求过程与网页基础"><a href="#8-请求过程与网页基础" class="headerlink" title="8.请求过程与网页基础"></a>8.请求过程与网页基础</h2><h3 id="URL介绍"><a href="#URL介绍" class="headerlink" title="URL介绍"></a>URL介绍</h3><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/hugoblog/url.png" alt="url" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/url.png" class="lozad post-image"></h2><h3 id="HTTP请求过程"><a href="#HTTP请求过程" class="headerlink" title="HTTP请求过程"></a>HTTP请求过程</h3><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="/hugoblog/qingqiu.png" alt="请求" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/qingqiu.png" class="lozad post-image"></h2><h3 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程:"></a>请求过程:</h3><p>客户端, 通常指web浏览器或APP向服务器发起请求, 服务器接收到请求进行处理, 并向客户端发起响应.</p><hr><h2 id="9-请求"><a href="#9-请求" class="headerlink" title="9.请求"></a>9.请求</h2><p>由客户端向服务器发出的,可以分为四部分内容:  </p><ol><li>请求方法(Request Method) </li><li>请求网址(Request URL)</li><li>请求头(Request Headers)</li><li>请求体(Request Body)</li></ol><hr><h3 id="请求方法-常见有8种"><a href="#请求方法-常见有8种" class="headerlink" title="请求方法:常见有8种"></a>请求方法:常见有8种</h3><pre class="highlight"><span class="line">- GET：请求页面, 并返回页面内容 </span><br><span class="line">- POST：用于提交表单数据或上传文件, 数据包含在请求体中  </span><br><span class="line">- PUT：从客户端向服务器传送的数据取代指定文档中的内容</span><br><span class="line">- DELETE：请求服务器删除指定的页面</span><br><span class="line">- HEAD：类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</span><br><span class="line">- CONNECT：把服务器当作跳板，让服务器代替客户端访问其他网页</span><br><span class="line">- OPTIONS：允许客户端查看服务器的性能</span><br><span class="line">- TRACE：回显服务器收到的请求，主要用于测试或诊断</span><br></pre><hr><h3 id="重点掌握GET-amp-POST的区别"><a href="#重点掌握GET-amp-POST的区别" class="headerlink" title="重点掌握GET &amp; POST的区别:"></a>重点掌握GET &amp; POST的区别:</h3><ol><li>GET请求中的参数包含在URL里面, 数据可以在URL中看到, 而POST请求的URL不会包含这些数据, POST的数据都是通过表单形式传输的, 会包含在请求体中</li><li>GET请求提交的数据最多只有1024字节, 而POST方式没有限制</li></ol><hr><h3 id="请求网址"><a href="#请求网址" class="headerlink" title="请求网址:"></a>请求网址:</h3><p>请求的网址，即统一资源定位符URL，它可以唯一确定我们想请求的资源</p><hr><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头:"></a>请求头:</h3><p>请求头:用来说明服务器要使用的附加信息. 重点: Accept, Cookie, Referer, User-Agent</p><ol><li>Accept：请求报头域，用于指定客户端可接受哪些类型的信息。 </li><li>Cookie：也常用复数形式 Cookies，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输入用户名和密码成功登录某个网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是Cookies的功劳。Cookies里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上Cookies并将其发送给服务器，服务器通过Cookies识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。  </li><li>Referer：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如作来源统计、防盗链处理等。  </li><li>User-Agent：简称UA，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出为爬虫  </li><li>x-requested-with :XMLHttpRequest   # 代表ajax请求</li><li>Accept-Language：指定客户端可接受的语言类型。</li><li>Accept-Encoding：指定客户端可接受的内容编码</li><li>Content-Type：也叫互联网媒体类型（Internet Media Type）或者MIME类型，在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。例如，text/html代表HTML格式，image/gif代表GIF图片，application/json代表JSON类型</li></ol><hr><h3 id="请求体："><a href="#请求体：" class="headerlink" title="请求体："></a>请求体：</h3><p>请求体一般承载的内容是POST请求中的表单数据，而对于GET请求，请求体则为空</p><hr><h2 id="10-响应"><a href="#10-响应" class="headerlink" title="10.响应"></a>10.响应</h2><p>由服务端返回给客户端的, 可以分为三部分: </p><ol><li>响应状态码(response status code)</li><li>响应头(response headers)</li><li>响应体(response body)</li></ol><hr><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码:"></a>响应状态码:</h3><p>用于判断请求后的响应状态, 如200代表请求成功, 404代表页面页面找不到, 500代表服务器错误</p><hr><h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码:"></a>常见的状态码:</h3><h5 id="200系列"><a href="#200系列" class="headerlink" title="200系列:"></a>200系列:</h5><pre class="highlight"><span class="line">200系列:</span><br><span class="line">200   成功         服务器已成功处理了请求  (**)</span><br><span class="line"></span><br><span class="line">300系列:</span><br><span class="line">    301    永久移动     请求的网页已永久移动到新位置，即永久重定向  (**)</span><br><span class="line">    302    临时移动     请求的网页暂时跳转到其他页面，即暂时重定向  (**)</span><br><span class="line"></span><br><span class="line">400系列:</span><br><span class="line">    400    错误请求     服务器无法解析该请求  (**)</span><br><span class="line">    401    未授权       请求没有进行身份验证或验证未通过</span><br><span class="line">    403    禁止访问     服务器拒绝此请求  (**)</span><br><span class="line">    404    未找到       服务器找不到请求的网页</span><br><span class="line"></span><br><span class="line">500系列</span><br><span class="line">    500    服务器内部错误   服务器遇到错误，无法完成请求  (**)</span><br><span class="line">    501    未实现       服务器不具备完成请求的功能</span><br><span class="line">    502    错误网关     服务器作为网关或代理，从上游服务器收到无效响应</span><br><span class="line">    504    网关超时     服务器作为网关或代理，但是没有及时从上游服务器收到请求</span><br><span class="line">    505    HTTP版本不支持   服务器不支持请求中所用的HTTP协议版本</span><br></pre><hr><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>状态码不能完全代表响应状态, 部分网站的状态码是自定义的, 一切以响应的数据为准</p><hr><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头:"></a>响应头:</h3><p>响应头包含了服务器对请求的应答信息</p><ul><li>Date：标识响应产生的时间。</li><li>Content-Encoding：指定响应内容的编码。</li><li>Server：包含服务器的信息，比如名称、版本号等。</li><li>Content-Type：文档类型，指定返回的数据类型是什么，如text/html代表返回HTML文档，application/x-javascript则代表返回JavaScript文件，image/jpeg则代表返回图片。</li><li>Set-Cookie：设置Cookies。响应头中的Set-Cookie告诉浏览器需要将此内容放在Cookies中，下次请求携带Cookies请求。</li><li>Expires：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。</li></ul><hr><h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体:"></a>响应体:</h3><p>最重要的当属响应体的内容了。响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的HTML代码；请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体.</p><hr><h2 id="11-网页基础"><a href="#11-网页基础" class="headerlink" title="11.网页基础"></a>11.网页基础</h2><p>网页可以分为三部分, HTML, CSS, JavaScript</p><ul><li>HTML: 其全称叫作Hyper Text Markup Language，即超文本标记语言，定义了网页的骨架    </li><li>CSS: 全称叫作Cascading Style Sheets，即层叠样式表，定义了网页的样式</li><li>JavaScript: 简称JS，是一种脚本语言定义了网页与用户的交互行为, 如下载进度条, 提示框, 播图 </li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
